"use strict";var t=require("@avalabs/avalanchejs"),e=require("viem");function n(t,...e){if(!((n=t)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Expected Uint8Array");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const i=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),r=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function o(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var e;return t}let a=class{clone(){return this._cloneInto()}};function c(t){const e=e=>t().update(o(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}class u extends a{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=i(this.buffer)}update(t){s(this);const{view:e,buffer:n,blockLen:r}=this,a=(t=o(t)).length;for(let s=0;s<a;){const o=Math.min(r-this.pos,a-s);if(o===r){const e=i(t);for(;r<=a-s;s+=r)this.process(e,s);continue}n.set(t.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===r&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){s(this),function(t,e){n(t);const s=e.outputLen;if(t.length<s)throw new Error(`digestInto() expects output buffer of length at least ${s}`)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:a}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let t=c;t<o;t++)e[t]=0;!function(t,e,n,s){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,s);const i=BigInt(32),r=BigInt(4294967295),o=Number(n>>i&r),a=Number(n&r),c=s?4:0,u=s?0:4;t.setUint32(e+c,o,s),t.setUint32(e+u,a,s)}(r,o-8,BigInt(8*this.length),a),this.process(r,0);const u=i(t),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=h/4,f=this.get();if(l>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<l;t++)u.setUint32(4*t,f[t],a)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:r,pos:o}=this;return t.length=s,t.pos=o,t.finished=i,t.destroyed=r,s%e&&t.buffer.set(n),t}}const h=(t,e,n)=>t&e^~t&n,l=(t,e,n)=>t&e^t&n^e&n,f=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),d=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);class g extends u{constructor(){super(64,32,8,!1),this.A=0|d[0],this.B=0|d[1],this.C=0|d[2],this.D=0|d[3],this.E=0|d[4],this.F=0|d[5],this.G=0|d[6],this.H=0|d[7]}get(){const{A:t,B:e,C:n,D:s,E:i,F:r,G:o,H:a}=this;return[t,e,n,s,i,r,o,a]}set(t,e,n,s,i,r,o,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|s,this.E=0|i,this.F=0|r,this.G=0|o,this.H=0|a}process(t,e){for(let n=0;n<16;n++,e+=4)p[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=p[t-15],n=p[t-2],s=r(e,7)^r(e,18)^e>>>3,i=r(n,17)^r(n,19)^n>>>10;p[t]=i+p[t-7]+s+p[t-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let t=0;t<64;t++){const e=d+(r(a,6)^r(a,11)^r(a,25))+h(a,c,u)+f[t]+p[t]|0,g=(r(n,2)^r(n,13)^r(n,22))+l(n,s,i)|0;d=u,u=c,c=a,a=o+e|0,o=i,i=s,s=n,n=e+g|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const y=c(()=>new g);function m(t,{includeName:e=!1}={}){if("function"!==t.type&&"event"!==t.type&&"error"!==t.type)throw new R(t.type);return`${t.name}(${b(t.inputs,{includeName:e})})`}function b(t,{includeName:e=!1}={}){return t?t.map(t=>function(t,{includeName:e}){if(t.type.startsWith("tuple"))return`(${b(t.components,{includeName:e})})${t.type.slice(5)}`;return t.type+(e&&t.name?` ${t.name}`:"")}(t,{includeName:e})).join(e?", ":","):""}function w(t,{strict:e=!0}={}){return!!t&&("string"==typeof t&&(e?/^0x[0-9a-fA-F]*$/.test(t):t.startsWith("0x")))}function v(t){return w(t,{strict:!1})?Math.ceil((t.length-2)/2):t.length}const x="2.38.6";let $=({docsBaseUrl:t,docsPath:e="",docsSlug:n})=>e?`${t??"https://viem.sh"}${e}${n?`#${n}`:""}`:void 0,A=`viem@${x}`;class I extends Error{constructor(t,e={}){const n=e.cause instanceof I?e.cause.details:e.cause?.message?e.cause.message:e.details,s=e.cause instanceof I&&e.cause.docsPath||e.docsPath,i=$?.({...e,docsPath:s});super([t||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...i?[`Docs: ${i}`]:[],...n?[`Details: ${n}`]:[],...A?[`Version: ${A}`]:[]].join("\n"),e.cause?{cause:e.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=n,this.docsPath=s,this.metaMessages=e.metaMessages,this.name=e.name??this.name,this.shortMessage=t,this.version=x}walk(t){return z(this,t)}}function z(t,e){return e?.(t)?t:t&&"object"==typeof t&&"cause"in t&&void 0!==t.cause?z(t.cause,e):e?null:t}class B extends I{constructor({data:t,params:e,size:n}){super([`Data size of ${n} bytes is too small for given parameters.`].join("\n"),{metaMessages:[`Params: (${b(e,{includeName:!0})})`,`Data:   ${t} (${n} bytes)`],name:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t,this.params=e,this.size=n}}class P extends I{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}}class E extends I{constructor({expectedLength:t,givenLength:e,type:n}){super([`ABI encoding array length mismatch for type ${n}.`,`Expected length: ${t}`,`Given length: ${e}`].join("\n"),{name:"AbiEncodingArrayLengthMismatchError"})}}class U extends I{constructor({expectedSize:t,value:e}){super(`Size of bytes "${e}" (bytes${v(e)}) does not match expected size (bytes${t}).`,{name:"AbiEncodingBytesSizeMismatchError"})}}class k extends I{constructor({expectedLength:t,givenLength:e}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${t}`,`Given length (values): ${e}`].join("\n"),{name:"AbiEncodingLengthMismatchError"})}}class L extends I{constructor({docsPath:t}){super("Cannot extract event signature from empty topics.",{docsPath:t,name:"AbiEventSignatureEmptyTopicsError"})}}class N extends I{constructor(t,{docsPath:e}){super([`Encoded event signature "${t}" not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it.",`You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join("\n"),{docsPath:e,name:"AbiEventSignatureNotFoundError"})}}class S extends I{constructor(t,{docsPath:e}={}){super([`Event ${t?`"${t}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the event exists on it."].join("\n"),{docsPath:e,name:"AbiEventNotFoundError"})}}class O extends I{constructor(t,e){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${t.type}\` in \`${m(t.abiItem)}\`, and`,`\`${e.type}\` in \`${m(e.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}}class j extends I{constructor({abiItem:t,data:e,params:n,size:s}){super([`Data size of ${s} bytes is too small for non-indexed event parameters.`].join("\n"),{metaMessages:[`Params: (${b(n,{includeName:!0})})`,`Data:   ${e} (${s} bytes)`],name:"DecodeLogDataMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=t,this.data=e,this.params=n,this.size=s}}class M extends I{constructor({abiItem:t,param:e}){super([`Expected a topic for indexed event parameter${e.name?` "${e.name}"`:""} on event "${m(t,{includeName:!0})}".`].join("\n"),{name:"DecodeLogTopicsMismatch"}),Object.defineProperty(this,"abiItem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abiItem=t}}class C extends I{constructor(t,{docsPath:e}){super([`Type "${t}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:e,name:"InvalidAbiEncodingType"})}}class D extends I{constructor(t,{docsPath:e}){super([`Type "${t}" is not a valid decoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:e,name:"InvalidAbiDecodingType"})}}class T extends I{constructor(t){super([`Value "${t}" is not a valid array.`].join("\n"),{name:"InvalidArrayError"})}}class R extends I{constructor(t){super([`"${t}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join("\n"),{name:"InvalidDefinitionTypeError"})}}class F extends I{constructor({address:t}){super(`Address "${t}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}class _ extends I{constructor({offset:t,position:e,size:n}){super(`Slice ${"start"===e?"starting":"ending"} at offset "${t}" is out-of-bounds (size: ${n}).`,{name:"SliceOffsetOutOfBoundsError"})}}class V extends I{constructor({size:t,targetSize:e,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${t}) exceeds padding size (${e}).`,{name:"SizeExceedsPaddingSizeError"})}}function H(t,{dir:e,size:n=32}={}){return"string"==typeof t?W(t,{dir:e,size:n}):function(t,{dir:e,size:n=32}={}){if(null===n)return t;if(t.length>n)throw new V({size:t.length,targetSize:n,type:"bytes"});const s=new Uint8Array(n);for(let i=0;i<n;i++){const r="right"===e;s[r?i:n-i-1]=t[r?i:t.length-i-1]}return s}(t,{dir:e,size:n})}function W(t,{dir:e,size:n=32}={}){if(null===n)return t;const s=t.replace("0x","");if(s.length>2*n)throw new V({size:Math.ceil(s.length/2),targetSize:n,type:"hex"});return`0x${s["right"===e?"padEnd":"padStart"](2*n,"0")}`}class q extends I{constructor({max:t,min:e,signed:n,size:s,value:i}){super(`Number "${i}" is not in safe ${s?`${8*s}-bit ${n?"signed":"unsigned"} `:""}integer range ${t?`(${e} to ${t})`:`(above ${e})`}`,{name:"IntegerOutOfRangeError"})}}class G extends I{constructor(t){super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}class X extends I{constructor({givenSize:t,maxSize:e}){super(`Size cannot exceed ${e} bytes. Given size: ${t} bytes.`,{name:"SizeOverflowError"})}}function Y(t,{dir:e="left"}={}){let n="string"==typeof t?t.replace("0x",""):t,s=0;for(let t=0;t<n.length-1&&"0"===n["left"===e?t:n.length-t-1].toString();t++)s++;return n="left"===e?n.slice(s):n.slice(0,n.length-s),"string"==typeof t?(1===n.length&&"right"===e&&(n=`${n}0`),`0x${n.length%2==1?`0${n}`:n}`):n}function J(t,{size:e}){if(v(t)>e)throw new X({givenSize:v(t),maxSize:e})}function K(t,e={}){const{signed:n}=e;e.size&&J(t,{size:e.size});const s=BigInt(t);if(!n)return s;const i=(t.length-2)/2;return s<=(1n<<8n*BigInt(i)-1n)-1n?s:s-BigInt(`0x${"f".padStart(2*i,"f")}`)-1n}const Z=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Q(t,e={}){const n=`0x${Number(t)}`;return"number"==typeof e.size?(J(n,{size:e.size}),H(n,{size:e.size})):n}function tt(t,e={}){let n="";for(let e=0;e<t.length;e++)n+=Z[t[e]];const s=`0x${n}`;return"number"==typeof e.size?(J(s,{size:e.size}),H(s,{dir:"right",size:e.size})):s}function et(t,e={}){const{signed:n,size:s}=e,i=BigInt(t);let r;s?r=n?(1n<<8n*BigInt(s)-1n)-1n:2n**(8n*BigInt(s))-1n:"number"==typeof t&&(r=BigInt(Number.MAX_SAFE_INTEGER));const o="bigint"==typeof r&&n?-r-1n:0;if(r&&i>r||i<o){const e="bigint"==typeof t?"n":"";throw new q({max:r?`${r}${e}`:void 0,min:`${o}${e}`,signed:n,size:s,value:`${t}${e}`})}const a=`0x${(n&&i<0?(1n<<BigInt(8*s))+BigInt(i):i).toString(16)}`;return s?H(a,{size:s}):a}const nt=new TextEncoder;function st(t,e={}){return tt(nt.encode(t),e)}const it=new TextEncoder;function rt(t,e={}){return"number"==typeof t||"bigint"==typeof t?function(t,e){const n=et(t,e);return ct(n)}(t,e):"boolean"==typeof t?function(t,e={}){const n=new Uint8Array(1);if(n[0]=Number(t),"number"==typeof e.size)return J(n,{size:e.size}),H(n,{size:e.size});return n}(t,e):w(t)?ct(t,e):ut(t,e)}const ot={zero:48,nine:57,A:65,F:70,a:97,f:102};function at(t){return t>=ot.zero&&t<=ot.nine?t-ot.zero:t>=ot.A&&t<=ot.F?t-(ot.A-10):t>=ot.a&&t<=ot.f?t-(ot.a-10):void 0}function ct(t,e={}){let n=t;e.size&&(J(n,{size:e.size}),n=H(n,{dir:"right",size:e.size}));let s=n.slice(2);s.length%2&&(s=`0${s}`);const i=s.length/2,r=new Uint8Array(i);for(let t=0,e=0;t<i;t++){const n=at(s.charCodeAt(e++)),i=at(s.charCodeAt(e++));if(void 0===n||void 0===i)throw new I(`Invalid byte sequence ("${s[e-2]}${s[e-1]}" in "${s}").`);r[t]=16*n+i}return r}function ut(t,e={}){const n=it.encode(t);return"number"==typeof e.size?(J(n,{size:e.size}),H(n,{dir:"right",size:e.size})):n}const ht=BigInt(2**32-1),lt=BigInt(32);function ft(t,e=!1){return e?{h:Number(t&ht),l:Number(t>>lt&ht)}:{h:0|Number(t>>lt&ht),l:0|Number(t&ht)}}function dt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function pt(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function gt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function yt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function mt(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}const bt=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?t=>t:function(t){for(let e=0;e<t.length;e++)t[e]=mt(t[e]);return t};function wt(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),pt(t),t}class vt{}const xt=BigInt(0),$t=BigInt(1),At=BigInt(2),It=BigInt(7),zt=BigInt(256),Bt=BigInt(113),Pt=[],Et=[],Ut=[];for(let t=0,e=$t,n=1,s=0;t<24;t++){[n,s]=[s,(2*n+3*s)%5],Pt.push(2*(5*s+n)),Et.push((t+1)*(t+2)/2%64);let i=xt;for(let t=0;t<7;t++)e=(e<<$t^(e>>It)*Bt)%zt,e&At&&(i^=$t<<($t<<BigInt(t))-$t);Ut.push(i)}const kt=function(t,e=!1){const n=t.length;let s=new Uint32Array(n),i=new Uint32Array(n);for(let r=0;r<n;r++){const{h:n,l:o}=ft(t[r],e);[s[r],i[r]]=[n,o]}return[s,i]}(Ut,!0),Lt=kt[0],Nt=kt[1],St=(t,e,n)=>n>32?((t,e,n)=>e<<n-32|t>>>64-n)(t,e,n):((t,e,n)=>t<<n|e>>>32-n)(t,e,n),Ot=(t,e,n)=>n>32?((t,e,n)=>t<<n-32|e>>>64-n)(t,e,n):((t,e,n)=>e<<n|t>>>32-n)(t,e,n);class jt extends vt{constructor(t,e,n,s=!1,i=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=n,this.enableXOF=s,this.rounds=i,dt(n),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");var r;this.state=new Uint8Array(200),this.state32=(r=this.state,new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4)))}clone(){return this._cloneInto()}keccak(){bt(this.state32),function(t,e=24){const n=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const s=(e+8)%10,i=(e+2)%10,r=n[i],o=n[i+1],a=St(r,o,1)^n[s],c=Ot(r,o,1)^n[s+1];for(let n=0;n<50;n+=10)t[e+n]^=a,t[e+n+1]^=c}let e=t[2],i=t[3];for(let n=0;n<24;n++){const s=Et[n],r=St(e,i,s),o=Ot(e,i,s),a=Pt[n];e=t[a],i=t[a+1],t[a]=r,t[a+1]=o}for(let e=0;e<50;e+=10){for(let s=0;s<10;s++)n[s]=t[e+s];for(let s=0;s<10;s++)t[e+s]^=~n[(s+2)%10]&n[(s+4)%10]}t[0]^=Lt[s],t[1]^=Nt[s]}yt(n)}(this.state32,this.rounds),bt(this.state32),this.posOut=0,this.pos=0}update(t){gt(this),pt(t=wt(t));const{blockLen:e,state:n}=this,s=t.length;for(let i=0;i<s;){const r=Math.min(e-this.pos,s-i);for(let e=0;e<r;e++)n[this.pos++]^=t[i++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:s}=this;t[n]^=e,128&e&&n===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){gt(this,!1),pt(t),this.finish();const e=this.state,{blockLen:n}=this;for(let s=0,i=t.length;s<i;){this.posOut>=n&&this.keccak();const r=Math.min(n-this.posOut,i-s);t.set(e.subarray(this.posOut,this.posOut+r),s),this.posOut+=r,s+=r}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return dt(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){pt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,yt(this.state)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:s,rounds:i,enableXOF:r}=this;return t||(t=new jt(e,n,s,r,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=n,t.outputLen=s,t.enableXOF=r,t.destroyed=this.destroyed,t}}const Mt=(t,e,n)=>function(t){const e=e=>t().update(wt(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}(()=>new jt(e,t,n)),Ct=(()=>Mt(1,136,32))();function Dt(t,e){const n=e||"hex",s=Ct(w(t,{strict:!1})?rt(t):t);return"bytes"===n?s:function(t,e={}){return"number"==typeof t||"bigint"==typeof t?et(t,e):"string"==typeof t?st(t,e):"boolean"==typeof t?Q(t,e):tt(t,e)}(s)}class Tt extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const e=super.get(t);return super.has(t)&&void 0!==e&&(this.delete(t),super.set(t,e)),e}set(t,e){if(super.set(t,e),this.maxSize&&this.size>this.maxSize){const t=this.keys().next().value;t&&this.delete(t)}return this}}const Rt=/^0x[a-fA-F0-9]{40}$/,Ft=new Tt(8192);function _t(t,e){const{strict:n=!0}=e??{},s=`${t}.${n}`;if(Ft.has(s))return Ft.get(s);const i=!(!Rt.test(t)||t.toLowerCase()!==t&&n&&Ht(t)!==t);return Ft.set(s,i),i}const Vt=new Tt(8192);function Ht(t,e){if(Vt.has(`${t}.${e}`))return Vt.get(`${t}.${e}`);const n=t.substring(2).toLowerCase(),s=Dt(ut(n),"bytes"),i=n.split("");for(let t=0;t<40;t+=2)s[t>>1]>>4>=8&&i[t]&&(i[t]=i[t].toUpperCase()),(15&s[t>>1])>=8&&i[t+1]&&(i[t+1]=i[t+1].toUpperCase());const r=`0x${i.join("")}`;return Vt.set(`${t}.${e}`,r),r}class Wt extends I{constructor({offset:t}){super(`Offset \`${t}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class qt extends I{constructor({length:t,position:e}){super(`Position \`${e}\` is out of bounds (\`0 < position < ${t}\`).`,{name:"PositionOutOfBoundsError"})}}class Gt extends I{constructor({count:t,limit:e}){super(`Recursive read limit of \`${e}\` exceeded (recursive read count: \`${t}\`).`,{name:"RecursiveReadLimitExceededError"})}}const Xt={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new Gt({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(t){if(t<0||t>this.bytes.length-1)throw new qt({length:this.bytes.length,position:t})},decrementPosition(t){if(t<0)throw new Wt({offset:t});const e=this.position-t;this.assertPosition(e),this.position=e},getReadCount(t){return this.positionReadCount.get(t||this.position)||0},incrementPosition(t){if(t<0)throw new Wt({offset:t});const e=this.position+t;this.assertPosition(e),this.position=e},inspectByte(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectBytes(t,e){const n=e??this.position;return this.assertPosition(n+t-1),this.bytes.subarray(n,n+t)},inspectUint8(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectUint16(t){const e=t??this.position;return this.assertPosition(e+1),this.dataView.getUint16(e)},inspectUint24(t){const e=t??this.position;return this.assertPosition(e+2),(this.dataView.getUint16(e)<<8)+this.dataView.getUint8(e+2)},inspectUint32(t){const e=t??this.position;return this.assertPosition(e+3),this.dataView.getUint32(e)},pushByte(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushBytes(t){this.assertPosition(this.position+t.length-1),this.bytes.set(t,this.position),this.position+=t.length},pushUint8(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushUint16(t){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,t),this.position+=2},pushUint24(t){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,t>>8),this.dataView.setUint8(this.position+2,255&t),this.position+=3},pushUint32(t){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,t),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const t=this.inspectByte();return this.position++,t},readBytes(t,e){this.assertReadLimit(),this._touch();const n=this.inspectBytes(t);return this.position+=e??t,n},readUint8(){this.assertReadLimit(),this._touch();const t=this.inspectUint8();return this.position+=1,t},readUint16(){this.assertReadLimit(),this._touch();const t=this.inspectUint16();return this.position+=2,t},readUint24(){this.assertReadLimit(),this._touch();const t=this.inspectUint24();return this.position+=3,t},readUint32(){this.assertReadLimit(),this._touch();const t=this.inspectUint32();return this.position+=4,t},get remaining(){return this.bytes.length-this.position},setPosition(t){const e=this.position;return this.assertPosition(t),this.position=t,()=>this.position=e},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const t=this.getReadCount();this.positionReadCount.set(this.position,t+1),t>0&&this.recursiveReadCount++}};function Yt(t,e,n,{strict:s}={}){return w(t,{strict:!1})?function(t,e,n,{strict:s}={}){Jt(t,e);const i=`0x${t.replace("0x","").slice(2*(e??0),2*(n??t.length))}`;s&&Kt(i,e,n);return i}(t,e,n,{strict:s}):Zt(t,e,n,{strict:s})}function Jt(t,e){if("number"==typeof e&&e>0&&e>v(t)-1)throw new _({offset:e,position:"start",size:v(t)})}function Kt(t,e,n){if("number"==typeof e&&"number"==typeof n&&v(t)!==n-e)throw new _({offset:n,position:"end",size:v(t)})}function Zt(t,e,n,{strict:s}={}){Jt(t,e);const i=t.slice(e,n);return s&&Kt(i,e,n),i}function Qt(t,e={}){void 0!==e.size&&J(t,{size:e.size});return K(tt(t,e),e)}function te(t,e={}){let n=t;if(void 0!==e.size&&(J(n,{size:e.size}),n=Y(n)),n.length>1||n[0]>1)throw new G(n);return Boolean(n[0])}function ee(t,e={}){void 0!==e.size&&J(t,{size:e.size});return function(t,e={}){return Number(K(t,e))}(tt(t,e),e)}function ne(t){return"string"==typeof t[0]?function(t){return`0x${t.reduce((t,e)=>t+e.replace("0x",""),"")}`}(t):function(t){let e=0;for(const n of t)e+=n.length;const n=new Uint8Array(e);let s=0;for(const e of t)n.set(e,s),s+=e.length;return n}(t)}const se=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function ie(t,e){if(t.length!==e.length)throw new k({expectedLength:t.length,givenLength:e.length});const n=function({params:t,values:e}){const n=[];for(let s=0;s<t.length;s++)n.push(re({param:t[s],value:e[s]}));return n}({params:t,values:e}),s=oe(n);return 0===s.length?"0x":s}function re({param:t,value:e}){const n=ae(t.type);if(n){const[s,i]=n;return function(t,{length:e,param:n}){const s=null===e;if(!Array.isArray(t))throw new T(t);if(!s&&t.length!==e)throw new E({expectedLength:e,givenLength:t.length,type:`${n.type}[${e}]`});let i=!1;const r=[];for(let e=0;e<t.length;e++){const s=re({param:n,value:t[e]});s.dynamic&&(i=!0),r.push(s)}if(s||i){const t=oe(r);if(s){const e=et(r.length,{size:32});return{dynamic:!0,encoded:r.length>0?ne([e,t]):e}}if(i)return{dynamic:!0,encoded:t}}return{dynamic:!1,encoded:ne(r.map(({encoded:t})=>t))}}(e,{length:s,param:{...t,type:i}})}if("tuple"===t.type)return function(t,{param:e}){let n=!1;const s=[];for(let i=0;i<e.components.length;i++){const r=e.components[i],o=re({param:r,value:t[Array.isArray(t)?i:r.name]});s.push(o),o.dynamic&&(n=!0)}return{dynamic:n,encoded:n?oe(s):ne(s.map(({encoded:t})=>t))}}(e,{param:t});if("address"===t.type)return function(t){if(!_t(t))throw new F({address:t});return{dynamic:!1,encoded:W(t.toLowerCase())}}(e);if("bool"===t.type)return function(t){if("boolean"!=typeof t)throw new I(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:W(Q(t))}}(e);if(t.type.startsWith("uint")||t.type.startsWith("int")){const n=t.type.startsWith("int"),[,,s="256"]=se.exec(t.type)??[];return function(t,{signed:e,size:n=256}){if("number"==typeof n){const s=2n**(BigInt(n)-(e?1n:0n))-1n,i=e?-s-1n:0n;if(t>s||t<i)throw new q({max:s.toString(),min:i.toString(),signed:e,size:n/8,value:t.toString()})}return{dynamic:!1,encoded:et(t,{size:32,signed:e})}}(e,{signed:n,size:Number(s)})}if(t.type.startsWith("bytes"))return function(t,{param:e}){const[,n]=e.type.split("bytes"),s=v(t);if(!n){let e=t;return s%32!=0&&(e=W(e,{dir:"right",size:32*Math.ceil((t.length-2)/2/32)})),{dynamic:!0,encoded:ne([W(et(s,{size:32})),e])}}if(s!==Number.parseInt(n,10))throw new U({expectedSize:Number.parseInt(n,10),value:t});return{dynamic:!1,encoded:W(t,{dir:"right"})}}(e,{param:t});if("string"===t.type)return function(t){const e=st(t),n=Math.ceil(v(e)/32),s=[];for(let t=0;t<n;t++)s.push(W(Yt(e,32*t,32*(t+1)),{dir:"right"}));return{dynamic:!0,encoded:ne([W(et(v(e),{size:32})),...s])}}(e);throw new C(t.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function oe(t){let e=0;for(let n=0;n<t.length;n++){const{dynamic:s,encoded:i}=t[n];e+=s?32:v(i)}const n=[],s=[];let i=0;for(let r=0;r<t.length;r++){const{dynamic:o,encoded:a}=t[r];o?(n.push(et(e+i,{size:32})),s.push(a),i+=v(a)):n.push(a)}return ne([...n,...s])}function ae(t){const e=t.match(/^(.*)\[(\d+)?\]$/);return e?[e[2]?Number(e[2]):null,e[1]]:void 0}function ce(t,e){const n="string"==typeof e?ct(e):e,s=function(t,{recursiveReadLimit:e=8192}={}){const n=Object.create(Xt);return n.bytes=t,n.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=e,n}(n);if(0===v(n)&&t.length>0)throw new P;if(v(e)&&v(e)<32)throw new B({data:"string"==typeof e?e:tt(e),params:t,size:v(e)});let i=0;const r=[];for(let e=0;e<t.length;++e){const n=t[e];s.setPosition(i);const[o,a]=ue(s,n,{staticPosition:0});i+=a,r.push(o)}return r}function ue(t,e,{staticPosition:n}){const s=ae(e.type);if(s){const[i,r]=s;return function(t,e,{length:n,staticPosition:s}){if(!n){const n=s+ee(t.readBytes(le)),i=n+he;t.setPosition(n);const r=ee(t.readBytes(he)),o=fe(e);let a=0;const c=[];for(let n=0;n<r;++n){t.setPosition(i+(o?32*n:a));const[s,r]=ue(t,e,{staticPosition:i});a+=r,c.push(s)}return t.setPosition(s+32),[c,32]}if(fe(e)){const i=s+ee(t.readBytes(le)),r=[];for(let s=0;s<n;++s){t.setPosition(i+32*s);const[n]=ue(t,e,{staticPosition:i});r.push(n)}return t.setPosition(s+32),[r,32]}let i=0;const r=[];for(let o=0;o<n;++o){const[n,o]=ue(t,e,{staticPosition:s+i});i+=o,r.push(n)}return[r,i]}(t,{...e,type:r},{length:i,staticPosition:n})}if("tuple"===e.type)return function(t,e,{staticPosition:n}){const s=0===e.components.length||e.components.some(({name:t})=>!t),i=s?[]:{};let r=0;if(fe(e)){const o=n+ee(t.readBytes(le));for(let n=0;n<e.components.length;++n){const a=e.components[n];t.setPosition(o+r);const[c,u]=ue(t,a,{staticPosition:o});r+=u,i[s?n:a?.name]=c}return t.setPosition(n+32),[i,32]}for(let o=0;o<e.components.length;++o){const a=e.components[o],[c,u]=ue(t,a,{staticPosition:n});i[s?o:a?.name]=c,r+=u}return[i,r]}(t,e,{staticPosition:n});if("address"===e.type)return function(t){const e=t.readBytes(32);return[Ht(tt(Zt(e,-20))),32]}(t);if("bool"===e.type)return function(t){return[te(t.readBytes(32),{size:32}),32]}(t);if(e.type.startsWith("bytes"))return function(t,e,{staticPosition:n}){const[s,i]=e.type.split("bytes");if(!i){const e=ee(t.readBytes(32));t.setPosition(n+e);const s=ee(t.readBytes(32));if(0===s)return t.setPosition(n+32),["0x",32];const i=t.readBytes(s);return t.setPosition(n+32),[tt(i),32]}const r=tt(t.readBytes(Number.parseInt(i,10),32));return[r,32]}(t,e,{staticPosition:n});if(e.type.startsWith("uint")||e.type.startsWith("int"))return function(t,e){const n=e.type.startsWith("int"),s=Number.parseInt(e.type.split("int")[1]||"256",10),i=t.readBytes(32);return[s>48?Qt(i,{signed:n}):ee(i,{signed:n}),32]}(t,e);if("string"===e.type)return function(t,{staticPosition:e}){const n=ee(t.readBytes(32)),s=e+n;t.setPosition(s);const i=ee(t.readBytes(32));if(0===i)return t.setPosition(e+32),["",32];const r=t.readBytes(i,32),o=function(t,e={}){let n=t;return void 0!==e.size&&(J(n,{size:e.size}),n=Y(n,{dir:"right"})),(new TextDecoder).decode(n)}(Y(r));return t.setPosition(e+32),[o,32]}(t,{staticPosition:n});throw new D(e.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const he=32,le=32;function fe(t){const{type:e}=t;if("string"===e)return!0;if("bytes"===e)return!0;if(e.endsWith("[]"))return!0;if("tuple"===e)return t.components?.some(fe);const n=ae(t.type);return!(!n||!fe({...t,type:n[1]}))}function de(t){return Dt(rt(t))}const pe=/^tuple(?<array>(\[(\d*)\])*)$/;function ge(t){let e=t.type;if(pe.test(t.type)&&"components"in t){e="(";const n=t.components.length;for(let s=0;s<n;s++){e+=ge(t.components[s]),s<n-1&&(e+=", ")}const s=function(t,e){const n=t.exec(e);return n?.groups}(pe,t.type);return e+=`)${s?.array??""}`,ge({...t,type:e})}return"indexed"in t&&t.indexed&&(e=`${e} indexed`),t.name?`${e} ${t.name}`:e}function ye(t){let e="";const n=t.length;for(let s=0;s<n;s++){e+=ge(t[s]),s!==n-1&&(e+=", ")}return e}const me=t=>{var e;return function(t){let e=!0,n="",s=0,i="",r=!1;for(let o=0;o<t.length;o++){const a=t[o];if(["(",")",","].includes(a)&&(e=!0),"("===a&&s++,")"===a&&s--,e)if(0!==s)" "!==a?(i+=a,n+=a):","!==t[o-1]&&","!==n&&",("!==n&&(n="",e=!1);else if(" "===a&&["event","function",""].includes(i))i="";else if(i+=a,")"===a){r=!0;break}}if(!r)throw new I("Unable to normalize signature.");return i}("string"==typeof t?t:"function"===(e=t).type?`function ${e.name}(${ye(e.inputs)})${e.stateMutability&&"nonpayable"!==e.stateMutability?` ${e.stateMutability}`:""}${e.outputs?.length?` returns (${ye(e.outputs)})`:""}`:"event"===e.type?`event ${e.name}(${ye(e.inputs)})`:"error"===e.type?`error ${e.name}(${ye(e.inputs)})`:"constructor"===e.type?`constructor(${ye(e.inputs)})${"payable"===e.stateMutability?" payable":""}`:"fallback"===e.type?"fallback() external"+("payable"===e.stateMutability?" payable":""):"receive() external payable")};function be(t){return de(me(t))}const we=be;function ve(t){const{abi:e,args:n=[],name:s}=t,i=w(s,{strict:!1}),r=e.filter(t=>i?"function"===t.type?Yt(be(t),0,4)===s:"event"===t.type&&we(t)===s:"name"in t&&t.name===s);if(0===r.length)return;if(1===r.length)return r[0];let o;for(const t of r){if(!("inputs"in t))continue;if(!n||0===n.length){if(!t.inputs||0===t.inputs.length)return t;continue}if(!t.inputs)continue;if(0===t.inputs.length)continue;if(t.inputs.length!==n.length)continue;if(n.every((e,n)=>{const s="inputs"in t&&t.inputs[n];return!!s&&xe(e,s)})){if(o&&"inputs"in o&&o.inputs){const e=$e(t.inputs,o.inputs,n);if(e)throw new O({abiItem:t,type:e[0]},{abiItem:o,type:e[1]})}o=t}}return o||r[0]}function xe(t,e){const n=typeof t,s=e.type;switch(s){case"address":return _t(t,{strict:!1});case"bool":return"boolean"===n;case"function":case"string":return"string"===n;default:return"tuple"===s&&"components"in e?Object.values(e.components).every((e,n)=>xe(Object.values(t)[n],e)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?"number"===n||"bigint"===n:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?"string"===n||t instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)&&(Array.isArray(t)&&t.every(t=>xe(t,{...e,type:s.replace(/(\[[0-9]{0,}\])$/,"")})))}}function $e(t,e,n){for(const s in t){const i=t[s],r=e[s];if("tuple"===i.type&&"tuple"===r.type&&"components"in i&&"components"in r)return $e(i.components,r.components,n[s]);const o=[i.type,r.type];if((()=>!(!o.includes("address")||!o.includes("bytes20"))||(o.includes("address")&&o.includes("string")||!(!o.includes("address")||!o.includes("bytes")))&&_t(n[s],{strict:!1}))())return o}}class Ae extends I{constructor(t){super(`Filter type "${t}" is not supported.`,{name:"FilterTypeNotSupportedError"})}}const Ie="/docs/contract/encodeEventTopics";function ze({param:t,value:e}){if("string"===t.type||"bytes"===t.type)return Dt(rt(e));if("tuple"===t.type||t.type.match(/^(.*)\[(\d+)?\]$/))throw new Ae(t.type);return ie([t],[e])}const Be=new Map,Pe=new Map;async function Ee(t,{cacheKey:e,cacheTime:n=Number.POSITIVE_INFINITY}){const s=function(t){const e=(t,e)=>({clear:()=>e.delete(t),get:()=>e.get(t),set:n=>e.set(t,n)}),n=e(t,Be),s=e(t,Pe);return{clear:()=>{n.clear(),s.clear()},promise:n,response:s}}(e),i=s.response.get();if(i&&n>0){if(Date.now()-i.created.getTime()<n)return i.data}let r=s.promise.get();r||(r=t(),s.promise.set(r));try{const t=await r;return s.response.set({created:new Date,data:t}),t}finally{s.promise.clear()}}const Ue="/docs/contract/decodeEventLog";function ke({param:t,value:e}){if("string"===t.type||"bytes"===t.type||"tuple"===t.type||t.type.match(/^(.*)\[(\d+)?\]$/))return e;return(ce([t],e)||[])[0]}function Le(t){const{abi:e,args:n,logs:s,strict:i=!0}=t,r=(()=>{if(t.eventName)return Array.isArray(t.eventName)?t.eventName:[t.eventName]})();return s.map(t=>{try{const s=e.find(e=>"event"===e.type&&t.topics[0]===we(e));if(!s)return null;const o=function(t){const{abi:e,data:n,strict:s,topics:i}=t,r=s??!0,[o,...a]=i;if(!o)throw new L({docsPath:Ue});const c=e.find(t=>"event"===t.type&&o===we(m(t)));if(!c||!("name"in c)||"event"!==c.type)throw new N(o,{docsPath:Ue});const{name:u,inputs:h}=c,l=h?.some(t=>!("name"in t&&t.name)),f=l?[]:{},d=h.map((t,e)=>[t,e]).filter(([t])=>"indexed"in t&&t.indexed);for(let t=0;t<d.length;t++){const[e,n]=d[t],s=a[t];if(!s)throw new M({abiItem:c,param:e});f[l?n:e.name||n]=ke({param:e,value:s})}const p=h.filter(t=>!("indexed"in t&&t.indexed));if(p.length>0)if(n&&"0x"!==n)try{const t=ce(p,n);if(t)if(l)for(let e=0;e<h.length;e++)f[e]=f[e]??t.shift();else for(let e=0;e<p.length;e++)f[p[e].name]=t[e]}catch(t){if(r){if(t instanceof B||t instanceof qt)throw new j({abiItem:c,data:n,params:p,size:v(n)});throw t}}else if(r)throw new j({abiItem:c,data:"0x",params:p,size:0});return{eventName:u,args:Object.values(f).length>0?f:void 0}}({...t,abi:[s],strict:i});return r&&!r.includes(o.eventName)?null:function(t){const{args:e,inputs:n,matchArgs:s}=t;if(!s)return!0;if(!e)return!1;function i(t,e,n){try{return"address"===t.type?function(t,e){if(!_t(t,{strict:!1}))throw new F({address:t});if(!_t(e,{strict:!1}))throw new F({address:e});return t.toLowerCase()===e.toLowerCase()}(e,n):"string"===t.type||"bytes"===t.type?Dt(rt(e))===n:e===n}catch{return!1}}if(Array.isArray(e)&&Array.isArray(s))return s.every((t,s)=>{if(null==t)return!0;const r=n[s];if(!r)return!1;return(Array.isArray(t)?t:[t]).some(t=>i(r,t,e[s]))});return"object"==typeof e&&!Array.isArray(e)&&"object"==typeof s&&!Array.isArray(s)&&Object.entries(s).every(([t,s])=>{if(null==s)return!0;const r=n.find(e=>e.name===t);if(!r)return!1;return(Array.isArray(s)?s:[s]).some(n=>i(r,n,e[t]))})}({args:o.args,inputs:s.inputs,matchArgs:n})?{...o,...t}:null}catch(e){let n,s;if(e instanceof N)return null;if(e instanceof j||e instanceof M){if(i)return null;n=e.abiItem.name,s=e.abiItem.inputs?.some(t=>!("name"in t&&t.name))}return{...t,args:s?[]:{},eventName:n}}}).filter(Boolean)}async function Ne(t,{address:e,blockHash:n,fromBlock:s,toBlock:i,event:r,events:o,args:a,strict:c}={}){const u=c??!1,h=o??(r?[r]:void 0);let l,f=[];if(h){const t=h.flatMap(t=>function(t){const{abi:e,eventName:n,args:s}=t;let i=e[0];if(n){const t=ve({abi:e,name:n});if(!t)throw new S(n,{docsPath:Ie});i=t}if("event"!==i.type)throw new S(void 0,{docsPath:Ie});const r=m(i),o=we(r);let a=[];if(s&&"inputs"in i){const t=i.inputs?.filter(t=>"indexed"in t&&t.indexed),e=Array.isArray(s)?s:Object.values(s).length>0?t?.map(t=>s[t.name])??[]:[];e.length>0&&(a=t?.map((t,n)=>Array.isArray(e[n])?e[n].map((s,i)=>ze({param:t,value:e[n][i]})):void 0!==e[n]&&null!==e[n]?ze({param:t,value:e[n]}):null)??[])}return[o,...a]}({abi:[t],eventName:t.name,args:o?void 0:a}));f=[t],r&&(f=f[0])}l=n?await t.request({method:"eth_getLogs",params:[{address:e,topics:f,blockHash:n}]}):await t.request({method:"eth_getLogs",params:[{address:e,topics:f,fromBlock:"bigint"==typeof s?et(s):s,toBlock:"bigint"==typeof i?et(i):i}]});const d=l.map(t=>function(t,{args:e,eventName:n}={}){return{...t,blockHash:t.blockHash?t.blockHash:null,blockNumber:t.blockNumber?BigInt(t.blockNumber):null,logIndex:t.logIndex?Number(t.logIndex):null,transactionHash:t.transactionHash?t.transactionHash:null,transactionIndex:t.transactionIndex?Number(t.transactionIndex):null,...n?{args:e,eventName:n}:{}}}(t));return h?Le({abi:h,args:a,logs:d,strict:u}):d}function Se(t){const e=[];for(;t>=128;)e.push(127&t|128),t>>>=7;return e.push(t),new Uint8Array(e)}function Oe(t,e){const n=function(t){const e=Buffer.alloc(4);return e.writeUInt32BE(t,0),new Uint8Array(e)}(e),s=new Uint8Array(t.length+n.length);return s.set(t,0),s.set(n,t.length),s}function je(t,e){const n=new Uint8Array([10]),s=Se(t.length),i=new Uint8Array([16]),r=Se(e),o=n.length+s.length+t.length+i.length+r.length,a=new Uint8Array(o);let c=0;a.set(n,c),c+=n.length,a.set(s,c),c+=s.length,a.set(t,c),c+=t.length,a.set(i,c),c+=i.length,a.set(r,c);const u=new Uint8Array([10]),h=Se(a.length),l=new Uint8Array(u.length+h.length+a.length);return c=0,l.set(u,c),c+=u.length,l.set(h,c),c+=h.length,l.set(a,c),l}function Me(t){const e=new Uint8Array([18]),n=Se(t.length),s=new Uint8Array(e.length+n.length+t.length);return s.set(e,0),s.set(n,e.length),s.set(t,e.length+n.length),s}const Ce=e.parseAbiItem("event SendWarpMessage(address indexed sourceAddress, bytes32 indexed unsignedMessageID, bytes message)"),De="0x0200000000000000000000000000000000000005";function Te(t,e,n,s){if("desc"===n){const n=Math.max(0,Number(t)-e+1);return{fromBlock:n,toBlock:Number(t),shouldStopAfter:0===n}}{const n=Number(t),i=Math.min(Number(s),Number(t)+e-1);return{fromBlock:n,toBlock:i,shouldStopAfter:i>=Number(s)}}}function Re(e,n,s){const i=t.pvmSerial.warp.getWarpManager();for(const s of e)try{const e=s,r=e.args?.message;if(!r)continue;const o=Buffer.from(r.slice(2),"hex"),a=i.unpack(o,t.pvmSerial.warp.WarpUnsignedMessage),c=i.unpack(t.utils.hexToBuffer(a.payload.toJSON()),t.pvmSerial.warp.AddressedCallPayloads.AddressedCall),u=t.utils.hexToBuffer(c.getPayload());if(!u)continue;const[,h]=t.Short.fromBytes(u),[l]=t.Int.fromBytes(h);if(1!==l.value())continue;try{const e=i.unpack(u,t.pvmSerial.warp.AddressedCallPayloads.RegisterL1ValidatorMessage).toBytes(t.pvmSerial.warp.codec),s=Uint8Array.from([...new t.Short(0).toBytes(),...e]),r=y(s);if(t.utils.bytesEqual(r,n)){return Me(u)}}catch(t){}}catch(t){}return null}exports.baseFee=async function(t){return t.request({method:"eth_baseFee",params:[]})},exports.feeConfig=async function(t,{blk:e}){return t.request({method:"eth_feeConfig",params:[e??"latest"]})},exports.getActiveRulesAt=async function(t,{timestamp:e}){return t.request({method:"eth_getActiveRulesAt",params:[e??"latest"]})},exports.getChainConfig=async function(t){return t.request({method:"eth_getChainConfig",params:[]})},exports.getRegistrationJustification=async function(n,s){const i=s.maxBootstrapValidators??100,{validationID:r,subnetIDStr:o}=s;let a,c,u;try{if(!r)throw new Error("Found empty validationID");if(c=r.startsWith("0x")?r:t.utils.bufferToHex(t.utils.base58check.decode(r)),a=e.hexToBytes(c),32!==a.length)throw new Error(`Decoded validationID must be 32 bytes, got ${a.length}`)}catch(t){return{justification:null,error:`Failed to decode provided validationIDHex '${c}': ${t.message}`}}try{if(!o)throw new Error("Found empty subnetIDStr");u=t.utils.base58check.decode(o)}catch(t){return{justification:null,error:`Failed to decode provided SubnetID: ${o}: ${t.message}`}}for(let e=0;e<i;e++){const n=Oe(u,e),s=y(n);if(t.utils.bytesEqual(s,a)){return{justification:je(u,e)}}}return await async function(t,e,n,s){const i=2e3,r=100,o=e.maxChunks??r,a=e.searchOrder??"desc",c=e.chunkSize??i;try{const i=await async function(t,{cacheTime:e=t.cacheTime}={}){const n=await Ee(()=>t.request({method:"eth_blockNumber"}),{cacheKey:(s=t.uid,`blockNumber.${s}`),cacheTime:e});var s;return BigInt(n)}(t);let r="latest"===e.startBlock||void 0===e.startBlock?i:BigInt(e.startBlock),u=0;for(;u<o;){const{fromBlock:e,toBlock:o,shouldStopAfter:h}=Te(r,c,a,i),l=await Ne(t,{address:De,event:Ce,fromBlock:BigInt(e),toBlock:BigInt(o)});if(l.length>0){const t=Re(l.slice().reverse(),n,s);if(t)return{justification:t}}if(h)break;if(r="desc"===a?BigInt(e)-1n:BigInt(o)+1n,"asc"===a&&r>i)break;u++}return{justification:null}}catch(t){return{justification:null,error:`Error fetching or decoding logs for ValidationID ${s}: ${t}`}}}(n,s,a,c)},exports.maxPriorityFeePerGas=async function(t){return t.request({method:"eth_maxPriorityFeePerGas",params:[]})};
