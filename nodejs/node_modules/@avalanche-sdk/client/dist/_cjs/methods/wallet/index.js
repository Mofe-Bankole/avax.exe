"use strict";var e=require("@avalabs/avalanchejs"),t=require("viem");function n(e){var t=Object.create(null);return e&&Object.keys(e).forEach(function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}}),t.default=e,Object.freeze(t)}var r=n(require("node:crypto"));async function s(e){return e.request({method:"avalanche_getAccountPubKey",params:{}})}function i(e,{strict:t=!0}={}){return!!e&&("string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")))}function o(e){return i(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}const a="2.38.6";let c=({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,u=`viem@${a}`;class l extends Error{constructor(e,t={}){const n=t.cause instanceof l?t.cause.details:t.cause?.message?t.cause.message:t.details,r=t.cause instanceof l&&t.cause.docsPath||t.docsPath,s=c?.({...t,docsPath:r});super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...s?[`Docs: ${s}`]:[],...n?[`Details: ${n}`]:[],...u?[`Version: ${u}`]:[]].join("\n"),t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=n,this.docsPath=r,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=a}walk(e){return d(this,e)}}function d(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e&&void 0!==e.cause?d(e.cause,t):t?null:e}class h extends l{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}class f extends l{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}class p extends l{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${t} ${n} long, but is ${e} ${n} long.`,{name:"InvalidBytesLengthError"})}}function m(e,{dir:t,size:n=32}={}){return"string"==typeof e?function(e,{dir:t,size:n=32}={}){if(null===n)return e;const r=e.replace("0x","");if(r.length>2*n)throw new f({size:Math.ceil(r.length/2),targetSize:n,type:"hex"});return`0x${r["right"===t?"padEnd":"padStart"](2*n,"0")}`}(e,{dir:t,size:n}):function(e,{dir:t,size:n=32}={}){if(null===n)return e;if(e.length>n)throw new f({size:e.length,targetSize:n,type:"bytes"});const r=new Uint8Array(n);for(let s=0;s<n;s++){const i="right"===t;r[i?s:n-s-1]=e[i?s:e.length-s-1]}return r}(e,{dir:t,size:n})}class g extends l{constructor({max:e,min:t,signed:n,size:r,value:s}){super(`Number "${s}" is not in safe ${r?`${8*r}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class w extends l{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}function b(e,{size:t}){if(o(e)>t)throw new w({givenSize:o(e),maxSize:t})}function y(e,t={}){const{signed:n}=t;t.size&&b(e,{size:t.size});const r=BigInt(e);if(!n)return r;const s=(e.length-2)/2;return r<=(1n<<8n*BigInt(s)-1n)-1n?r:r-BigInt(`0x${"f".padStart(2*s,"f")}`)-1n}function x(e,t={}){return Number(y(e,t))}const v=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function P(e,t={}){return"number"==typeof e||"bigint"==typeof e?I(e,t):"string"==typeof e?function(e,t={}){const n=E.encode(e);return B(n,t)}(e,t):"boolean"==typeof e?function(e,t={}){const n=`0x${Number(e)}`;if("number"==typeof t.size)return b(n,{size:t.size}),m(n,{size:t.size});return n}(e,t):B(e,t)}function B(e,t={}){let n="";for(let t=0;t<e.length;t++)n+=v[e[t]];const r=`0x${n}`;return"number"==typeof t.size?(b(r,{size:t.size}),m(r,{dir:"right",size:t.size})):r}function I(e,t={}){const{signed:n,size:r}=t,s=BigInt(e);let i;r?i=n?(1n<<8n*BigInt(r)-1n)-1n:2n**(8n*BigInt(r))-1n:"number"==typeof e&&(i=BigInt(Number.MAX_SAFE_INTEGER));const o="bigint"==typeof i&&n?-i-1n:0;if(i&&s>i||s<o){const t="bigint"==typeof e?"n":"";throw new g({max:i?`${i}${t}`:void 0,min:`${o}${t}`,signed:n,size:r,value:`${e}${t}`})}const a=`0x${(n&&s<0?(1n<<BigInt(8*r))+BigInt(s):s).toString(16)}`;return r?m(a,{size:r}):a}const E=new TextEncoder;const A=new TextEncoder;function T(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){const n=I(e,t);return F(n)}(e,t):"boolean"==typeof e?function(e,t={}){const n=new Uint8Array(1);if(n[0]=Number(e),"number"==typeof t.size)return b(n,{size:t.size}),m(n,{size:t.size});return n}(e,t):i(e)?F(e,t):S(e,t)}const k={zero:48,nine:57,A:65,F:70,a:97,f:102};function C(e){return e>=k.zero&&e<=k.nine?e-k.zero:e>=k.A&&e<=k.F?e-(k.A-10):e>=k.a&&e<=k.f?e-(k.a-10):void 0}function F(e,t={}){let n=e;t.size&&(b(n,{size:t.size}),n=m(n,{dir:"right",size:t.size}));let r=n.slice(2);r.length%2&&(r=`0${r}`);const s=r.length/2,i=new Uint8Array(s);for(let e=0,t=0;e<s;e++){const n=C(r.charCodeAt(t++)),s=C(r.charCodeAt(t++));if(void 0===n||void 0===s)throw new l(`Invalid byte sequence ("${r[t-2]}${r[t-1]}" in "${r}").`);i[e]=16*n+s}return i}function S(e,t={}){const n=A.encode(e);return"number"==typeof t.size?(b(n,{size:t.size}),m(n,{dir:"right",size:t.size})):n}const O=BigInt(2**32-1),N=BigInt(32);function $(e,t=!1){return t?{h:Number(e&O),l:Number(e>>N&O)}:{h:0|Number(e>>N&O),l:0|Number(e&O)}}const z=r&&"object"==typeof r&&"webcrypto"in r?r.webcrypto:r&&"object"==typeof r&&"randomBytes"in r?r:void 0;function G(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function U(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function R(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function H(e,t){U(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function q(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function L(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function M(e,t){return e<<32-t|e>>>t}function V(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const j=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?e=>e:function(e){for(let t=0;t<e.length;t++)e[t]=V(e[t]);return e};function D(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),U(e),e}class _{}function X(e){const t=t=>e().update(D(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function K(e=32){if(z&&"function"==typeof z.getRandomValues)return z.getRandomValues(new Uint8Array(e));if(z&&"function"==typeof z.randomBytes)return Uint8Array.from(z.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}const Z=BigInt(0),W=BigInt(1),Y=BigInt(2),J=BigInt(7),Q=BigInt(256),ee=BigInt(113),te=[],ne=[],re=[];for(let e=0,t=W,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],te.push(2*(5*r+n)),ne.push((e+1)*(e+2)/2%64);let s=Z;for(let e=0;e<7;e++)t=(t<<W^(t>>J)*ee)%Q,t&Y&&(s^=W<<(W<<BigInt(e))-W);re.push(s)}const se=function(e,t=!1){const n=e.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let i=0;i<n;i++){const{h:n,l:o}=$(e[i],t);[r[i],s[i]]=[n,o]}return[r,s]}(re,!0),ie=se[0],oe=se[1],ae=(e,t,n)=>n>32?((e,t,n)=>t<<n-32|e>>>64-n)(e,t,n):((e,t,n)=>e<<n|t>>>32-n)(e,t,n),ce=(e,t,n)=>n>32?((e,t,n)=>e<<n-32|t>>>64-n)(e,t,n):((e,t,n)=>t<<n|e>>>32-n)(e,t,n);class ue extends _{constructor(e,t,n,r=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=r,this.rounds=s,G(n),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");var i;this.state=new Uint8Array(200),this.state32=(i=this.state,new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)))}clone(){return this._cloneInto()}keccak(){j(this.state32),function(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let t=0;t<10;t++)n[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const r=(t+8)%10,s=(t+2)%10,i=n[s],o=n[s+1],a=ae(i,o,1)^n[r],c=ce(i,o,1)^n[r+1];for(let n=0;n<50;n+=10)e[t+n]^=a,e[t+n+1]^=c}let t=e[2],s=e[3];for(let n=0;n<24;n++){const r=ne[n],i=ae(t,s,r),o=ce(t,s,r),a=te[n];t=e[a],s=e[a+1],e[a]=i,e[a+1]=o}for(let t=0;t<50;t+=10){for(let r=0;r<10;r++)n[r]=e[t+r];for(let r=0;r<10;r++)e[t+r]^=~n[(r+2)%10]&n[(r+4)%10]}e[0]^=ie[r],e[1]^=oe[r]}q(n)}(this.state32,this.rounds),j(this.state32),this.posOut=0,this.pos=0}update(e){R(this),U(e=D(e));const{blockLen:t,state:n}=this,r=e.length;for(let s=0;s<r;){const i=Math.min(t-this.pos,r-s);for(let t=0;t<i;t++)n[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:r}=this;e[n]^=t,128&t&&n===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){R(this,!1),U(e),this.finish();const t=this.state,{blockLen:n}=this;for(let r=0,s=e.length;r<s;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,s-r);e.set(t.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return G(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(H(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,q(this.state)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:r,rounds:s,enableXOF:i}=this;return e||(e=new ue(t,n,r,i,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=n,e.outputLen=r,e.enableXOF=i,e.destroyed=this.destroyed,e}}const le=(()=>{return e=1,t=136,n=32,X(()=>new ue(t,e,n));var e,t,n})();function de(e,t){const n=t||"hex",r=le(i(e,{strict:!1})?T(e):e);return"bytes"===n?r:P(r)}class he extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&void 0!==t&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}}const fe=/^0x[a-fA-F0-9]{40}$/,pe=new he(8192);function me(e,t){const{strict:n=!0}=t??{},r=`${e}.${n}`;if(pe.has(r))return pe.get(r);const s=!(!fe.test(e)||e.toLowerCase()!==e&&n&&we(e)!==e);return pe.set(r,s),s}const ge=new he(8192);function we(e,t){if(ge.has(`${e}.${t}`))return ge.get(`${e}.${t}`);const n=e.substring(2).toLowerCase(),r=de(S(n),"bytes"),s=n.split("");for(let e=0;e<40;e+=2)r[e>>1]>>4>=8&&s[e]&&(s[e]=s[e].toUpperCase()),(15&r[e>>1])>=8&&s[e+1]&&(s[e+1]=s[e+1].toUpperCase());const i=`0x${s.join("")}`;return ge.set(`${e}.${t}`,i),i}class be extends l{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class ye extends l{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,{name:"PositionOutOfBoundsError"})}}class xe extends l{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,{name:"RecursiveReadLimitExceededError"})}}const ve={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new xe({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new ye({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new be({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new be({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function Pe(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(ve);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}class Be extends l{constructor({chain:e,currentChainId:t}){super(`The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e.id} – ${e.name}`],name:"ChainMismatchError"})}}class Ie extends l{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n"),{name:"ChainNotFoundError"})}}function Ee(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}const Ae=(e,t,n)=>JSON.stringify(e,(e,t)=>"bigint"==typeof t?t.toString():t,n),Te={gwei:9,wei:18},ke={ether:-9,wei:9};function Ce(e,t){let n=e.toString();const r=n.startsWith("-");r&&(n=n.slice(1)),n=n.padStart(t,"0");let[s,i]=[n.slice(0,n.length-t),n.slice(n.length-t)];return i=i.replace(/(0+)$/,""),`${r?"-":""}${s||"0"}${i?`.${i}`:""}`}function Fe(e,t="wei"){return Ce(e,Te[t])}function Se(e,t="wei"){return Ce(e,ke[t])}class Oe extends l{constructor({address:e}){super(`State for account "${e}" is set multiple times.`,{name:"AccountStateConflictError"})}}class Ne extends l{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function $e(e){const t=Object.entries(e).map(([e,t])=>void 0===t||!1===t?null:[e,t]).filter(Boolean),n=t.reduce((e,[t])=>Math.max(e,t.length),0);return t.map(([e,t])=>`  ${`${e}:`.padEnd(n+1)}  ${t}`).join("\n")}class ze extends l{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n"),{name:"FeeConflictError"})}}class Ge extends l{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",$e(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}class Ue extends l{constructor(e,{account:t,docsPath:n,chain:r,data:s,gas:i,gasPrice:o,maxFeePerGas:a,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const h=$e({chain:r&&`${r?.name} (id: ${r?.id})`,from:t?.address,to:l,value:void 0!==d&&`${Fe(d)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:s,gas:i,gasPrice:void 0!==o&&`${Se(o)} gwei`,maxFeePerGas:void 0!==a&&`${Se(a)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${Se(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Request Arguments:",h].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class Re extends l{constructor({blockHash:e,blockNumber:t,blockTag:n,hash:r,index:s}){let i="Transaction";n&&void 0!==s&&(i=`Transaction at block time "${n}" at index "${s}"`),e&&void 0!==s&&(i=`Transaction at block hash "${e}" at index "${s}"`),t&&void 0!==s&&(i=`Transaction at block number "${t}" at index "${s}"`),r&&(i=`Transaction with hash "${r}"`),super(`${i} could not be found.`,{name:"TransactionNotFoundError"})}}class He extends l{constructor({hash:e}){super(`Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class qe extends l{constructor({hash:e}){super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}function Le(e,t,n){const r=e[t.name];if("function"==typeof r)return r;const s=e[n];return"function"==typeof s?s:n=>t(e,n)}class Me extends l{constructor({cause:e,message:t}={}){const n=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`,{cause:e,name:"ExecutionRevertedError"})}}Object.defineProperty(Me,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(Me,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class Ve extends l{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${Se(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e,name:"FeeCapTooHighError"})}}Object.defineProperty(Ve,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class je extends l{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${Se(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e,name:"FeeCapTooLowError"})}}Object.defineProperty(je,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class De extends l{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e,name:"NonceTooHighError"})}}Object.defineProperty(De,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class _e extends l{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e,name:"NonceTooLowError"})}}Object.defineProperty(_e,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class Xe extends l{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e,name:"NonceMaxValueError"})}}Object.defineProperty(Xe,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class Ke extends l{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(Ke,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class Ze extends l{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(Ze,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class We extends l{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(We,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class Ye extends l{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(Ye,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class Je extends l{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:n}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${Se(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${Se(n)} gwei`:""}).`].join("\n"),{cause:e,name:"TipAboveFeeCapError"})}}Object.defineProperty(Je,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class Qe extends l{constructor({cause:e}){super(`An error occurred while executing: ${e?.shortMessage}`,{cause:e,name:"UnknownNodeError"})}}function et(e,t){const n=(e.details||"").toLowerCase(),r=e instanceof l?e.walk(e=>e?.code===Me.code):e;return r instanceof l?new Me({cause:e,message:r.details}):Me.nodeMessage.test(n)?new Me({cause:e,message:e.details}):Ve.nodeMessage.test(n)?new Ve({cause:e,maxFeePerGas:t?.maxFeePerGas}):je.nodeMessage.test(n)?new je({cause:e,maxFeePerGas:t?.maxFeePerGas}):De.nodeMessage.test(n)?new De({cause:e,nonce:t?.nonce}):_e.nodeMessage.test(n)?new _e({cause:e,nonce:t?.nonce}):Xe.nodeMessage.test(n)?new Xe({cause:e,nonce:t?.nonce}):Ke.nodeMessage.test(n)?new Ke({cause:e}):Ze.nodeMessage.test(n)?new Ze({cause:e,gas:t?.gas}):We.nodeMessage.test(n)?new We({cause:e,gas:t?.gas}):Ye.nodeMessage.test(n)?new Ye({cause:e}):Je.nodeMessage.test(n)?new Je({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new Qe({cause:e})}function tt(e,{format:t}){if(!t)return{};const n={};return function t(r){const s=Object.keys(r);for(const i of s)i in e&&(n[i]=e[i]),r[i]&&"object"==typeof r[i]&&!Array.isArray(r[i])&&t(r[i])}(t(e||{})),n}const nt={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function rt(e,t){const n={};return void 0!==e.authorizationList&&(n.authorizationList=e.authorizationList.map(e=>({address:e.address,r:e.r?I(BigInt(e.r)):e.r,s:e.s?I(BigInt(e.s)):e.s,chainId:I(e.chainId),nonce:I(e.nonce),...void 0!==e.yParity?{yParity:I(e.yParity)}:{},...void 0!==e.v&&void 0===e.yParity?{v:I(e.v)}:{}}))),void 0!==e.accessList&&(n.accessList=e.accessList),void 0!==e.blobVersionedHashes&&(n.blobVersionedHashes=e.blobVersionedHashes),void 0!==e.blobs&&("string"!=typeof e.blobs[0]?n.blobs=e.blobs.map(e=>B(e)):n.blobs=e.blobs),void 0!==e.data&&(n.data=e.data),e.account&&(n.from=e.account.address),void 0!==e.from&&(n.from=e.from),void 0!==e.gas&&(n.gas=I(e.gas)),void 0!==e.gasPrice&&(n.gasPrice=I(e.gasPrice)),void 0!==e.maxFeePerBlobGas&&(n.maxFeePerBlobGas=I(e.maxFeePerBlobGas)),void 0!==e.maxFeePerGas&&(n.maxFeePerGas=I(e.maxFeePerGas)),void 0!==e.maxPriorityFeePerGas&&(n.maxPriorityFeePerGas=I(e.maxPriorityFeePerGas)),void 0!==e.nonce&&(n.nonce=I(e.nonce)),void 0!==e.to&&(n.to=e.to),void 0!==e.type&&(n.type=nt[e.type]),void 0!==e.value&&(n.value=I(e.value)),n}function st(e){if(e&&0!==e.length)return e.reduce((e,{slot:t,value:n})=>{if(66!==t.length)throw new p({size:t.length,targetSize:66,type:"hex"});if(66!==n.length)throw new p({size:n.length,targetSize:66,type:"hex"});return e[t]=n,e},{})}function it(e){const{balance:t,nonce:n,state:r,stateDiff:s,code:i}=e,o={};if(void 0!==i&&(o.code=i),void 0!==t&&(o.balance=I(t)),void 0!==n&&(o.nonce=I(n)),void 0!==r&&(o.state=st(r)),void 0!==s){if(o.state)throw new Ne;o.stateDiff=st(s)}return o}const ot=2n**256n-1n;function at(e){const{account:t,gasPrice:n,maxFeePerGas:r,maxPriorityFeePerGas:s,to:i}=e,o=t?Ee(t):void 0;if(o&&!me(o.address))throw new h({address:o.address});if(i&&!me(i))throw new h({address:i});if(void 0!==n&&(void 0!==r||void 0!==s))throw new ze;if(r&&r>ot)throw new Ve({maxFeePerGas:r});if(s&&r&&s>r)throw new Je({maxFeePerGas:r,maxPriorityFeePerGas:s})}function ct(e){if(0===e||1===e)return e;if(27===e)return 0;if(28===e)return 1;throw new Error("Invalid yParityOrV value")}async function ut({hash:e,signature:t}){return n=await async function({hash:e,signature:t}){const n=i(e)?e:P(e),{secp256k1:r}=await Promise.resolve().then(function(){return qr});return`0x${(()=>{if("object"==typeof t&&"r"in t&&"s"in t){const{r:e,s:n,v:s,yParity:i}=t,o=ct(Number(i??s));return new r.Signature(y(e),y(n)).addRecoveryBit(o)}const e=i(t)?t:P(t);if(65!==o(e))throw new Error("invalid signature length");const n=ct(x(`0x${e.slice(130)}`));return r.Signature.fromCompact(e.substring(2,130)).addRecoveryBit(n)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}({hash:e,signature:t}),we(`0x${de(`0x${n.substring(4)}`).substring(26)}`);var n}function lt(e,t="hex"){const n=dt(e),r=Pe(new Uint8Array(n.length));return n.encode(r),"hex"===t?B(r.bytes):r.bytes}function dt(e){return Array.isArray(e)?function(e){const t=e.reduce((e,t)=>e+t.length,0),n=ht(t);return{length:t<=55?1+t:1+n+t,encode(r){t<=55?r.pushByte(192+t):(r.pushByte(247+n),1===n?r.pushUint8(t):2===n?r.pushUint16(t):3===n?r.pushUint24(t):r.pushUint32(t));for(const{encode:t}of e)t(r)}}}(e.map(e=>dt(e))):function(e){const t="string"==typeof e?F(e):e,n=ht(t.length),r=1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length;return{length:r,encode(e){1===t.length&&t[0]<128?e.pushBytes(t):t.length<=55?(e.pushByte(128+t.length),e.pushBytes(t)):(e.pushByte(183+n),1===n?e.pushUint8(t.length):2===n?e.pushUint16(t.length):3===n?e.pushUint24(t.length):e.pushUint32(t.length),e.pushBytes(t))}}}(e)}function ht(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new l("Length is too large.")}function ft(e){const{chainId:t,nonce:n,to:r}=e,s=e.contractAddress??e.address,i=de(`0x${["0x05",lt([t?I(t):"0x",s,n?I(n):"0x"])].reduce((e,t)=>e+t.replace("0x",""),"")}`);return"bytes"===r?F(i):i}async function pt(e){const{authorization:t,signature:n}=e;return ut({hash:ft(t),signature:n??t})}class mt extends l{constructor(e,{account:t,docsPath:n,chain:r,data:s,gas:i,gasPrice:o,maxFeePerGas:a,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const h=$e({from:t?.address,to:l,value:void 0!==d&&`${Fe(d)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:s,gas:i,gasPrice:void 0!==o&&`${Se(o)} gwei`,maxFeePerGas:void 0!==a&&`${Se(a)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${Se(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Estimate Gas Arguments:",h].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class gt extends l{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class wt extends l{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class bt extends l{constructor({maxPriorityFeePerGas:e}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Se(e)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class yt extends l{constructor({blockHash:e,blockNumber:t}){let n="Block";e&&(n=`Block at hash "${e}"`),t&&(n=`Block at number "${t}"`),super(`${n} could not be found.`,{name:"BlockNotFoundError"})}}const xt={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function vt(e,t){const n={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?x(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?x(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?xt[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};return e.authorizationList&&(n.authorizationList=e.authorizationList.map(e=>({address:e.address,chainId:Number(e.chainId),nonce:Number(e.nonce),r:e.r,s:e.s,yParity:Number(e.yParity)}))),n.yParity=(()=>{if(e.yParity)return Number(e.yParity);if("bigint"==typeof n.v){if(0n===n.v||27n===n.v)return 0;if(1n===n.v||28n===n.v)return 1;if(n.v>=35n)return n.v%2n==0n?1:0}})(),"legacy"===n.type&&(delete n.accessList,delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas,delete n.yParity),"eip2930"===n.type&&(delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas),"eip1559"===n.type&&delete n.maxFeePerBlobGas,n}function Pt(e,t){const n=(e.transactions??[]).map(e=>"string"==typeof e?e:vt(e));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:n,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function Bt(e,{blockHash:t,blockNumber:n,blockTag:r=e.experimental_blockTag??"latest",includeTransactions:s}={}){const i=s??!1,o=void 0!==n?I(n):void 0;let a=null;if(a=t?await e.request({method:"eth_getBlockByHash",params:[t,i]},{dedupe:!0}):await e.request({method:"eth_getBlockByNumber",params:[o||r,i]},{dedupe:Boolean(o)}),!a)throw new yt({blockHash:t,blockNumber:n});return(e.chain?.formatters?.block?.format||Pt)(a,"getBlock")}async function It(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Et(e,t){const{block:n,chain:r=e.chain,request:s,type:i="eip1559"}=t||{},o=await(async()=>"function"==typeof r?.fees?.baseFeeMultiplier?r.fees.baseFeeMultiplier({block:n,client:e,request:s}):r?.fees?.baseFeeMultiplier??1.2)();if(o<1)throw new gt;const a=10**(o.toString().split(".")[1]?.length??0),c=e=>e*BigInt(Math.ceil(o*a))/BigInt(a),u=n||await Le(e,Bt,"getBlock")({});if("function"==typeof r?.fees?.estimateFeesPerGas){const t=await r.fees.estimateFeesPerGas({block:n,client:e,multiply:c,request:s,type:i});if(null!==t)return t}if("eip1559"===i){if("bigint"!=typeof u.baseFeePerGas)throw new wt;const t="bigint"==typeof s?.maxPriorityFeePerGas?s.maxPriorityFeePerGas:await async function(e,t){const{block:n,chain:r=e.chain,request:s}=t||{};try{const t=r?.fees?.maxPriorityFeePerGas??r?.fees?.defaultPriorityFee;if("function"==typeof t){const r=n||await Le(e,Bt,"getBlock")({}),i=await t({block:r,client:e,request:s});if(null===i)throw new Error;return i}return void 0!==t?t:y(await e.request({method:"eth_maxPriorityFeePerGas"}))}catch{const[t,r]=await Promise.all([n?Promise.resolve(n):Le(e,Bt,"getBlock")({}),Le(e,It,"getGasPrice")({})]);if("bigint"!=typeof t.baseFeePerGas)throw new wt;const s=r-t.baseFeePerGas;return s<0n?0n:s}}(e,{block:u,chain:r,request:s}),n=c(u.baseFeePerGas);return{maxFeePerGas:s?.maxFeePerGas??n+t,maxPriorityFeePerGas:t}}return{gasPrice:s?.gasPrice??c(await Le(e,It,"getGasPrice")({}))}}async function At(e,{address:t,blockTag:n="latest",blockNumber:r}){return x(await e.request({method:"eth_getTransactionCount",params:[t,"bigint"==typeof r?I(r):n]},{dedupe:Boolean(r)}))}function Tt(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),r="string"==typeof e.blobs[0]?e.blobs.map(e=>F(e)):e.blobs,s=[];for(const e of r)s.push(Uint8Array.from(t.blobToKzgCommitment(e)));return"bytes"===n?s:s.map(e=>B(e))}function kt(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),r="string"==typeof e.blobs[0]?e.blobs.map(e=>F(e)):e.blobs,s="string"==typeof e.commitments[0]?e.commitments.map(e=>F(e)):e.commitments,i=[];for(let e=0;e<r.length;e++){const n=r[e],o=s[e];i.push(Uint8Array.from(t.computeBlobKzgProof(n,o)))}return"bytes"===n?i:i.map(e=>B(e))}function Ct(e,t,n){return e&t^~e&n}function Ft(e,t,n){return e&t^e&n^t&n}class St extends _{constructor(e,t,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=L(this.buffer)}update(e){R(this),U(e=D(e));const{view:t,buffer:n,blockLen:r}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){const t=L(e);for(;r<=s-i;i+=r)this.process(t,i);continue}n.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){R(this),H(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:s}=this;let{pos:i}=this;t[i++]=128,q(this.buffer.subarray(i)),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(n>>s&i),a=Number(n&i),c=r?4:0,u=r?0:4;e.setUint32(t+c,o,r),e.setUint32(t+u,a,r)}(n,r-8,BigInt(8*this.length),s),this.process(n,0);const o=L(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)o.setUint32(4*e,u[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:s,destroyed:i,pos:o}=this;return e.destroyed=i,e.finished=s,e.length=r,e.pos=o,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Ot=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Nt=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),$t=new Uint32Array(64);class zt extends St{constructor(e=32){super(64,e,8,!1),this.A=0|Ot[0],this.B=0|Ot[1],this.C=0|Ot[2],this.D=0|Ot[3],this.E=0|Ot[4],this.F=0|Ot[5],this.G=0|Ot[6],this.H=0|Ot[7]}get(){const{A:e,B:t,C:n,D:r,E:s,F:i,G:o,H:a}=this;return[e,t,n,r,s,i,o,a]}set(e,t,n,r,s,i,o,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)$t[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=$t[e-15],n=$t[e-2],r=M(t,7)^M(t,18)^t>>>3,s=M(n,17)^M(n,19)^n>>>10;$t[e]=s+$t[e-7]+r+$t[e-16]|0}let{A:n,B:r,C:s,D:i,E:o,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(M(o,6)^M(o,11)^M(o,25))+Ct(o,a,c)+Nt[e]+$t[e]|0,l=(M(n,2)^M(n,13)^M(n,22))+Ft(n,r,s)|0;u=c,c=a,a=o,o=i+t|0,i=s,s=r,r=n,n=t+l|0}n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(n,r,s,i,o,a,c,u)}roundClean(){q($t)}destroy(){this.set(0,0,0,0,0,0,0,0),q(this.buffer)}}const Gt=X(()=>new zt),Ut=Gt;function Rt(e){const{commitment:t,version:n=1}=e,r=e.to??("string"==typeof t?"hex":"bytes"),s=Ut(i(o=t,{strict:!1})?T(o):o);var o;return s.set([n],0),"bytes"===r?s:B(s)}const Ht=4096,qt=131072,Lt=761855;class Mt extends l{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`],name:"BlobSizeTooLargeError"})}}class Vt extends l{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}function jt(e){const{data:t,kzg:n,to:r}=e,s=e.blobs??function(e){const t="string"==typeof e.data?F(e.data):e.data,n=o(t);if(!n)throw new Vt;if(n>Lt)throw new Mt({maxSize:Lt,size:n});const r=[];let s=!0,i=0;for(;s;){const e=Pe(new Uint8Array(qt));let n=0;for(;n<Ht;){const r=t.slice(i,i+31);if(e.pushByte(0),e.pushBytes(r),r.length<31){e.pushByte(128),s=!1;break}n++,i+=31}r.push(e)}return r.map(e=>B(e.bytes))}({data:t}),i=e.commitments??Tt({blobs:s,kzg:n,to:r}),a=e.proofs??kt({blobs:s,commitments:i,kzg:n,to:r}),c=[];for(let e=0;e<s.length;e++)c.push({blob:s[e],commitment:i[e],proof:a[e]});return c}async function Dt(e){return x(await e.request({method:"eth_chainId"},{dedupe:!0}))}const _t=["blobVersionedHashes","chainId","fees","gas","nonce","type"],Xt=new Map;async function Kt(e,t){const{account:n=e.account,blobs:r,chain:s,gas:i,kzg:o,nonce:a,nonceManager:c,parameters:u=_t,type:l}=t,d=n?Ee(n):n,h={...t,...d?{from:d?.address}:{}};let f,p;async function m(){return f||(f=await Le(e,Bt,"getBlock")({blockTag:"latest"}),f)}async function g(){if(p)return p;if(s)return s.id;if(void 0!==t.chainId)return t.chainId;const n=await Le(e,Dt,"getChainId")({});return p=n,p}if(u.includes("nonce")&&void 0===a&&d)if(c){const t=await g();h.nonce=await c.consume({address:d.address,chainId:t,client:e})}else h.nonce=await Le(e,At,"getTransactionCount")({address:d.address,blockTag:"pending"});if((u.includes("blobVersionedHashes")||u.includes("sidecars"))&&r&&o){const e=Tt({blobs:r,kzg:o});if(u.includes("blobVersionedHashes")){const t=function(e){const{commitments:t,version:n}=e,r=e.to,s=[];for(const e of t)s.push(Rt({commitment:e,to:r,version:n}));return s}({commitments:e,to:"hex"});h.blobVersionedHashes=t}if(u.includes("sidecars")){const t=jt({blobs:r,commitments:e,proofs:kt({blobs:r,commitments:e,kzg:o}),to:"hex"});h.sidecars=t}}if(u.includes("chainId")&&(h.chainId=await g()),(u.includes("fees")||u.includes("type"))&&void 0===l)try{h.type=function(e){if(e.type)return e.type;if(void 0!==e.authorizationList)return"eip7702";if(void 0!==e.blobs||void 0!==e.blobVersionedHashes||void 0!==e.maxFeePerBlobGas||void 0!==e.sidecars)return"eip4844";if(void 0!==e.maxFeePerGas||void 0!==e.maxPriorityFeePerGas)return"eip1559";if(void 0!==e.gasPrice)return void 0!==e.accessList?"eip2930":"legacy";throw new Ge({transaction:e})}(h)}catch{let t=Xt.get(e.uid);if(void 0===t){const n=await m();t="bigint"==typeof n?.baseFeePerGas,Xt.set(e.uid,t)}h.type=t?"eip1559":"legacy"}if(u.includes("fees"))if("legacy"!==h.type&&"eip2930"!==h.type){if(void 0===h.maxFeePerGas||void 0===h.maxPriorityFeePerGas){const n=await m(),{maxFeePerGas:r,maxPriorityFeePerGas:i}=await Et(e,{block:n,chain:s,request:h});if(void 0===t.maxPriorityFeePerGas&&t.maxFeePerGas&&t.maxFeePerGas<i)throw new bt({maxPriorityFeePerGas:i});h.maxPriorityFeePerGas=i,h.maxFeePerGas=r}}else{if(void 0!==t.maxFeePerGas||void 0!==t.maxPriorityFeePerGas)throw new wt;if(void 0===t.gasPrice){const t=await m(),{gasPrice:n}=await Et(e,{block:t,chain:s,request:h,type:"legacy"});h.gasPrice=n}}return u.includes("gas")&&void 0===i&&(h.gas=await Le(e,Zt,"estimateGas")({...h,account:d,prepare:"local"===d?.type?[]:["blobVersionedHashes"]})),at(h),delete h.parameters,h}async function Zt(e,t){const{account:n=e.account,prepare:r=!0}=t,s=n?Ee(n):void 0,i=Array.isArray(r)?r:"local"!==s?.type?["blobVersionedHashes"]:void 0;try{const{accessList:n,authorizationList:o,blobs:a,blobVersionedHashes:c,blockNumber:u,blockTag:d,data:f,gas:p,gasPrice:m,maxFeePerBlobGas:g,maxFeePerGas:w,maxPriorityFeePerGas:b,nonce:y,value:x,stateOverride:v,...P}=r?await Kt(e,{...t,parameters:i}):t,B=("bigint"==typeof u?I(u):void 0)||d,E=function(e){if(!e)return;const t={};for(const{address:n,...r}of e){if(!me(n,{strict:!1}))throw new h({address:n});if(t[n])throw new Oe({address:n});t[n]=it(r)}return t}(v),A=await(async()=>P.to?P.to:o&&o.length>0?await pt({authorization:o[0]}).catch(()=>{throw new l("`to` is required. Could not infer from `authorizationList`")}):void 0)();at(t);const T=e.chain?.formatters?.transactionRequest?.format,k=(T||rt)({...tt(P,{format:T}),account:s,accessList:n,authorizationList:o,blobs:a,blobVersionedHashes:c,data:f,gas:p,gasPrice:m,maxFeePerBlobGas:g,maxFeePerGas:w,maxPriorityFeePerGas:b,nonce:y,to:A,value:x},"estimateGas");return BigInt(await e.request({method:"eth_estimateGas",params:E?[k,B??e.experimental_blockTag??"latest",E]:B?[k,B]:[k]}))}catch(n){throw function(e,{docsPath:t,...n}){const r=(()=>{const t=et(e,n);return t instanceof Qe?e:t})();return new mt(r,{docsPath:t,...n})}(n,{...t,account:s,chain:e.chain})}}async function Wt(e,{address:t,blockNumber:n,blockTag:r=e.experimental_blockTag??"latest"}){const s="bigint"==typeof n?I(n):void 0,i=await e.request({method:"eth_getBalance",params:[t,s||r]});return BigInt(i)}const Yt=new Map,Jt=new Map;async function Qt(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const r=function(e){const t=(e,t)=>({clear:()=>t.delete(e),get:()=>t.get(e),set:n=>t.set(e,n)}),n=t(e,Yt),r=t(e,Jt);return{clear:()=>{n.clear(),r.clear()},promise:n,response:r}}(t),s=r.response.get();if(s&&n>0){if(Date.now()-s.created.getTime()<n)return s.data}let i=r.promise.get();i||(i=e(),r.promise.set(i));try{const e=await i;return r.response.set({created:new Date,data:e}),e}finally{r.promise.clear()}}async function en(e,{cacheTime:t=e.cacheTime}={}){const n=await Qt(()=>e.request({method:"eth_blockNumber"}),{cacheKey:(r=e.uid,`blockNumber.${r}`),cacheTime:t});var r;return BigInt(n)}async function tn(e){return new Promise(t=>setTimeout(t,e))}function nn(e,{delay:t=100,retryCount:n=2,shouldRetry:r=()=>!0}={}){return new Promise((s,i)=>{const o=async({count:a=0}={})=>{try{const t=await e();s(t)}catch(e){if(a<n&&await r({count:a,error:e}))return(async({error:e})=>{const n="function"==typeof t?t({count:a,error:e}):t;n&&await tn(n),o({count:a+1})})({error:e});i(e)}};o()})}function rn({chain:e,currentChainId:t}){if(!e)throw new Ie;if(t!==e.id)throw new Be({chain:e,currentChainId:t})}const sn={"0x0":"reverted","0x1":"success"};function on(e,t){const n={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(e=>function(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}(e)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?x(e.transactionIndex):null,status:e.status?sn[e.status]:null,type:e.type?xt[e.type]||e.type:null};return e.blobGasPrice&&(n.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(n.blobGasUsed=BigInt(e.blobGasUsed)),n}async function an(e,{blockHash:t,blockNumber:n,blockTag:r,hash:s,index:i}){const o=r||"latest",a=void 0!==n?I(n):void 0;let c=null;if(c=s?await e.request({method:"eth_getTransactionByHash",params:[s]},{dedupe:!0}):t?await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,I(i)]},{dedupe:!0}):await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[a||o,I(i)]},{dedupe:Boolean(a)}),!c)throw new Re({blockHash:t,blockNumber:n,blockTag:o,hash:s,index:i});return(e.chain?.formatters?.transaction?.format||vt)(c,"getTransaction")}async function cn(e,{hash:t}){const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new He({hash:t});return(e.chain?.formatters?.transactionReceipt?.format||on)(n,"getTransactionReceipt")}class un extends _{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.createHasher");G(e.outputLen),G(e.blockLen)}(e);const n=D(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?e.create().update(n).digest():n);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),q(s)}update(e){return R(this),this.iHash.update(e),this}digestInto(e){R(this),U(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:r,destroyed:s,blockLen:i,outputLen:o}=this;return e.finished=r,e.destroyed=s,e.blockLen=i,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ln=(e,t,n)=>new un(e,t).update(n).digest();ln.create=(e,t)=>new un(e,t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const dn=BigInt(0),hn=BigInt(1);function fn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function pn(e){if(!fn(e))throw new Error("Uint8Array expected")}function mn(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}function gn(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function wn(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?dn:BigInt("0x"+e)}const bn="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,yn=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function xn(e){if(pn(e),bn)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=yn[e[n]];return t}const vn=48,Pn=57,Bn=65,In=70,En=97,An=102;function Tn(e){return e>=vn&&e<=Pn?e-vn:e>=Bn&&e<=In?e-(Bn-10):e>=En&&e<=An?e-(En-10):void 0}function kn(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(bn)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,s=0;t<n;t++,s+=2){const n=Tn(e.charCodeAt(s)),i=Tn(e.charCodeAt(s+1));if(void 0===n||void 0===i){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}r[t]=16*n+i}return r}function Cn(e){return wn(xn(e))}function Fn(e){return pn(e),wn(xn(Uint8Array.from(e).reverse()))}function Sn(e,t){return kn(e.toString(16).padStart(2*t,"0"))}function On(e,t){return Sn(e,t).reverse()}function Nn(e,t,n){let r;if("string"==typeof t)try{r=kn(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!fn(t))throw new Error(e+" must be hex string or Uint8Array");r=Uint8Array.from(t)}const s=r.length;if("number"==typeof n&&s!==n)throw new Error(e+" of length "+n+" expected, got "+s);return r}function $n(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];pn(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}const zn=e=>"bigint"==typeof e&&dn<=e;function Gn(e,t,n){return zn(e)&&zn(t)&&zn(n)&&t<=e&&e<n}function Un(e,t,n,r){if(!Gn(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}const Rn=e=>(hn<<BigInt(e))-hn,Hn=e=>new Uint8Array(e),qn=e=>Uint8Array.from(e);const Ln={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||fn(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function Mn(e,t,n={}){const r=(t,n,r)=>{const s=Ln[n];if("function"!=typeof s)throw new Error("invalid validator function");const i=e[t];if(!(r&&void 0===i||s(i,e)))throw new Error("param "+String(t)+" is invalid. Expected "+n+", got "+i)};for(const[e,n]of Object.entries(t))r(e,n,!1);for(const[e,t]of Object.entries(n))r(e,t,!0);return e}function Vn(e){const t=new WeakMap;return(n,...r)=>{const s=t.get(n);if(void 0!==s)return s;const i=e(n,...r);return t.set(n,i),i}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jn=BigInt(0),Dn=BigInt(1),_n=BigInt(2),Xn=BigInt(3),Kn=BigInt(4),Zn=BigInt(5),Wn=BigInt(8);function Yn(e,t){const n=e%t;return n>=jn?n:t+n}function Jn(e,t,n){let r=e;for(;t-- >jn;)r*=r,r%=n;return r}function Qn(e,t){if(e===jn)throw new Error("invert: expected non-zero number");if(t<=jn)throw new Error("invert: expected positive modulus, got "+t);let n=Yn(e,t),r=t,s=jn,i=Dn;for(;n!==jn;){const e=r%n,t=s-i*(r/n);r=n,n=e,s=i,i=t}if(r!==Dn)throw new Error("invert: does not exist");return Yn(s,t)}function er(e,t){const n=(e.ORDER+Dn)/Kn,r=e.pow(t,n);if(!e.eql(e.sqr(r),t))throw new Error("Cannot find square root");return r}function tr(e,t){const n=(e.ORDER-Zn)/Wn,r=e.mul(t,_n),s=e.pow(r,n),i=e.mul(t,s),o=e.mul(e.mul(i,_n),s),a=e.mul(i,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),t))throw new Error("Cannot find square root");return a}function nr(e){return e%Kn===Xn?er:e%Wn===Zn?tr:function(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let t=e-Dn,n=0;for(;t%_n===jn;)t/=_n,n++;let r=_n;const s=ar(e);for(;1===ir(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return er;let i=s.pow(r,t);const o=(t+Dn)/_n;return function(e,r){if(e.is0(r))return r;if(1!==ir(e,r))throw new Error("Cannot find square root");let s=n,a=e.mul(e.ONE,i),c=e.pow(r,t),u=e.pow(r,o);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,n=e.sqr(c);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===s)throw new Error("Cannot find square root");const r=Dn<<BigInt(s-t-1),i=e.pow(a,r);s=t,a=e.sqr(i),c=e.mul(c,a),u=e.mul(u,i)}return u}}(e)}const rr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function sr(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),s=t.reduce((t,n,s)=>e.is0(n)?t:(r[s]=t,e.mul(t,n)),e.ONE),i=e.inv(s);return t.reduceRight((t,n,s)=>e.is0(n)?t:(r[s]=e.mul(t,r[s]),e.mul(t,n)),i),r}function ir(e,t){const n=(e.ORDER-Dn)/_n,r=e.pow(t,n),s=e.eql(r,e.ONE),i=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function or(e,t){void 0!==t&&G(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function ar(e,t,n=!1,r={}){if(e<=jn)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:s,nByteLength:i}=or(e,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:e,isLE:n,BITS:s,BYTES:i,MASK:Rn(s),ZERO:jn,ONE:Dn,create:t=>Yn(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return jn<=t&&t<e},is0:e=>e===jn,isOdd:e=>(e&Dn)===Dn,neg:t=>Yn(-t,e),eql:(e,t)=>e===t,sqr:t=>Yn(t*t,e),add:(t,n)=>Yn(t+n,e),sub:(t,n)=>Yn(t-n,e),mul:(t,n)=>Yn(t*n,e),pow:(e,t)=>function(e,t,n){if(n<jn)throw new Error("invalid exponent, negatives unsupported");if(n===jn)return e.ONE;if(n===Dn)return t;let r=e.ONE,s=t;for(;n>jn;)n&Dn&&(r=e.mul(r,s)),s=e.sqr(s),n>>=Dn;return r}(a,e,t),div:(t,n)=>Yn(t*Qn(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Qn(t,e),sqrt:r.sqrt||(t=>(o||(o=nr(e)),o(a,t))),toBytes:e=>n?On(e,i):Sn(e,i),fromBytes:e=>{if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);return n?Fn(e):Cn(e)},invertBatch:e=>sr(a,e),cmov:(e,t,n)=>n?t:e});return Object.freeze(a)}function cr(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function ur(e){const t=cr(e);return t+Math.ceil(t/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lr=BigInt(0),dr=BigInt(1);function hr(e,t){const n=t.negate();return e?n:t}function fr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function pr(e,t){fr(e,t);const n=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:Rn(e),maxNumber:n,shiftBy:BigInt(e)}}function mr(e,t,n){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=n;let a=Number(e&s),c=e>>o;a>r&&(a-=i,c+=dr);const u=t*r;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:u}}const gr=new WeakMap,wr=new WeakMap;function br(e){return wr.get(e)||1}function yr(e,t,n,r){!function(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}(n,e),function(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}(r,t);const s=n.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,a=function(e){let t;for(t=0;e>dn;e>>=hn,t+=1);return t}(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=Rn(c),l=new Array(Number(u)+1).fill(o);let d=o;for(let e=Math.floor((t.BITS-1)/c)*c;e>=0;e-=c){l.fill(o);for(let t=0;t<i;t++){const s=r[t],i=Number(s>>BigInt(e)&u);l[i]=l[i].add(n[t])}let t=o;for(let e=l.length-1,n=o;e>0;e--)n=n.add(l[e]),t=t.add(n);if(d=d.add(t),0!==e)for(let e=0;e<c;e++)d=d.double()}return d}function xr(e){return Mn(e.Fp,rr.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Mn(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...or(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function vr(e){void 0!==e.lowS&&mn("lowS",e.lowS),void 0!==e.prehash&&mn("prehash",e.prehash)}class Pr extends Error{constructor(e=""){super(e)}}const Br={Err:Pr,_tlv:{encode:(e,t)=>{const{Err:n}=Br;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const r=t.length/2,s=gn(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?gn(s.length/2|128):"";return gn(e)+i+s+t},decode(e,t){const{Err:n}=Br;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const s=t[r++];let i=0;if(!!(128&s)){const e=127&s;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const o=t.subarray(r,r+e);if(o.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===o[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of o)i=i<<8|e;if(r+=e,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=s;const o=t.subarray(r,r+i);if(o.length!==i)throw new n("tlv.decode: wrong value length");return{v:o,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=Br;if(e<Er)throw new t("integer: negative integers are not allowed");let n=gn(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Br;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return Cn(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Br,s=Nn("signature",e),{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l:l}=r.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(u)}},hexFromSig(e){const{_tlv:t,_int:n}=Br,r=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,r)}};function Ir(e,t){return xn(Sn(e,t))}const Er=BigInt(0),Ar=BigInt(1);BigInt(2);const Tr=BigInt(3),kr=BigInt(4);function Cr(e){const t=function(e){const t=xr(e);Mn(t,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:n,Fp:r,a:s}=t;if(n){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...t})}(e),{Fp:n}=t,r=ar(t.n,t.nBitLength),s=t.toBytes||((e,t,r)=>{const s=t.toAffine();return $n(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function o(e){const{a:r,b:s}=t,i=n.sqr(e),o=n.mul(i,e);return n.add(n.add(o,n.mul(e,r)),s)}function a(e,t){const r=n.sqr(t),s=o(e);return n.eql(r,s)}if(!a(t.Gx,t.Gy))throw new Error("bad curve params: generator point");const c=n.mul(n.pow(t.a,Tr),kr),u=n.mul(n.sqr(t.b),BigInt(27));if(n.is0(n.add(c,u)))throw new Error("bad curve params: a or b");function l(e){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:s,n:i}=t;if(n&&"bigint"!=typeof e){if(fn(e)&&(e=xn(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("invalid private key");e=e.padStart(2*r,"0")}let o;try{o="bigint"==typeof e?e:Cn(Nn("private key",e,r))}catch(t){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof e)}return s&&(o=Yn(o,i)),Un("private key",o,Ar,i),o}function d(e){if(!(e instanceof p))throw new Error("ProjectivePoint expected")}const h=Vn((e,t)=>{const{px:r,py:s,pz:i}=e;if(n.eql(i,n.ONE))return{x:r,y:s};const o=e.is0();null==t&&(t=o?n.ONE:n.inv(i));const a=n.mul(r,t),c=n.mul(s,t),u=n.mul(i,t);if(o)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),f=Vn(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:r,y:s}=e.toAffine();if(!n.isValid(r)||!n.isValid(s))throw new Error("bad point: x or y not FE");if(!a(r,s))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(e,t,r){if(null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t)||n.is0(t))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");this.px=e,this.py=t,this.pz=r,Object.freeze(this)}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof p)throw new Error("projective point not allowed");const s=e=>n.eql(e,n.ZERO);return s(t)&&s(r)?p.ZERO:new p(t,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=sr(n,e.map(e=>e.pz));return e.map((e,n)=>e.toAffine(t[n])).map(p.fromAffine)}static fromHex(e){const t=p.fromAffine(i(Nn("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return p.BASE.multiply(l(e))}static msm(e,t){return yr(p,r,e,t)}_setWindowSize(e){w.setWindowSize(this,e)}assertValidity(){f(this)}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){d(e);const{px:t,py:r,pz:s}=this,{px:i,py:o,pz:a}=e,c=n.eql(n.mul(t,a),n.mul(i,s)),u=n.eql(n.mul(r,a),n.mul(o,s));return c&&u}negate(){return new p(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:r}=t,s=n.mul(r,Tr),{px:i,py:o,pz:a}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO,d=n.mul(i,i),h=n.mul(o,o),f=n.mul(a,a),m=n.mul(i,o);return m=n.add(m,m),l=n.mul(i,a),l=n.add(l,l),c=n.mul(e,l),u=n.mul(s,f),u=n.add(c,u),c=n.sub(h,u),u=n.add(h,u),u=n.mul(c,u),c=n.mul(m,c),l=n.mul(s,l),f=n.mul(e,f),m=n.sub(d,f),m=n.mul(e,m),m=n.add(m,l),l=n.add(d,d),d=n.add(l,d),d=n.add(d,f),d=n.mul(d,m),u=n.add(u,d),f=n.mul(o,a),f=n.add(f,f),d=n.mul(f,m),c=n.sub(c,d),l=n.mul(f,h),l=n.add(l,l),l=n.add(l,l),new p(c,u,l)}add(e){d(e);const{px:r,py:s,pz:i}=this,{px:o,py:a,pz:c}=e;let u=n.ZERO,l=n.ZERO,h=n.ZERO;const f=t.a,m=n.mul(t.b,Tr);let g=n.mul(r,o),w=n.mul(s,a),b=n.mul(i,c),y=n.add(r,s),x=n.add(o,a);y=n.mul(y,x),x=n.add(g,w),y=n.sub(y,x),x=n.add(r,i);let v=n.add(o,c);return x=n.mul(x,v),v=n.add(g,b),x=n.sub(x,v),v=n.add(s,i),u=n.add(a,c),v=n.mul(v,u),u=n.add(w,b),v=n.sub(v,u),h=n.mul(f,x),u=n.mul(m,b),h=n.add(u,h),u=n.sub(w,h),h=n.add(w,h),l=n.mul(u,h),w=n.add(g,g),w=n.add(w,g),b=n.mul(f,b),x=n.mul(m,x),w=n.add(w,b),b=n.sub(g,b),b=n.mul(f,b),x=n.add(x,b),g=n.mul(w,x),l=n.add(l,g),g=n.mul(v,x),u=n.mul(y,u),u=n.sub(u,g),g=n.mul(y,w),h=n.mul(v,h),h=n.add(h,g),new p(u,l,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(p.ZERO)}wNAF(e){return w.wNAFCached(this,e,p.normalizeZ)}multiplyUnsafe(e){const{endo:r,n:s}=t;Un("scalar",e,Er,s);const i=p.ZERO;if(e===Er)return i;if(this.is0()||e===Ar)return this;if(!r||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,e,p.normalizeZ);let{k1neg:o,k1:a,k2neg:c,k2:u}=r.splitScalar(e),l=i,d=i,h=this;for(;a>Er||u>Er;)a&Ar&&(l=l.add(h)),u&Ar&&(d=d.add(h)),h=h.double(),a>>=Ar,u>>=Ar;return o&&(l=l.negate()),c&&(d=d.negate()),d=new p(n.mul(d.px,r.beta),d.py,d.pz),l.add(d)}multiply(e){const{endo:r,n:s}=t;let i,o;if(Un("scalar",e,Ar,s),r){const{k1neg:t,k1:s,k2neg:a,k2:c}=r.splitScalar(e);let{p:u,f:l}=this.wNAF(s),{p:d,f:h}=this.wNAF(c);u=w.constTimeNegate(t,u),d=w.constTimeNegate(a,d),d=new p(n.mul(d.px,r.beta),d.py,d.pz),i=u.add(d),o=l.add(h)}else{const{p:t,f:n}=this.wNAF(e);i=t,o=n}return p.normalizeZ([i,o])[0]}multiplyAndAddUnsafe(e,t,n){const r=p.BASE,s=(e,t)=>t!==Er&&t!==Ar&&e.equals(r)?e.multiply(t):e.multiplyUnsafe(t),i=s(this,t).add(s(e,n));return i.is0()?void 0:i}toAffine(e){return h(this,e)}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===Ar)return!0;if(n)return n(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===Ar?this:n?n(p,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return mn("isCompressed",e),this.assertValidity(),s(p,this,e)}toHex(e=!0){return mn("isCompressed",e),xn(this.toRawBytes(e))}}p.BASE=new p(t.Gx,t.Gy,n.ONE),p.ZERO=new p(n.ZERO,n.ONE,n.ZERO);const{endo:m,nBitLength:g}=t,w=(b=p,y=m?Math.ceil(g/2):g,{constTimeNegate:hr,hasPrecomputes:e=>1!==br(e),unsafeLadder(e,t,n=b.ZERO){let r=e;for(;t>lr;)t&dr&&(n=n.add(r)),r=r.double(),t>>=dr;return n},precomputeWindow(e,t){const{windows:n,windowSize:r}=pr(t,y),s=[];let i=e,o=i;for(let e=0;e<n;e++){o=i,s.push(o);for(let e=1;e<r;e++)o=o.add(i),s.push(o);i=o.double()}return s},wNAF(e,t,n){let r=b.ZERO,s=b.BASE;const i=pr(e,y);for(let e=0;e<i.windows;e++){const{nextN:o,offset:a,isZero:c,isNeg:u,isNegF:l,offsetF:d}=mr(n,e,i);n=o,c?s=s.add(hr(l,t[d])):r=r.add(hr(u,t[a]))}return{p:r,f:s}},wNAFUnsafe(e,t,n,r=b.ZERO){const s=pr(e,y);for(let e=0;e<s.windows&&n!==lr;e++){const{nextN:i,offset:o,isZero:a,isNeg:c}=mr(n,e,s);if(n=i,!a){const e=t[o];r=r.add(c?e.negate():e)}}return r},getPrecomputes(e,t,n){let r=gr.get(t);return r||(r=this.precomputeWindow(t,e),1!==e&&gr.set(t,n(r))),r},wNAFCached(e,t,n){const r=br(e);return this.wNAF(r,this.getPrecomputes(r,e,n),t)},wNAFCachedUnsafe(e,t,n,r){const s=br(e);return 1===s?this.unsafeLadder(e,t,r):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),t,r)},setWindowSize(e,t){fr(t,y),wr.set(e,t),gr.delete(e)}});var b,y;return{CURVE:t,ProjectivePoint:p,normPrivateKeyToScalar:l,weierstrassEquation:o,isWithinCurveOrder:function(e){return Gn(e,Ar,t.n)}}}function Fr(e){const t=function(e){const t=xr(e);return Mn(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:r,nByteLength:s,nBitLength:i}=t,o=n.BYTES+1,a=2*n.BYTES+1;function c(e){return Yn(e,r)}function u(e){return Qn(e,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:f}=Cr({...t,toBytes(e,t,r){const s=t.toAffine(),i=n.toBytes(s.x),o=$n;return mn("isCompressed",r),r?o(Uint8Array.from([t.hasEvenY()?2:3]),i):o(Uint8Array.from([4]),i,n.toBytes(s.y))},fromBytes(e){const t=e.length,r=e[0],s=e.subarray(1);if(t!==o||2!==r&&3!==r){if(t===a&&4===r){return{x:n.fromBytes(s.subarray(0,n.BYTES)),y:n.fromBytes(s.subarray(n.BYTES,2*n.BYTES))}}throw new Error("invalid Point, expected length of "+o+", or uncompressed "+a+", got "+t)}{const e=Cn(s);if(!Gn(e,Ar,n.ORDER))throw new Error("Point is not on curve");const t=h(e);let i;try{i=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~r)!==((i&Ar)===Ar)&&(i=n.neg(i)),{x:e,y:i}}}});function p(e){return e>r>>Ar}const m=(e,t,n)=>Cn(e.slice(t,n));class g{constructor(e,t,n){Un("r",e,Ar,r),Un("s",t,Ar,r),this.r=e,this.s=t,null!=n&&(this.recovery=n),Object.freeze(this)}static fromCompact(e){const t=s;return e=Nn("compactSignature",e,2*t),new g(m(e,0,t),m(e,t,2*t))}static fromDER(e){const{r:t,s:n}=Br.toSig(Nn("DER",e));return new g(t,n)}assertValidity(){}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:r,s:s,recovery:i}=this,o=x(Nn("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const a=2===i||3===i?r+t.n:r;if(a>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const d=1&i?"03":"02",h=l.fromHex(d+Ir(a,n.BYTES)),f=u(a),p=c(-o*f),m=c(s*f),g=l.BASE.multiplyAndAddUnsafe(h,p,m);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return kn(this.toDERHex())}toDERHex(){return Br.hexFromSig(this)}toCompactRawBytes(){return kn(this.toCompactHex())}toCompactHex(){const e=s;return Ir(this.r,e)+Ir(this.s,e)}}const w={isValidPrivateKey(e){try{return d(e),!0}catch(e){return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const e=ur(t.n);return function(e,t,n=!1){const r=e.length,s=cr(t),i=ur(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=Yn(n?Fn(e):Cn(e),t-Dn)+Dn;return n?On(o,s):Sn(o,s)}(t.randomBytes(e),t.n)},precompute:(e=8,t=l.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function b(e){if("bigint"==typeof e)return!1;if(e instanceof l)return!0;const r=Nn("key",e).length,i=n.BYTES,o=i+1,a=2*i+1;return t.allowedPrivateKeyLengths||s===o?void 0:r===o||r===a}const y=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=Cn(e),n=8*e.length-i;return n>0?t>>BigInt(n):t},x=t.bits2int_modN||function(e){return c(y(e))},v=Rn(i);function P(e){return Un("num < 2^"+i,e,Er,v),Sn(e,s)}function B(e,r,s=I){if(["recovered","canonical"].some(e=>e in s))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:o}=t;let{lowS:a,prehash:h,extraEntropy:m}=s;null==a&&(a=!0),e=Nn("msgHash",e),vr(s),h&&(e=Nn("prehashed msgHash",i(e)));const w=x(e),b=d(r),v=[P(b),P(w)];if(null!=m&&!1!==m){const e=!0===m?o(n.BYTES):m;v.push(Nn("extraEntropy",e))}const B=$n(...v),E=w;return{seed:B,k2sig:function(e){const t=y(e);if(!f(t))return;const n=u(t),r=l.BASE.multiply(t).toAffine(),s=c(r.x);if(s===Er)return;const i=c(n*c(E+s*b));if(i===Er)return;let o=(r.x===s?0:2)|Number(r.y&Ar),d=i;return a&&p(i)&&(d=function(e){return p(e)?c(-e):e}(i),o^=1),new g(s,d,o)}}}const I={lowS:t.lowS,prehash:!1},E={lowS:t.lowS,prehash:!1};return l.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return l.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(!0===b(e))throw new Error("first arg must be private key");if(!1===b(t))throw new Error("second arg must be public key");return l.fromHex(t).multiply(d(e)).toRawBytes(n)},sign:function(e,n,r=I){const{seed:s,k2sig:i}=B(e,n,r),o=t,a=function(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=Hn(e),s=Hn(e),i=0;const o=()=>{r.fill(1),s.fill(0),i=0},a=(...e)=>n(s,r,...e),c=(e=Hn(0))=>{s=a(qn([0]),e),r=a(),0!==e.length&&(s=a(qn([1]),e),r=a())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){r=a();const t=r.slice();n.push(t),e+=r.length}return $n(...n)};return(e,t)=>{let n;for(o(),c(e);!(n=t(u()));)c();return o(),n}}(o.hash.outputLen,o.nByteLength,o.hmac);return a(s,i)},verify:function(e,n,r,s=E){const i=e;n=Nn("msgHash",n),r=Nn("publicKey",r);const{lowS:o,prehash:a,format:d}=s;if(vr(s),"strict"in s)throw new Error("options.strict was renamed to lowS");if(void 0!==d&&"compact"!==d&&"der"!==d)throw new Error("format must be compact or der");const h="string"==typeof i||fn(i),f=!h&&!d&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!h&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,m;try{if(f&&(p=new g(i.r,i.s)),h){try{"compact"!==d&&(p=g.fromDER(i))}catch(e){if(!(e instanceof Br.Err))throw e}p||"der"===d||(p=g.fromCompact(i))}m=l.fromHex(r)}catch(e){return!1}if(!p)return!1;if(o&&p.hasHighS())return!1;a&&(n=t.hash(n));const{r:w,s:b}=p,y=x(n),v=u(b),P=c(y*v),B=c(w*v),I=l.BASE.multiplyAndAddUnsafe(m,P,B)?.toAffine();return!!I&&c(I.x)===w},ProjectivePoint:l,Signature:g,utils:w}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sr(e){return{hash:e,hmac:(t,...n)=>ln(e,t,function(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];U(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}(...n)),randomBytes:K}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Or=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Nr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),$r=BigInt(0),zr=BigInt(1),Gr=BigInt(2),Ur=(e,t)=>(e+t/Gr)/t;const Rr=ar(Or,void 0,void 0,{sqrt:function(e){const t=Or,n=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,l=u*u*e%t,d=Jn(l,n,t)*l%t,h=Jn(d,n,t)*l%t,f=Jn(h,Gr,t)*u%t,p=Jn(f,s,t)*f%t,m=Jn(p,i,t)*p%t,g=Jn(m,a,t)*m%t,w=Jn(g,c,t)*g%t,b=Jn(w,a,t)*m%t,y=Jn(b,n,t)*l%t,x=Jn(y,o,t)*p%t,v=Jn(x,r,t)*u%t,P=Jn(v,Gr,t);if(!Rr.eql(Rr.sqr(P),e))throw new Error("Cannot find square root");return P}}),Hr=function(e,t){const n=t=>Fr({...e,...Sr(t)});return{...n(t),create:n}}({a:$r,b:BigInt(7),Fp:Rr,n:Nr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Nr,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-zr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,o=BigInt("0x100000000000000000000000000000000"),a=Ur(i*e,t),c=Ur(-r*e,t);let u=Yn(e-a*n-c*s,t),l=Yn(-a*r-c*i,t);const d=u>o,h=l>o;if(d&&(u=t-u),h&&(l=t-l),u>o||l>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:u,k2neg:h,k2:l}}}},Gt);var qr=Object.freeze({__proto__:null,secp256k1:Hr});const Lr=new Map,Mr=new Map;let Vr=0;function jr(e,t,n){const r=++Vr,s=()=>Lr.get(e)||[],i=()=>{const t=s();if(!t.some(e=>e.id===r))return;const n=Mr.get(e);if(1===t.length&&n){const e=n();e instanceof Promise&&e.catch(()=>{})}(()=>{const t=s();Lr.set(e,t.filter(e=>e.id!==r))})()},o=s();if(Lr.set(e,[...o,{id:r,fns:t}]),o&&o.length>0)return i;const a={};for(const e in t)a[e]=(...t)=>{const n=s();if(0!==n.length)for(const r of n)r.fns[e]?.(...t)};const c=n(a);return"function"==typeof c&&Mr.set(e,c),i}function Dr(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:r,onError:s,poll:i,pollingInterval:o=e.pollingInterval}){let a;return(void 0!==i?i:"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))?jr(Ae(["watchBlockNumber",e.uid,t,n,o]),{onBlockNumber:r,onError:s},r=>function(e,{emitOnBegin:t,initialWaitTime:n,interval:r}){let s=!0;const i=()=>s=!1;return(async()=>{let o;t&&(o=await e({unpoll:i}));const a=await(n?.(o))??r;await tn(a);const c=async()=>{s&&(await e({unpoll:i}),await tn(r),c())};c()})(),i}(async()=>{try{const t=await Le(e,en,"getBlockNumber")({cacheTime:0});if(void 0!==a){if(t===a)return;if(t-a>1&&n)for(let e=a+1n;e<t;e++)r.onBlockNumber(e,a),a=e}(void 0===a||t>a)&&(r.onBlockNumber(t,a),a=t)}catch(e){r.onError?.(e)}},{emitOnBegin:t,interval:o})):jr(Ae(["watchBlockNumber",e.uid,t,n]),{onBlockNumber:r,onError:s},t=>{let n=!0,r=()=>n=!1;return(async()=>{try{const s=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})(),{unsubscribe:i}=await s.subscribe({params:["newHeads"],onData(e){if(!n)return;const r=y(e.result?.number);t.onBlockNumber(r,a),a=r},onError(e){t.onError?.(e)}});r=i,n||r()}catch(e){s?.(e)}})(),()=>r()})}async function _r(e,t){const{checkReplacement:n=!0,confirmations:r=1,hash:s,onReplaced:i,retryCount:o=6,retryDelay:a=({count:e})=>200*(1<<e),timeout:c=18e4}=t,u=Ae(["waitForTransactionReceipt",e.uid,s]),l=t.pollingInterval?t.pollingInterval:e.chain?.experimental_preconfirmationTime?e.chain.experimental_preconfirmationTime:e.pollingInterval;let d,h,f,p,m,g=!1;const{promise:w,resolve:b,reject:y}=function(){let e=()=>{},t=()=>{};return{promise:new Promise((n,r)=>{e=n,t=r}),resolve:e,reject:t}}(),x=c?setTimeout(()=>{m?.(),p?.(),y(new qe({hash:s}))},c):void 0;return p=jr(u,{onReplaced:i,resolve:b,reject:y},async t=>{if(f=await Le(e,cn,"getTransactionReceipt")({hash:s}).catch(()=>{}),f&&r<=1)return clearTimeout(x),t.resolve(f),void p?.();m=Le(e,Dr,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:l,async onBlockNumber(i){const c=e=>{clearTimeout(x),m?.(),e(),p?.()};let u=i;if(!g)try{if(f){if(r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;return void c(()=>t.resolve(f))}if(n&&!d&&(g=!0,await nn(async()=>{d=await Le(e,an,"getTransaction")({hash:s}),d.blockNumber&&(u=d.blockNumber)},{delay:a,retryCount:o}),g=!1),f=await Le(e,cn,"getTransactionReceipt")({hash:s}),r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;c(()=>t.resolve(f))}catch(n){if(n instanceof Re||n instanceof He){if(!d)return void(g=!1);try{h=d,g=!0;const n=await nn(()=>Le(e,Bt,"getBlock")({blockNumber:u,includeTransactions:!0}),{delay:a,retryCount:o,shouldRetry:({error:e})=>e instanceof yt});g=!1;const s=n.transactions.find(({from:e,nonce:t})=>e===h.from&&t===h.nonce);if(!s)return;if(f=await Le(e,cn,"getTransactionReceipt")({hash:s.hash}),r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;let i="replaced";s.to===h.to&&s.value===h.value&&s.input===h.input?i="repriced":s.from===s.to&&0n===s.value&&(i="cancelled"),c(()=>{t.onReplaced?.({reason:i,replacedTransaction:h,transaction:s,transactionReceipt:f}),t.resolve(f)})}catch(e){c(()=>t.reject(e))}}else c(()=>t.reject(n))}}})}),w}class Xr extends l{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join("\n"),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class Kr extends l{constructor({docsPath:e,metaMessages:t,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:t,name:"AccountTypeNotSupportedError"})}}async function Zr(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const Wr=new he(128);async function Yr(e,t){const{account:n=e.account,chain:r=e.chain,accessList:s,authorizationList:i,blobs:o,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:h,maxPriorityFeePerGas:f,nonce:p,type:m,value:g,...w}=t;if(void 0===n)throw new Xr({docsPath:"/docs/actions/wallet/sendTransaction"});const b=n?Ee(n):null;try{at(t);const n=await(async()=>t.to?t.to:null!==t.to&&i&&i.length>0?await pt({authorization:i[0]}).catch(()=>{throw new l("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if("json-rpc"===b?.type||null===b){let t;null!==r&&(t=await Le(e,Dt,"getChainId")({}),rn({currentChainId:t,chain:r}));const l=e.chain?.formatters?.transactionRequest?.format,y=(l||rt)({...tt(w,{format:l}),accessList:s,account:b,authorizationList:i,blobs:o,chainId:t,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:h,maxPriorityFeePerGas:f,nonce:p,to:n,type:m,value:g},"sendTransaction"),x=Wr.get(e.uid),v=x?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:v,params:[y]},{retryCount:0})}catch(t){if(!1===x)throw t;const n=t;if("InvalidInputRpcError"===n.name||"InvalidParamsRpcError"===n.name||"MethodNotFoundRpcError"===n.name||"MethodNotSupportedRpcError"===n.name)return await e.request({method:"wallet_sendTransaction",params:[y]},{retryCount:0}).then(t=>(Wr.set(e.uid,!0),t)).catch(t=>{const r=t;if("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name)throw Wr.set(e.uid,!1),n;throw r});throw n}}if("local"===b?.type){const t=await Le(e,Kt,"prepareTransactionRequest")({account:b,accessList:s,authorizationList:i,blobs:o,chain:r,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:h,maxPriorityFeePerGas:f,nonce:p,nonceManager:b.nonceManager,parameters:[..._t,"sidecars"],type:m,value:g,...w,to:n}),l=r?.serializers?.transaction,y=await b.signTransaction(t,{serializer:l});return await Le(e,Zr,"sendRawTransaction")({serializedTransaction:y})}if("smart"===b?.type)throw new Kr({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new Kr({docsPath:"/docs/actions/wallet/sendTransaction",type:b?.type})}catch(e){if(e instanceof Kr)throw e;throw function(e,{docsPath:t,...n}){const r=(()=>{const t=et(e,n);return t instanceof Qe?e:t})();return new Ue(r,{docsPath:t,...n})}(e,{...t,account:b,chain:t.chain||void 0})}}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const Jr=2n**256n,Qr=Jr-0x1000003d1n,es=Jr-0x14551231950b75fc4402da1732fc9bebfn,ts={a:0n,b:7n},ns=e=>ls(ls(e*e)*e+ts.b),rs=(e="")=>{throw new Error(e)},ss=e=>"bigint"==typeof e,is=e=>"string"==typeof e,os=e=>ss(e)&&0n<e&&e<Qr,as=e=>ss(e)&&0n<e&&e<es,cs=e=>new Uint8Array(e),us=(e,t)=>((e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?rs("Uint8Array expected"):e)(is(e)?bs(e):cs(e),t),ls=(e,t=Qr)=>{let n=e%t;return n>=0n?n:t+n},ds=e=>e instanceof fs?e:rs("Point expected");let hs;class fs{constructor(e,t,n){this.px=e,this.py=t,this.pz=n}static fromAffine(e){return new fs(e.x,e.y,1n)}static fromHex(e){let t;const n=(e=us(e))[0],r=e.subarray(1),s=xs(r,0,32),i=e.length;if(33===i&&[2,3].includes(n)){os(s)||rs("Point hex invalid: x not FE");let e=Bs(ns(s));!(1&~n)!==(1n==(1n&e))&&(e=ls(-e)),t=new fs(s,e,1n)}return 65===i&&4===n&&(t=new fs(s,xs(r,32,64),1n)),t?t.ok():rs("Point is not on curve")}static fromPrivateKey(e){return ps.mul(Is(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:t,py:n,pz:r}=this,{px:s,py:i,pz:o}=ds(e),a=ls(t*o),c=ls(s*r),u=ls(n*o),l=ls(i*r);return a===c&&u===l}negate(){return new fs(this.px,ls(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:t,py:n,pz:r}=this,{px:s,py:i,pz:o}=ds(e),{a:a,b:c}=ts;let u=0n,l=0n,d=0n;const h=ls(3n*c);let f=ls(t*s),p=ls(n*i),m=ls(r*o),g=ls(t+n),w=ls(s+i);g=ls(g*w),w=ls(f+p),g=ls(g-w),w=ls(t+r);let b=ls(s+o);return w=ls(w*b),b=ls(f+m),w=ls(w-b),b=ls(n+r),u=ls(i+o),b=ls(b*u),u=ls(p+m),b=ls(b-u),d=ls(a*w),u=ls(h*m),d=ls(u+d),u=ls(p-d),d=ls(p+d),l=ls(u*d),p=ls(f+f),p=ls(p+f),m=ls(a*m),w=ls(h*w),p=ls(p+m),m=ls(f-m),m=ls(a*m),w=ls(w+m),f=ls(p*w),l=ls(l+f),f=ls(b*w),u=ls(g*u),u=ls(u-f),f=ls(g*p),d=ls(b*d),d=ls(d+f),new fs(u,l,d)}mul(e,t=!0){if(!t&&0n===e)return ms;if(as(e)||rs("invalid scalar"),this.equals(ps))return Es(e).p;let n=ms,r=ps;for(let s=this;e>0n;s=s.double(),e>>=1n)1n&e?n=n.add(s):t&&(r=r.add(s));return n}mulAddQUns(e,t,n){return this.mul(t,!1).add(e.mul(n,!1)).ok()}toAffine(){const{px:e,py:t,pz:n}=this;if(this.equals(ms))return{x:0n,y:0n};if(1n===n)return{x:e,y:t};const r=Ps(n);return 1n!==ls(n*r)&&rs("invalid inverse"),{x:ls(e*r),y:ls(t*r)}}assertValidity(){const{x:e,y:t}=this.aff();return os(e)&&os(t)||rs("Point invalid: x or y"),ls(t*t)===ns(e)?this:rs("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:t,y:n}=this.aff();return(e?0n==(1n&n)?"02":"03":"04")+vs(t)+(e?"":vs(n))}toRawBytes(e=!0){return bs(this.toHex(e))}}fs.BASE=new fs(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),fs.ZERO=new fs(0n,1n,0n);const{BASE:ps,ZERO:ms}=fs,gs=(e,t)=>e.toString(16).padStart(t,"0"),ws=e=>Array.from(e).map(e=>gs(e,2)).join(""),bs=e=>{const t=e.length;(!is(e)||t%2)&&rs("hex invalid 1");const n=cs(t/2);for(let t=0;t<n.length;t++){const r=2*t,s=e.slice(r,r+2),i=Number.parseInt(s,16);(Number.isNaN(i)||i<0)&&rs("hex invalid 2"),n[t]=i}return n},ys=e=>BigInt("0x"+(ws(e)||"0")),xs=(e,t,n)=>ys(e.slice(t,n)),vs=e=>ws((e=>ss(e)&&e>=0n&&e<Jr?bs(gs(e,64)):rs("bigint expected"))(e)),Ps=(e,t=Qr)=>{(0n===e||t<=0n)&&rs("no inverse n="+e+" mod="+t);let n=ls(e,t),r=t,s=0n,i=1n;for(;0n!==n;){const e=r%n,t=s-i*(r/n);r=n,n=e,s=i,i=t}return 1n===r?ls(s,t):rs("no inverse")},Bs=e=>{let t=1n;for(let n=e,r=(Qr+1n)/4n;r>0n;r>>=1n)1n&r&&(t=t*n%Qr),n=n*n%Qr;return ls(t*t)===e?t:rs("sqrt invalid")},Is=e=>(ss(e)||(e=ys(us(e,32))),as(e)?e:rs("private key out of range")),Es=e=>{const t=hs||(hs=(()=>{const e=[];let t=ps,n=t;for(let r=0;r<33;r++){n=t,e.push(n);for(let r=1;r<128;r++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let r=ms,s=ps;const i=BigInt(255),o=BigInt(8);for(let a=0;a<33;a++){const c=128*a;let u=Number(e&i);e>>=o,u>128&&(u-=256,e+=1n);const l=c,d=c+Math.abs(u)-1,h=a%2!=0,f=u<0;0===u?s=s.add(n(h,t[l])):r=r.add(n(f,t[d]))}return{p:r,f:s}};function As(t,n){const r=fs.fromHex(e.utils.strip0x(t)),s=new Uint8Array(r.toRawBytes(!0)),i=e.secp256k1.publicKeyBytesToAddress(s);return e.utils.formatBech32(n,i)}function Ts(e){return"string"==typeof e?{evmAccount:Ee(e)}:e}function ks(t,n){let r;r="string"==typeof t?e.utils.hexToBuffer(t):t;return e.utils.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(r,e.Utxo)}async function Cs(e,t){const n=n=>"P"===t.chainAlias?async function(e,t){return e.request({method:"platform.getUTXOs",params:t})}(e.pChainClient,n):"X"===t.chainAlias?async function(e,t){return e.request({method:"avm.getUTXOs",params:t})}(e.xChainClient,n):async function(e,t){return e.request({method:"avax.getUTXOs",params:t})}(e.cChainClient,n),r=[];let s,i=!1;do{const e=await n({addresses:[t.address],...t.sourceChain?{sourceChain:t.sourceChain}:{},...void 0===s?{}:{startIndex:s}});if(r.push(...e.utxos.map(e=>ks(e,t.chainAlias))),Number(e.numFetched)>=1024?(i=!0,s={address:e.endIndex.address,utxo:e.endIndex.utxo}):i=!1,r.length>=5e3)break}while(i);return r}const Fs="P",Ss="C";async function Os(e){const t=await e.request({method:"platform.getFeeState",params:{}});return{...t,capacity:BigInt(t.capacity),excess:BigInt(t.excess),price:BigInt(t.price)}}async function Ns(e,t,n,r){const i=Ts(t)?.xpAccount||e.xpAccount,o=Ts(t)?.evmAccount||e.account;if(!i||!o){const{xp:t,evm:i}=await s(e);return`${n}-${As(n===Ss?i:t,r)}`}if(n===Ss&&!o.publicKey)throw new Error("EVM public key not found for evm account");return`${n}-${As(n===Ss?o.publicKey:i.publicKey,r)}`}async function $s(e,t){let n=t?.getEVMAddress()||e.account?.address;if(!n){const t=await async function(e){return"local"===e.account?.type?[e.account.address]:(await e.request({method:"eth_accounts"},{dedupe:!0})).map(e=>we(e))}(e);if(0===t.length)throw new Error("No EVM address found from wallet");if(t.length>1)throw new Error("Multiple EVM addresses found from wallet, pass the from address");n=t[0]}return n}function zs(t){return t.includes("-")?e.utils.bech32ToBytes(t):e.utils.bech32ToBytes(`P-${t}`)}function Gs(e){return e/BigInt(1e9)}function Us(e,t){if(1!==t&&5!==t)throw new Error(`Invalid network ID: ${t}`);switch(e){case"X":return 1===t?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case Ss:return 1===t?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case Fs:return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${e}`)}}async function Rs(t,n){const{txParams:r,sourceChain:s,chainAlias:i,subnetId:o,l1ValidationId:a,account:c,context:u}=n,l=await Ns(t,c,i||Fs,u.hrp),d=new Set(r.fromAddresses||[l]);let h,f;if(o){const n=await async function(e,t){return e.request({method:"platform.getTx",params:t})}(t.pChainClient,{txID:o,encoding:"hex"}),r=e.utils.strip0x(n.tx),s=e.utils.getManagerForVM("X"===i?"AVM":"C"===i?"EVM":"PVM").unpack(e.utils.hexToBuffer(r),e.avaxSerial.SignedTx);e.pvmSerial.isCreateSubnetTx(s.unsignedTx)&&(h=new e.PChainOwner(new e.Int(s.unsignedTx.getSubnetOwners().threshold.value()),s.unsignedTx.getSubnetOwners().addrs),s.unsignedTx.getSubnetOwners().addrs.forEach(e=>{d.add(`${Fs}-${e.toString(u.hrp)}`)}))}if(a){const n=await async function(e,t){const n=await e.request({method:"platform.getL1Validator",params:t});return{...n,startTime:BigInt(n.startTime),weight:BigInt(n.weight),...n.minNonce&&{minNonce:BigInt(n.minNonce)},...n.balance&&{balance:BigInt(n.balance)},...n.height&&{height:BigInt(n.height)}}}(t.pChainClient,{validationID:a});f=new e.PChainOwner(new e.Int(Number(n.deactivationOwner.threshold)),n.deactivationOwner.addresses.map(e.Address.fromString)),n.deactivationOwner.addresses.forEach(e=>{const t=e.startsWith("P-")?e:`${Fs}-${e}`;d.add(t)})}const p=Array.from(d),m=r.utxos||(await Promise.all(p.map(e=>Cs(t,{address:e,chainAlias:i||Fs,...s?{sourceChain:s}:{}})))).flat(),g={feeState:await Os(t.pChainClient),fromAddressesBytes:p.map(zs),utxos:m,memo:r.memo?new Uint8Array(Buffer.from(r.memo)):new Uint8Array};return r.changeAddresses&&(g.changeAddressesBytes=r.changeAddresses.map(zs)),r.minIssuanceTime&&(g.minIssuanceTime=r.minIssuanceTime),{commonTxParams:g,subnetOwners:h,disableOwners:f}}function Hs(t,n){return e.TransferableOutput.fromNative(t.assetId??n.avaxAssetID,t.amount,t.addresses.map(e.utils.bech32ToBytes),BigInt(t.locktime??0),t.threshold??1)}function qs(t){return t._type===e.TypeSymbols.AvmExportTx||t._type===e.TypeSymbols.AvmImportTx||t._type===e.TypeSymbols.EvmExportTx||t._type===e.TypeSymbols.EvmImportTx||t._type===e.TypeSymbols.PvmImportTx||t._type===e.TypeSymbols.PvmExportTx}function Ls(e,t){if(e)return e.map(e=>function(e,t){if(!e)return;return e.startsWith(t)?e:`${t}-${1===e.split("-").length?e:e.split("-")[1]}`}(e,t)).filter(e=>void 0!==e)}async function Ms(e,t){const n=!!t.account||!!e.account,r=t.from||await $s(e,t.account),[s,i,o]=await Promise.all([await Zt(e,{to:t.to,value:t.amount,account:r}),await It(e),await Wt(e,{address:r})]),a=s*i;if(o<a||o<t.amount)throw new Error(`Insufficient balance: ${a} AVAX (in wei) is required, but only ${o} AVAX (in wei) is available`);let c;if(n){const n=await Kt(e,{to:t.to,value:t.amount,account:r}),s=t.account?.evmAccount||e.account,i=await async function(e,t){const{account:n=e.account,chain:r=e.chain,...s}=t;if(!n)throw new Xr({docsPath:"/docs/actions/wallet/signTransaction"});const i=Ee(n);at({account:i,...t});const o=await Le(e,Dt,"getChainId")({});null!==r&&rn({currentChainId:o,chain:r});const a=r?.formatters||e.chain?.formatters,c=a?.transactionRequest?.format||rt;return i.signTransaction?i.signTransaction({...s,chainId:o},{serializer:e.chain?.serializers?.transaction}):await e.request({method:"eth_signTransaction",params:[{...c({...s,account:i},"signTransaction"),chainId:I(o),from:i.address}]},{retryCount:0})}(e,{...n,account:s});c=await Zr(e,{serializedTransaction:i})}else c=await Yr(e,{to:t.to,value:t.amount,account:r});return await _r(e,{hash:c}),{txHashes:[{txHash:c,chainAlias:"C"}]}}async function Vs(e){return e.request({method:"eth_baseFee",params:[]})}async function js(e,t){return e.request({method:"info.getBlockchainID",params:t})}t.parseAbiItem("event SendWarpMessage(address indexed sourceAddress, bytes32 indexed unsignedMessageID, bytes message)"),new e.Id(new Uint8Array(32)),new e.Id(new Uint8Array(32));const Ds=1,_s=2,Xs=3,Ks=4,Zs=5,Ws=10,Ys=12345,Js={[Ds]:"avax",[_s]:"cascade",[Xs]:"denali",[Ks]:"everest",[Zs]:"fuji",[Ws]:"testing",[Ys]:"local"},Qs=e=>Js[e]??"custom",ei=async(e,t="AVAX")=>{const{assetID:n}=await async function(e,t){return e.request({method:"avm.getAssetDescription",params:t})}(e.xChainClient,{assetID:t}),{txFee:r,createAssetTxFee:s}=await async function(e){return e.request({method:"avm.getTxFee",params:{}})}(e.xChainClient),{blockchainID:i}=await js(e.infoClient,{alias:"X"}),{blockchainID:o}=await js(e.infoClient,{alias:"P"}),{blockchainID:a}=await js(e.infoClient,{alias:"C"}),{networkID:c}=await async function(e){return e.request({method:"info.getNetworkID",params:{}})}(e.infoClient),u=Number(c),l=await async function(e){const t=await e.request({method:"platform.getFeeConfig",params:{}});return{...t,maxCapacity:BigInt(t.maxCapacity),maxPerSecond:BigInt(t.maxPerSecond),minPrice:BigInt(t.minPrice),targetPerSecond:BigInt(t.targetPerSecond),excessConversionConstant:BigInt(t.excessConversionConstant)}}(e.pChainClient);return Object.freeze({xBlockchainID:i,pBlockchainID:o,cBlockchainID:a,avaxAssetID:n,baseTxFee:BigInt(r),createAssetTxFee:BigInt(s),networkID:u,hrp:Qs(u),platformFeeConfig:l})};function ti(t,n,r,s,i,o=0n){const a=function(t,n,r,s,i,o=0n,a){const c=e.evm.newImportTx(t,n,r,s,i,o,a);return o*e.utils.costCorethTx(c)}(t,n,r,s,i,o);let c=Gs(a);return 0n===c&&(c=1n),e.evm.newImportTx(t,n,r,s,i,c)}async function ni(t,n){const r=n.context||await ei(t),[s,i]=await Promise.all([At(t,{address:`0x${e.utils.strip0x(n.fromAddress)}`}),Vs(t)]),o=n.exportedOutput.addresses.map(e=>zs(e)),a=function(t,n,r,s,i,o,a){let c=Gs(e.evm.estimateExportCost(t,n,r,s,i,o,a));return 0n===c&&(c=1n),e.evm.newExportTx(t,r,s,i,o,c,a)}(r,BigInt(i),n.exportedOutput.amount,Us(n.destinationChain,r.networkID),e.utils.hexToBuffer(n.fromAddress),o,BigInt(s));return{tx:a,exportTx:a.getTx(),chainAlias:"C"}}function ri(e,t){return`${e}-${t}`}async function si(t,n){const{tx:r,signedTxHex:s,chainAlias:i,account:o,utxoIds:a,subnetAuth:c,subnetOwners:u,disableOwners:l,disableAuth:d}=n,h=r||s;if(!h)throw new Error("Either tx or signedTxHex must be provided");const f=Ts(o),p=f?.xpAccount||t.xpAccount;let m,g;if(t.chain?.testnet)m=t.chain?.testnet,g=m?5:1;else{const e=n.context||await ei(t);m=5===e.networkID,g=e.networkID}if(p){const n=As(p.publicKey,m?"fuji":"avax");if("string"==typeof h){let[r,s]=function(t,n){const r=e.utils.strip0x(t),s=e.utils.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM"),i=s.unpackTransaction(Buffer.from(r,"hex")),o=e.utils.bufferToHex(i.toBytes(s.getDefaultCodec())),a=r.slice(0,12),c=r.replace(a+e.utils.strip0x(o),""),u=Buffer.from(e.utils.strip0x(c).slice(8),"hex"),l=[];let d=new Uint8Array(u);for(;d.length>=65;){const[t,n]=e.Credential.fromBytes(d.slice(4),s.getDefaultCodec());l.push(t),d=n.buffer instanceof ArrayBuffer?new Uint8Array(n.buffer,n.byteOffset,n.length):new Uint8Array(n)}return[i,l]}(h,i);const o=r.getSigIndices();0===s.length&&(s=o.map(t=>{const n=t.map(t=>new e.Signature(new Uint8Array(Array(65).fill(0))));return new e.Credential(n)}));const a=e.utils.hexToBuffer(await p.signTransaction(new e.UnsignedTx(r,[],new e.utils.AddressMaps,s).toBytes())),f=r.baseTx.inputs.map(e=>e.utxoID),w=await Cs(t,{address:ri(i,n),chainAlias:i,...qs(r)&&{sourceChain:Us(i,g)}});if(0===w.length)throw new Error("No utxos found for the account address");const b=[];if(f.forEach((e,t)=>{const r=w.find(t=>t.utxoId.ID()===e.ID()&&t.utxoId.outputIdx.toJSON()===e.outputIdx.toJSON());r&&b.push([t,r.getOutputOwners().addrs.findIndex(e=>e.toString(m?"fuji":"avax")===n)])}),b.forEach(e=>{const t=e[0],n=e[1];s[t]?.setSignature(n,a)}),u&&c||l&&d){const e=(c??d)||[],t=(u??l).addresses.filter((t,n)=>e.includes(n)),r=s.length-1,i=t.findIndex(e=>e.toString(m?"fuji":"avax")===n);-1!==i&&(b.push([r,i]),s[r]?.setSignature(i,a))}return{signedTxHex:e.utils.bufferToHex(e.utils.addChecksum(new e.avaxSerial.SignedTx(r,s).toBytes())),signatures:b.map(t=>({signature:e.utils.bufferToHex(a),sigIndices:t})),subnetAuth:c,subnetOwners:u,disableOwners:l,disableAuth:d,chainAlias:i}}{const t=h,n=e.utils.hexToBuffer(await p.signTransaction(h.toBytes()));return t.addSignature(n),(u&&c||l&&d)&&async function(t,n,r,s,i){const o=n.addresses.filter((e,t)=>r.includes(t)),a=t.getCredentials().length-1,c=new e.Address(e.secp256k1.publicKeyBytesToAddress(e.utils.hexToBuffer(i))),u=o.findIndex(e=>e.value()===c.value());-1!==u&&t.addSignatureAt(s,a,u)}(t,u??l,(c??d)||[],n,p.publicKey),{signedTxHex:e.utils.bufferToHex(e.utils.addChecksum(t.getSignedTx().toBytes())),signatures:t.getSigIndicesForPubKey(e.utils.hexToBuffer(p.publicKey))?.map(t=>({signature:e.utils.bufferToHex(n),sigIndices:t})),subnetAuth:c,subnetOwners:u,disableOwners:l,disableAuth:d,chainAlias:i}}}const w=await t.request({method:"avalanche_signTransaction",params:{transactionHex:"string"==typeof h?h:e.utils.bufferToHex(h.toBytes()),chainAlias:i,utxos:a}});return{signedTxHex:w.signedTransactionHex,signatures:w.signatures,subnetAuth:c,subnetOwners:u,disableOwners:l,disableAuth:d,chainAlias:i}}async function ii(t,n){const{tx:r,chainAlias:s,account:i,utxoIds:o,subnetAuth:a,subnetOwners:c,disableOwners:u,disableAuth:l,...d}=n,h=Ts(i);if(h?.xpAccount||t.xpAccount){let e=await si(t,{tx:r,chainAlias:s,subnetOwners:c,subnetAuth:a,disableOwners:u,disableAuth:l});const n=e=>{switch(s){case"P":return async function(e,t){return e.request({method:"platform.issueTx",params:t})}(t.pChainClient,e);case"C":return async function(e,t){return e.request({method:"avax.issueTx",params:t})}(t.cChainClient,e);case"X":return async function(e,t){return e.request({method:"avm.issueTx",params:t})}(t.xChainClient,e)}};return{txHash:(await n({tx:e.signedTxHex,encoding:"hex"})).txID,chainAlias:s}}return{txHash:await t.request({method:"avalanche_sendTransaction",params:{externalIndices:d.externalIndices,internalIndices:d.internalIndices,feeTolerance:d.feeTolerance,transactionHex:"string"==typeof r?r:e.utils.bufferToHex(r.toBytes()),chainAlias:s,utxos:o}}),chainAlias:s}}async function oi(e,t){let{txHash:n,chainAlias:r,sleepTime:s=300,maxRetries:i=10}=t;const o=t=>"P"===r?async function(e,t){return e.request({method:"platform.getTxStatus",params:t})}(e.pChainClient,t):"X"===r?async function(e,t){return e.request({method:"avm.getTxStatus",params:t})}(e.xChainClient,t):async function(e,t){return e.request({method:"avax.getAtomicTxStatus",params:t})}(e.cChainClient,t);for(;i>0;){const e=await o({txID:n});if(["Accepted","Committed"].includes(e.status))return;if(["Rejected","Dropped"].includes(e.status))throw new Error(`Transaction ${n} rejected with status ${e.status}`);i--,await new Promise(e=>setTimeout(e,s))}throw new Error("Transaction status not found")}async function ai(t,n){const r=n.context||await ei(t),s=n.from||await $s(t,n.account),i=await Ns(t,n.account,Fs,5===r.networkID?"fuji":"avax");if(!n.to.startsWith("P-"))throw new Error("Invalid P chain address, it should start with P-");const[o,a,c,u,l]=await Promise.all([ni(t,{destinationChain:"P",fromAddress:s,exportedOutput:{addresses:[i],amount:Gs(n.amount)},context:r}),Os(t.pChainClient),Vs(t),At(t,{address:`0x${e.utils.strip0x(s)}`}),await Wt(t,{address:`0x${e.utils.strip0x(s)}`})]);if(l<n.amount)throw new Error(`Insufficient balance: ${n.amount} ${n.token} (in wei) is required, but only ${l} ${n.token} (in wei) is available`);const d=e.evm.estimateExportCost(r,BigInt(c),Gs(n.amount),Us("P",r.networkID),e.utils.hexToBuffer(s),[zs(n.to)],BigInt(u));if(d>Gs(n.amount))throw new Error(`Transfer amount is too low: ${d} nAVAX Fee is required for C chain export txn, but only ${Gs(n.amount)} nAVAX is being transferred, try sending a higher amount.`);const h=await ii(t,o);await oi(t,h);const f=await async function(t,n){const r=n.context||await ei(t),{commonTxParams:s}=await Rs(t,{txParams:n,context:r,sourceChain:Us(n.sourceChain,r.networkID)}),i=e.pvm.newImportTx({...s,sourceChainId:Us(n.sourceChain,r.networkID),toAddressesBytes:n.importedOutput.addresses.map(e.utils.bech32ToBytes),locktime:BigInt(n.importedOutput.locktime??0),threshold:n.importedOutput.threshold??1},r);return{tx:i,importTx:i.getTx(),chainAlias:Fs}}(t,{sourceChain:"C",importedOutput:{addresses:[n.to]},context:r}),p=e.pvm.calculateFee(f.tx.getTx(),r.platformFeeConfig.weights,a.price);if(p+d>Gs(n.amount))throw new Error(`Transfer amount is too low: ${p} nAVAX Fee is required for P chain import txn, \n      try sending a higher amount.\n      C chain export txn hash: ${h.txHash}`);const m=await ii(t,f);return await oi(t,m),{txHashes:[{txHash:h.txHash,chainAlias:"C"},{txHash:m.txHash,chainAlias:"P"}]}}async function ci(e,t){const n=await e.request({method:"platform.getBalance",params:t});return{...n,balance:BigInt(n.balance),unlocked:BigInt(n.unlocked),lockedNotStakeable:BigInt(n.lockedNotStakeable),lockedStakeable:BigInt(n.lockedStakeable)}}async function ui(t,n){const r=n.context||await ei(t),{commonTxParams:s}=await Rs(t,{txParams:n,context:r}),i=n.exportedOutputs.map(e=>Hs(e,r)),o=e.pvm.newExportTx({...s,outputs:i,destinationChainId:Us(n.destinationChain,r.networkID)},r);return{tx:o,exportTx:o.getTx(),chainAlias:Fs}}async function li(n,r){const s=r.context||await ei(n),i=5===s.networkID;let o=r.from;o||(o=await Ns(n,r.account,Ss,i?"fuji":"avax"));let a=r.from;if(a||(a=await Ns(n,r.account,Fs,i?"fuji":"avax")),!t.isAddress(r.to))throw new Error("Invalid `to` address");const[c,u,l,d]=await Promise.all([await ui(n,{exportedOutputs:[{addresses:[o],amount:Gs(r.amount)}],destinationChain:"C",context:s}),Os(n.pChainClient),Vs(n),(await ci(n.pChainClient,{addresses:[a]})).balance]);if(d<Gs(r.amount))throw new Error(`Insufficient balance: ${Gs(r.amount)} nAVAX is required, but only ${d} nAVAX is available`);const h=e.pvm.calculateFee(c.tx.getTx(),s.platformFeeConfig.weights,u.price);if(h>Gs(r.amount))throw new Error(`Transfer amount is too low: ${h} nAVAX Fee is required for P chain export txn, but only ${Gs(r.amount)} nAVAX is being transferred, try sending a higher amount`);const f=await ii(n,c);await oi(n,f);const p=await async function(t,n){const{account:r}=n,s=n.context||await ei(t),i=await Vs(t),o=Ls(n.fromAddresses,Ss)||[];if(0===o.length){const e=Ts(r),n=await Ns(t,e,Ss,s.hrp);o.push(n)}const a=o.map(e=>zs(e));let c=n.utxos||[];c.length||(c=(await Promise.all(o.map(async e=>await Cs(t,{address:e,chainAlias:"C",sourceChain:Us(n.sourceChain,s.networkID)})))).flat());const u=ti(s,e.utils.hexToBuffer(n.toAddress),a,c,Us(n.sourceChain,s.networkID),BigInt(i));return{tx:u,importTx:u.getTx(),chainAlias:Ss}}(n,{fromAddresses:[o],sourceChain:"P",toAddress:r.to,context:s}),m=BigInt(l)*BigInt(e.utils.costCorethTx(p.tx));if(h+m>Gs(r.amount))throw new Error(`Transfer amount is too low: ${m} nAVAX Fee is required for C chain import txn,\n      try sending a higher amount.\n      P chain export txn hash: ${f.txHash}`);const g=await ii(n,p);return await oi(n,g),{txHashes:[{txHash:f.txHash,chainAlias:"P"},{txHash:g.txHash,chainAlias:"C"}]}}async function di(t,n){const r=n.context||await ei(t),{commonTxParams:s}=await Rs(t,{txParams:n,context:r}),i=n.outputs?n.outputs.map(e=>Hs(e,r)):[],o=e.pvm.newBaseTx({...s,outputs:i},r);return{tx:o,baseTx:o.getTx(),chainAlias:Fs}}exports.addOrModifyXPAddressAlias=Ls,exports.getAccountPubKey=s,exports.send=async function(t,n){const{sourceChain:r="C",destinationChain:s="C",token:i="AVAX"}=n;if("AVAX"!==i)throw new Error(`Invalid token: ${i}, only AVAX is supported.`);switch(r){case"C":switch(s){case"C":return Ms(t,n);case"P":return ai(t,n);default:throw new Error(`Invalid destination chain: ${s}`)}case"P":switch(s){case"P":return async function(t,n){const r=n.context||await ei(t),s=5===r.networkID,i=await Ns(t,n.account,"P",s?"fuji":"avax");if(!n.to.startsWith("P-"))throw new Error("Invalid P chain address, it should start with P-");const[o,a,c]=await Promise.all([di(t,{fromAddresses:[i],outputs:[{addresses:[n.to],amount:Gs(n.amount)}],context:r}),Os(t.pChainClient),(await ci(t.pChainClient,{addresses:[i]})).balance]),u=e.pvm.calculateFee(o.tx.getTx(),r.platformFeeConfig.weights,a.price);if(c<Gs(n.amount))throw new Error(`Insufficient balance: ${Gs(n.amount)} nAVAX is required, but only ${c} nAVAX is available`);if(u>Gs(n.amount))throw new Error(`Transfer amount is too low: ${u} nAVAX Fee is required, but only ${Gs(n.amount)} nAVAX is being transferred`);const l=await ii(t,o);return await oi(t,l),{txHashes:[{txHash:l.txHash,chainAlias:"P"}]}}(t,n);case"C":return li(t,n);default:throw new Error(`Invalid destination chain: ${s}`)}default:throw new Error(`Invalid source chain: ${r}`)}},exports.sendXPTransaction=ii,exports.signXPMessage=async function(e,t){const{message:n,account:r,accountIndex:s}=t,i=Ts(r),o=i?.xpAccount||e.xpAccount;if(o){return{signature:await o.signMessage(n)}}return e.request({method:"avalanche_signMessage",params:{message:n,accountIndex:s}})},exports.signXPTransaction=si,exports.waitForTxn=oi;
