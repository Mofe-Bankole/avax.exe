"use strict";var e=require("@avalabs/avalanchejs");require("viem");const t="P",n="C";async function a(e,t){return e.request({method:"info.getBlockchainID",params:t})}new e.Id(new Uint8Array(32)),new e.Id(new Uint8Array(32));const r=1,s=2,i=3,o=4,c=5,u=10,d=12345,l={[r]:"avax",[s]:"cascade",[i]:"denali",[o]:"everest",[c]:"fuji",[u]:"testing",[d]:"local"},x=e=>l[e]??"custom",m=async(e,t="AVAX")=>{const{assetID:n}=await async function(e,t){return e.request({method:"avm.getAssetDescription",params:t})}(e.xChainClient,{assetID:t}),{txFee:r,createAssetTxFee:s}=await async function(e){return e.request({method:"avm.getTxFee",params:{}})}(e.xChainClient),{blockchainID:i}=await a(e.infoClient,{alias:"X"}),{blockchainID:o}=await a(e.infoClient,{alias:"P"}),{blockchainID:c}=await a(e.infoClient,{alias:"C"}),{networkID:u}=await async function(e){return e.request({method:"info.getNetworkID",params:{}})}(e.infoClient),d=Number(u),l=await async function(e){const t=await e.request({method:"platform.getFeeConfig",params:{}});return{...t,maxCapacity:BigInt(t.maxCapacity),maxPerSecond:BigInt(t.maxPerSecond),minPrice:BigInt(t.minPrice),targetPerSecond:BigInt(t.targetPerSecond),excessConversionConstant:BigInt(t.excessConversionConstant)}}(e.pChainClient);return Object.freeze({xBlockchainID:i,pBlockchainID:o,cBlockchainID:c,avaxAssetID:n,baseTxFee:BigInt(r),createAssetTxFee:BigInt(s),networkID:d,hrp:x(d),platformFeeConfig:l})};function h(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const p=2n**256n,f=p-0x1000003d1n,w=p-0x14551231950b75fc4402da1732fc9bebfn,b={a:0n,b:7n},g=e=>C(C(e*e)*e+b.b),T=(e="")=>{throw new Error(e)},I=e=>"bigint"==typeof e,A=e=>"string"==typeof e,y=e=>I(e)&&0n<e&&e<f,v=e=>I(e)&&0n<e&&e<w,P=e=>new Uint8Array(e),B=(e,t)=>((e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?T("Uint8Array expected"):e)(A(e)?L(e):P(e),t),C=(e,t=f)=>{let n=e%t;return n>=0n?n:t+n},S=e=>e instanceof V?e:T("Point expected");let O;class V{constructor(e,t,n){this.px=e,this.py=t,this.pz=n}static fromAffine(e){return new V(e.x,e.y,1n)}static fromHex(e){let t;const n=(e=B(e))[0],a=e.subarray(1),r=U(a,0,32),s=e.length;if(33===s&&[2,3].includes(n)){y(r)||T("Point hex invalid: x not FE");let e=F(g(r));!(1&~n)!==(1n==(1n&e))&&(e=C(-e)),t=new V(r,e,1n)}return 65===s&&4===n&&(t=new V(r,U(a,32,64),1n)),t?t.ok():T("Point is not on curve")}static fromPrivateKey(e){return k.mul(K(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:t,py:n,pz:a}=this,{px:r,py:s,pz:i}=S(e),o=C(t*i),c=C(r*a),u=C(n*i),d=C(s*a);return o===c&&u===d}negate(){return new V(this.px,C(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:t,py:n,pz:a}=this,{px:r,py:s,pz:i}=S(e),{a:o,b:c}=b;let u=0n,d=0n,l=0n;const x=C(3n*c);let m=C(t*r),h=C(n*s),p=C(a*i),f=C(t+n),w=C(r+s);f=C(f*w),w=C(m+h),f=C(f-w),w=C(t+a);let g=C(r+i);return w=C(w*g),g=C(m+p),w=C(w-g),g=C(n+a),u=C(s+i),g=C(g*u),u=C(h+p),g=C(g-u),l=C(o*w),u=C(x*p),l=C(u+l),u=C(h-l),l=C(h+l),d=C(u*l),h=C(m+m),h=C(h+m),p=C(o*p),w=C(x*w),h=C(h+p),p=C(m-p),p=C(o*p),w=C(w+p),m=C(h*w),d=C(d+m),m=C(g*w),u=C(f*u),u=C(u-m),m=C(f*h),l=C(g*l),l=C(l+m),new V(u,d,l)}mul(e,t=!0){if(!t&&0n===e)return D;if(v(e)||T("invalid scalar"),this.equals(k))return j(e).p;let n=D,a=k;for(let r=this;e>0n;r=r.double(),e>>=1n)1n&e?n=n.add(r):t&&(a=a.add(r));return n}mulAddQUns(e,t,n){return this.mul(t,!1).add(e.mul(n,!1)).ok()}toAffine(){const{px:e,py:t,pz:n}=this;if(this.equals(D))return{x:0n,y:0n};if(1n===n)return{x:e,y:t};const a=R(n);return 1n!==C(n*a)&&T("invalid inverse"),{x:C(e*a),y:C(t*a)}}assertValidity(){const{x:e,y:t}=this.aff();return y(e)&&y(t)||T("Point invalid: x or y"),C(t*t)===g(e)?this:T("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:t,y:n}=this.aff();return(e?0n==(1n&n)?"02":"03":"04")+M(t)+(e?"":M(n))}toRawBytes(e=!0){return L(this.toHex(e))}}V.BASE=new V(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),V.ZERO=new V(0n,1n,0n);const{BASE:k,ZERO:D}=V,N=(e,t)=>e.toString(16).padStart(t,"0"),E=e=>Array.from(e).map(e=>N(e,2)).join(""),L=e=>{const t=e.length;(!A(e)||t%2)&&T("hex invalid 1");const n=P(t/2);for(let t=0;t<n.length;t++){const a=2*t,r=e.slice(a,a+2),s=Number.parseInt(r,16);(Number.isNaN(s)||s<0)&&T("hex invalid 2"),n[t]=s}return n},q=e=>BigInt("0x"+(E(e)||"0")),U=(e,t,n)=>q(e.slice(t,n)),M=e=>E((e=>I(e)&&e>=0n&&e<p?L(N(e,64)):T("bigint expected"))(e)),R=(e,t=f)=>{(0n===e||t<=0n)&&T("no inverse n="+e+" mod="+t);let n=C(e,t),a=t,r=0n,s=1n;for(;0n!==n;){const e=a%n,t=r-s*(a/n);a=n,n=e,r=s,s=t}return 1n===a?C(r,t):T("no inverse")},F=e=>{let t=1n;for(let n=e,a=(f+1n)/4n;a>0n;a>>=1n)1n&a&&(t=t*n%f),n=n*n%f;return C(t*t)===e?t:T("sqrt invalid")},K=e=>(I(e)||(e=q(B(e,32))),v(e)?e:T("private key out of range")),j=e=>{const t=O||(O=(()=>{const e=[];let t=k,n=t;for(let a=0;a<33;a++){n=t,e.push(n);for(let a=1;a<128;a++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let a=D,r=k;const s=BigInt(255),i=BigInt(8);for(let o=0;o<33;o++){const c=128*o;let u=Number(e&s);e>>=i,u>128&&(u-=256,e+=1n);const d=c,l=c+Math.abs(u)-1,x=o%2!=0,m=u<0;0===u?r=r.add(n(x,t[d])):a=a.add(n(m,t[l]))}return{p:a,f:r}};function $(t,n){const a=V.fromHex(e.utils.strip0x(t)),r=new Uint8Array(a.toRawBytes(!0)),s=e.secp256k1.publicKeyBytesToAddress(r);return e.utils.formatBech32(n,s)}function z(e){return"string"==typeof e?{evmAccount:h(e)}:e}function X(t,n){let a;a="string"==typeof t?e.utils.hexToBuffer(t):t;return e.utils.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(a,e.Utxo)}function Y(t){return t.includes("-")?e.utils.bech32ToBytes(t):e.utils.bech32ToBytes(`P-${t}`)}function H(e,a){if(1!==a&&5!==a)throw new Error(`Invalid network ID: ${a}`);switch(e){case"X":return 1===a?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case n:return 1===a?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case t:return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${e}`)}}async function J(a,r){const{txParams:s,sourceChain:i,chainAlias:o,subnetId:c,l1ValidationId:u,account:d,context:l}=r,x=await async function(e,t,a,r){const s=z(t)?.xpAccount||e.xpAccount,i=z(t)?.evmAccount||e.account;if(!s||!i){const{xp:t,evm:s}=await async function(e){return e.request({method:"avalanche_getAccountPubKey",params:{}})}(e);return`${a}-${$(a===n?s:t,r)}`}if(a===n&&!i.publicKey)throw new Error("EVM public key not found for evm account");return`${a}-${$(a===n?i.publicKey:s.publicKey,r)}`}(a,d,o||t,l.hrp),m=new Set(s.fromAddresses||[x]);let h,p;if(c){const n=await async function(e,t){return e.request({method:"platform.getTx",params:t})}(a.pChainClient,{txID:c,encoding:"hex"}),r=e.utils.strip0x(n.tx),s=e.utils.getManagerForVM("X"===o?"AVM":"C"===o?"EVM":"PVM").unpack(e.utils.hexToBuffer(r),e.avaxSerial.SignedTx);e.pvmSerial.isCreateSubnetTx(s.unsignedTx)&&(h=new e.PChainOwner(new e.Int(s.unsignedTx.getSubnetOwners().threshold.value()),s.unsignedTx.getSubnetOwners().addrs),s.unsignedTx.getSubnetOwners().addrs.forEach(e=>{m.add(`${t}-${e.toString(l.hrp)}`)}))}if(u){const n=await async function(e,t){const n=await e.request({method:"platform.getL1Validator",params:t});return{...n,startTime:BigInt(n.startTime),weight:BigInt(n.weight),...n.minNonce&&{minNonce:BigInt(n.minNonce)},...n.balance&&{balance:BigInt(n.balance)},...n.height&&{height:BigInt(n.height)}}}(a.pChainClient,{validationID:u});p=new e.PChainOwner(new e.Int(Number(n.deactivationOwner.threshold)),n.deactivationOwner.addresses.map(e.Address.fromString)),n.deactivationOwner.addresses.forEach(e=>{const n=e.startsWith("P-")?e:`${t}-${e}`;m.add(n)})}const f=Array.from(m),w=s.utxos||(await Promise.all(f.map(e=>async function(e,t){const n=n=>"P"===t.chainAlias?async function(e,t){return e.request({method:"platform.getUTXOs",params:t})}(e.pChainClient,n):"X"===t.chainAlias?async function(e,t){return e.request({method:"avm.getUTXOs",params:t})}(e.xChainClient,n):async function(e,t){return e.request({method:"avax.getUTXOs",params:t})}(e.cChainClient,n),a=[];let r,s=!1;do{const e=await n({addresses:[t.address],...t.sourceChain?{sourceChain:t.sourceChain}:{},...void 0===r?{}:{startIndex:r}});if(a.push(...e.utxos.map(e=>X(e,t.chainAlias))),Number(e.numFetched)>=1024?(s=!0,r={address:e.endIndex.address,utxo:e.endIndex.utxo}):s=!1,a.length>=5e3)break}while(s);return a}(a,{address:e,chainAlias:o||t,...i?{sourceChain:i}:{}})))).flat(),b=await async function(e){const t=await e.request({method:"platform.getFeeState",params:{}});return{...t,capacity:BigInt(t.capacity),excess:BigInt(t.excess),price:BigInt(t.price)}}(a.pChainClient),g={feeState:b,fromAddressesBytes:f.map(Y),utxos:w,memo:s.memo?new Uint8Array(Buffer.from(s.memo)):new Uint8Array};return s.changeAddresses&&(g.changeAddressesBytes=s.changeAddresses.map(Y)),s.minIssuanceTime&&(g.minIssuanceTime=s.minIssuanceTime),{commonTxParams:g,subnetOwners:h,disableOwners:p}}function Q(t,n){return e.TransferableOutput.fromNative(t.assetId??n.avaxAssetID,t.amount,t.addresses.map(e.utils.bech32ToBytes),BigInt(t.locktime??0),t.threshold??1)}exports.prepareAddPermissionlessDelegatorTx=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=e.pvm.newAddPermissionlessDelegatorTx({...s,weight:a.stakeInAvax,nodeId:a.nodeId,start:0n,end:a.end,rewardAddresses:a.rewardAddresses.map(Y),threshold:a.threshold??1,locktime:a.locktime??0n,subnetId:"11111111111111111111111111111111LpoYY"},r);return{tx:i,addPermissionlessDelegatorTx:i.getTx(),chainAlias:t}},exports.prepareAddPermissionlessValidatorTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=e.pvm.newAddPermissionlessValidatorTx({...s,weight:a.stakeInAvax,nodeId:a.nodeId,start:0n,end:BigInt(a.end),rewardAddresses:a.rewardAddresses.map(Y),delegatorRewardsOwner:a.delegatorRewardAddresses.map(Y),shares:1e4*a.delegatorRewardPercentage,threshold:a.threshold??1,locktime:BigInt(a.locktime??0n),subnetId:"11111111111111111111111111111111LpoYY",...a.publicKey?{publicKey:e.utils.hexToBuffer(a.publicKey)}:{},...a.signature?{signature:e.utils.hexToBuffer(a.signature)}:{}},r);return{tx:i,addPermissionlessValidatorTx:i.getTx(),chainAlias:t}},exports.prepareAddSubnetValidatorTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s,subnetOwners:i}=await J(n,{txParams:a,context:r,chainAlias:t,subnetId:a.subnetId});if(!i)throw new Error("Subnet owners not found for a Subnet tx");const o=e.pvm.newAddSubnetValidatorTx({...s,subnetId:a.subnetId,nodeId:a.nodeId,weight:a.weight,start:0n,end:a.end,subnetAuth:a.subnetAuth},r);return{tx:o,addSubnetValidatorTx:o.getTx(),subnetOwners:i,subnetAuth:o.getTx().getSubnetAuth().values(),chainAlias:t}},exports.prepareBaseTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=a.outputs?a.outputs.map(e=>Q(e,r)):[],o=e.pvm.newBaseTx({...s,outputs:i},r);return{tx:o,baseTx:o.getTx(),chainAlias:t}},exports.prepareConvertSubnetToL1Txn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s,subnetOwners:i}=await J(n,{txParams:a,context:r,chainAlias:t,subnetId:a.subnetId});if(!i)throw new Error("Subnet owners not found for a Subnet tx");const o=a.validators.map(t=>e.L1Validator.fromNative(t.nodeId,t.weight,t.initialBalanceInAvax,new e.pvmSerial.ProofOfPossession(e.utils.hexToBuffer(t.nodePoP.publicKey),e.utils.hexToBuffer(t.nodePoP.proofOfPossession)),e.PChainOwner.fromNative(t.remainingBalanceOwner.addresses.map(e=>Y(e)),t.remainingBalanceOwner.threshold),e.PChainOwner.fromNative(t.deactivationOwner.addresses.map(e=>Y(e)),t.deactivationOwner.threshold))),c=e.pvm.newConvertSubnetToL1Tx({...s,subnetId:a.subnetId,chainId:a.blockchainId,address:e.utils.hexToBuffer(a.managerContractAddress),subnetAuth:a.subnetAuth,validators:o},r);return{tx:c,convertSubnetToL1Tx:c.getTx(),subnetOwners:i,subnetAuth:c.getTx().getSubnetAuth().values(),chainAlias:t}},exports.prepareCreateChainTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s,subnetOwners:i}=await J(n,{txParams:a,context:r,chainAlias:t,subnetId:a.subnetId});if(!i)throw new Error("Subnet owners not found for a Subnet tx");const o=e.pvm.newCreateChainTx({...s,subnetId:a.subnetId,vmId:a.vmId,chainName:a.chainName,genesisData:a.genesisData,subnetAuth:a.subnetAuth,fxIds:a.fxIds??[]},r);return{tx:o,createChainTx:o.getTx(),subnetOwners:i,subnetAuth:o.getTx().getSubnetAuth().values(),chainAlias:t}},exports.prepareCreateSubnetTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=a.subnetOwners.addresses.map(e.utils.bech32ToBytes),o=e.pvm.newCreateSubnetTx({...s,subnetOwners:i,locktime:a.subnetOwners.locktime??0n,threshold:a.subnetOwners.threshold??1},r);return{tx:o,createSubnetTx:o.getTx(),chainAlias:t}},exports.prepareDisableL1ValidatorTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s,disableOwners:i}=await J(n,{txParams:a,context:r,l1ValidationId:a.validationId});if(!i)throw new Error("Disable owners not found for a DisableL1ValidatorTx. Either the validator is removed, or incorrect.");const o=e.pvm.newDisableL1ValidatorTx({...s,validationId:a.validationId,disableAuth:a.disableAuth},r);return{tx:o,disableL1ValidatorTx:o.getTx(),disableOwners:i,disableAuth:o.getTx().getDisableAuth().values(),chainAlias:t}},exports.prepareExportTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=a.exportedOutputs.map(e=>Q(e,r)),o=e.pvm.newExportTx({...s,outputs:i,destinationChainId:H(a.destinationChain,r.networkID)},r);return{tx:o,exportTx:o.getTx(),chainAlias:t}},exports.prepareImportTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r,sourceChain:H(a.sourceChain,r.networkID)}),i=e.pvm.newImportTx({...s,sourceChainId:H(a.sourceChain,r.networkID),toAddressesBytes:a.importedOutput.addresses.map(e.utils.bech32ToBytes),locktime:BigInt(a.importedOutput.locktime??0),threshold:a.importedOutput.threshold??1},r);return{tx:i,importTx:i.getTx(),chainAlias:t}},exports.prepareIncreaseL1ValidatorBalanceTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=e.pvm.newIncreaseL1ValidatorBalanceTx({...s,balance:a.balanceInAvax,validationId:a.validationId},r);return{tx:i,increaseL1ValidatorBalanceTx:i.getTx(),chainAlias:t}},exports.prepareRegisterL1ValidatorTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=e.pvm.newRegisterL1ValidatorTx({...s,balance:a.initialBalanceInAvax,blsSignature:e.utils.hexToBuffer(a.blsSignature),message:e.utils.hexToBuffer(a.message)},r);return{tx:i,registerL1ValidatorTx:i.getTx(),chainAlias:t}},exports.prepareRemoveSubnetValidatorTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s,subnetOwners:i}=await J(n,{txParams:a,context:r,chainAlias:t,subnetId:a.subnetId});if(!i)throw new Error("Subnet owners not found for a Subnet tx");const o=e.pvm.newRemoveSubnetValidatorTx({...s,subnetId:a.subnetId,nodeId:a.nodeId,subnetAuth:a.subnetAuth},r);return{tx:o,removeSubnetValidatorTx:o.getTx(),subnetOwners:i,subnetAuth:o.getTx().getSubnetAuth().values(),chainAlias:t}},exports.prepareSetL1ValidatorWeightTxn=async function(n,a){const r=a.context||await m(n),{commonTxParams:s}=await J(n,{txParams:a,context:r}),i=e.pvm.newSetL1ValidatorWeightTx({...s,message:e.utils.hexToBuffer(a.message)},r);return{tx:i,setL1ValidatorWeightTx:i.getTx(),chainAlias:t}};
