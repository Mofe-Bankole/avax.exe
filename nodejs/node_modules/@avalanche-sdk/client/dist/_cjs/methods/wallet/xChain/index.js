"use strict";var e=require("@avalabs/avalanchejs");require("viem");const t="X",n="C";async function s(e,t){return e.request({method:"info.getBlockchainID",params:t})}new e.Id(new Uint8Array(32)),new e.Id(new Uint8Array(32));const r=1,a=2,i=3,o=4,c=5,u=10,m=12345,d={[r]:"avax",[a]:"cascade",[i]:"denali",[o]:"everest",[c]:"fuji",[u]:"testing",[m]:"local"},l=e=>d[e]??"custom",f=async(e,t="AVAX")=>{const{assetID:n}=await async function(e,t){return e.request({method:"avm.getAssetDescription",params:t})}(e.xChainClient,{assetID:t}),{txFee:r,createAssetTxFee:a}=await async function(e){return e.request({method:"avm.getTxFee",params:{}})}(e.xChainClient),{blockchainID:i}=await s(e.infoClient,{alias:"X"}),{blockchainID:o}=await s(e.infoClient,{alias:"P"}),{blockchainID:c}=await s(e.infoClient,{alias:"C"}),{networkID:u}=await async function(e){return e.request({method:"info.getNetworkID",params:{}})}(e.infoClient),m=Number(u),d=await async function(e){const t=await e.request({method:"platform.getFeeConfig",params:{}});return{...t,maxCapacity:BigInt(t.maxCapacity),maxPerSecond:BigInt(t.maxPerSecond),minPrice:BigInt(t.minPrice),targetPerSecond:BigInt(t.targetPerSecond),excessConversionConstant:BigInt(t.excessConversionConstant)}}(e.pChainClient);return Object.freeze({xBlockchainID:i,pBlockchainID:o,cBlockchainID:c,avaxAssetID:n,baseTxFee:BigInt(r),createAssetTxFee:BigInt(a),networkID:m,hrp:l(m),platformFeeConfig:d})};function x(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const p=2n**256n,h=p-0x1000003d1n,y=p-0x14551231950b75fc4402da1732fc9bebfn,g={a:0n,b:7n},w=e=>P(P(e*e)*e+g.b),A=(e="")=>{throw new Error(e)},b=e=>"bigint"==typeof e,I=e=>"string"==typeof e,T=e=>b(e)&&0n<e&&e<h,v=e=>b(e)&&0n<e&&e<y,B=e=>new Uint8Array(e),C=(e,t)=>((e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?A("Uint8Array expected"):e)(I(e)?V(e):B(e),t),P=(e,t=h)=>{let n=e%t;return n>=0n?n:t+n},k=e=>e instanceof q?e:A("Point expected");let D;class q{constructor(e,t,n){this.px=e,this.py=t,this.pz=n}static fromAffine(e){return new q(e.x,e.y,1n)}static fromHex(e){let t;const n=(e=C(e))[0],s=e.subarray(1),r=O(s,0,32),a=e.length;if(33===a&&[2,3].includes(n)){T(r)||A("Point hex invalid: x not FE");let e=M(w(r));!(1&~n)!==(1n==(1n&e))&&(e=P(-e)),t=new q(r,e,1n)}return 65===a&&4===n&&(t=new q(r,O(s,32,64),1n)),t?t.ok():A("Point is not on curve")}static fromPrivateKey(e){return N.mul(X(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:t,py:n,pz:s}=this,{px:r,py:a,pz:i}=k(e),o=P(t*i),c=P(r*s),u=P(n*i),m=P(a*s);return o===c&&u===m}negate(){return new q(this.px,P(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:t,py:n,pz:s}=this,{px:r,py:a,pz:i}=k(e),{a:o,b:c}=g;let u=0n,m=0n,d=0n;const l=P(3n*c);let f=P(t*r),x=P(n*a),p=P(s*i),h=P(t+n),y=P(r+a);h=P(h*y),y=P(f+x),h=P(h-y),y=P(t+s);let w=P(r+i);return y=P(y*w),w=P(f+p),y=P(y-w),w=P(n+s),u=P(a+i),w=P(w*u),u=P(x+p),w=P(w-u),d=P(o*y),u=P(l*p),d=P(u+d),u=P(x-d),d=P(x+d),m=P(u*d),x=P(f+f),x=P(x+f),p=P(o*p),y=P(l*y),x=P(x+p),p=P(f-p),p=P(o*p),y=P(y+p),f=P(x*y),m=P(m+f),f=P(w*y),u=P(h*u),u=P(u-f),f=P(h*x),d=P(w*d),d=P(d+f),new q(u,m,d)}mul(e,t=!0){if(!t&&0n===e)return U;if(v(e)||A("invalid scalar"),this.equals(N))return H(e).p;let n=U,s=N;for(let r=this;e>0n;r=r.double(),e>>=1n)1n&e?n=n.add(r):t&&(s=s.add(r));return n}mulAddQUns(e,t,n){return this.mul(t,!1).add(e.mul(n,!1)).ok()}toAffine(){const{px:e,py:t,pz:n}=this;if(this.equals(U))return{x:0n,y:0n};if(1n===n)return{x:e,y:t};const s=z(n);return 1n!==P(n*s)&&A("invalid inverse"),{x:P(e*s),y:P(t*s)}}assertValidity(){const{x:e,y:t}=this.aff();return T(e)&&T(t)||A("Point invalid: x or y"),P(t*t)===w(e)?this:A("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:t,y:n}=this.aff();return(e?0n==(1n&n)?"02":"03":"04")+S(t)+(e?"":S(n))}toRawBytes(e=!0){return V(this.toHex(e))}}q.BASE=new q(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),q.ZERO=new q(0n,1n,0n);const{BASE:N,ZERO:U}=q,F=(e,t)=>e.toString(16).padStart(t,"0"),E=e=>Array.from(e).map(e=>F(e,2)).join(""),V=e=>{const t=e.length;(!I(e)||t%2)&&A("hex invalid 1");const n=B(t/2);for(let t=0;t<n.length;t++){const s=2*t,r=e.slice(s,s+2),a=Number.parseInt(r,16);(Number.isNaN(a)||a<0)&&A("hex invalid 2"),n[t]=a}return n},j=e=>BigInt("0x"+(E(e)||"0")),O=(e,t,n)=>j(e.slice(t,n)),S=e=>E((e=>b(e)&&e>=0n&&e<p?V(F(e,64)):A("bigint expected"))(e)),z=(e,t=h)=>{(0n===e||t<=0n)&&A("no inverse n="+e+" mod="+t);let n=P(e,t),s=t,r=0n,a=1n;for(;0n!==n;){const e=s%n,t=r-a*(s/n);s=n,n=e,r=a,a=t}return 1n===s?P(r,t):A("no inverse")},M=e=>{let t=1n;for(let n=e,s=(h+1n)/4n;s>0n;s>>=1n)1n&s&&(t=t*n%h),n=n*n%h;return P(t*t)===e?t:A("sqrt invalid")},X=e=>(b(e)||(e=j(C(e,32))),v(e)?e:A("private key out of range")),H=e=>{const t=D||(D=(()=>{const e=[];let t=N,n=t;for(let s=0;s<33;s++){n=t,e.push(n);for(let s=1;s<128;s++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let s=U,r=N;const a=BigInt(255),i=BigInt(8);for(let o=0;o<33;o++){const c=128*o;let u=Number(e&a);e>>=i,u>128&&(u-=256,e+=1n);const m=c,d=c+Math.abs(u)-1,l=o%2!=0,f=u<0;0===u?r=r.add(n(l,t[m])):s=s.add(n(f,t[d]))}return{p:s,f:r}};function K(t,n){const s=q.fromHex(e.utils.strip0x(t)),r=new Uint8Array(s.toRawBytes(!0)),a=e.secp256k1.publicKeyBytesToAddress(r);return e.utils.formatBech32(n,a)}function R(e){return"string"==typeof e?{evmAccount:x(e)}:e}function $(t,n){let s;s="string"==typeof t?e.utils.hexToBuffer(t):t;return e.utils.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(s,e.Utxo)}function J(t){return t.includes("-")?e.utils.bech32ToBytes(t):e.utils.bech32ToBytes(`P-${t}`)}function Q(e,s){if(1!==s&&5!==s)throw new Error(`Invalid network ID: ${s}`);switch(e){case t:return 1===s?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case n:return 1===s?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case"P":return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${e}`)}}async function Y(e,s){const{txParams:r,sourceChain:a,chainAlias:i,account:o,context:c}=s,u=await async function(e,t,s,r){const a=R(t)?.xpAccount||e.xpAccount,i=R(t)?.evmAccount||e.account;if(!a||!i){const{xp:t,evm:a}=await async function(e){return e.request({method:"avalanche_getAccountPubKey",params:{}})}(e);return`${s}-${K(s===n?a:t,r)}`}if(s===n&&!i.publicKey)throw new Error("EVM public key not found for evm account");return`${s}-${K(s===n?i.publicKey:a.publicKey,r)}`}(e,o,i||t,c.hrp),m=new Set(r.fromAddresses||[u]),d=Array.from(m),l=r.utxos||(await Promise.all(d.map(n=>async function(e,t){const n=n=>"P"===t.chainAlias?async function(e,t){return e.request({method:"platform.getUTXOs",params:t})}(e.pChainClient,n):"X"===t.chainAlias?async function(e,t){return e.request({method:"avm.getUTXOs",params:t})}(e.xChainClient,n):async function(e,t){return e.request({method:"avax.getUTXOs",params:t})}(e.cChainClient,n),s=[];let r,a=!1;do{const e=await n({addresses:[t.address],...t.sourceChain?{sourceChain:t.sourceChain}:{},...void 0===r?{}:{startIndex:r}});if(s.push(...e.utxos.map(e=>$(e,t.chainAlias))),Number(e.numFetched)>=1024?(a=!0,r={address:e.endIndex.address,utxo:e.endIndex.utxo}):a=!1,s.length>=5e3)break}while(a);return s}(e,{address:n,chainAlias:i||t,...a?{sourceChain:a}:{}})))).flat(),f={txFee:{txFee:c.baseTxFee,createAssetTxFee:c.createAssetTxFee},fromAddressesBytes:d.map(J),utxos:l,memo:r.memo?new Uint8Array(Buffer.from(r.memo)):new Uint8Array};return r.changeAddresses&&(f.changeAddressesBytes=r.changeAddresses.map(J)),r.minIssuanceTime&&(f.minIssuanceTime=r.minIssuanceTime),{commonTxParams:f}}function L(t,n){return e.TransferableOutput.fromNative(t.assetId??n.avaxAssetID,t.amount,t.addresses.map(e.utils.bech32ToBytes),BigInt(t.locktime??0),t.threshold??1)}exports.prepareBaseTxn=async function(n,s){const r=s.context||await f(n),{commonTxParams:a}=await Y(n,{txParams:s,context:r}),i=s.outputs?s.outputs.map(e=>L(e,r)):[],o=e.avm.newBaseTx(r,a.fromAddressesBytes,a.utxos,i,{...a.changeAddressesBytes&&{changeAddresses:a.changeAddressesBytes},...a.minIssuanceTime&&{minIssuanceTime:a.minIssuanceTime},...a.memo&&{memo:a.memo}});return{tx:o,baseTx:o.getTx(),chainAlias:t}},exports.prepareExportTxn=async function(n,s){const r=s.context||await f(n),{commonTxParams:a}=await Y(n,{txParams:s,context:r}),i=s.exportedOutputs.map(e=>L(e,r)),o=e.avm.newExportTx(r,Q(s.destinationChain,r.networkID),a.fromAddressesBytes,a.utxos,i,{...a.changeAddressesBytes&&{changeAddresses:a.changeAddressesBytes},...a.minIssuanceTime&&{minIssuanceTime:a.minIssuanceTime},...a.memo&&{memo:a.memo}});return{tx:o,exportTx:o.getTx(),chainAlias:t}},exports.prepareImportTxn=async function(n,s){const r=s.context||await f(n),{commonTxParams:a}=await Y(n,{txParams:s,context:r,sourceChain:Q(s.sourceChain,r.networkID)}),i=e.avm.newImportTx(r,Q(s.sourceChain,r.networkID),a.utxos,s.importedOutput.addresses.map(e.utils.bech32ToBytes),a.fromAddressesBytes,{...a.memo&&{memo:a.memo},...a.minIssuanceTime&&{minIssuanceTime:a.minIssuanceTime}},s.importedOutput.threshold??1,BigInt(s.importedOutput.locktime??0));return{tx:i,importTx:i.getTx(),chainAlias:t}};
