import{Id as t,utils as e,secp256k1 as n,Utxo as a,avaxSerial as s,pvmSerial as r,PChainOwner as i,Int as o,Address as c,TransferableOutput as u,pvm as d,L1Validator as l}from"@avalabs/avalanchejs";import"viem";const x="P",m="C";async function h(t,e){return t.request({method:"info.getBlockchainID",params:e})}new t(new Uint8Array(32)),new t(new Uint8Array(32));const f=1,w=2,b=3,p=4,g=5,I=10,T=12345,y={[f]:"avax",[w]:"cascade",[b]:"denali",[p]:"everest",[g]:"fuji",[I]:"testing",[T]:"local"},A=t=>y[t]??"custom",v=async(t,e="AVAX")=>{const{assetID:n}=await async function(t,e){return t.request({method:"avm.getAssetDescription",params:e})}(t.xChainClient,{assetID:e}),{txFee:a,createAssetTxFee:s}=await async function(t){return t.request({method:"avm.getTxFee",params:{}})}(t.xChainClient),{blockchainID:r}=await h(t.infoClient,{alias:"X"}),{blockchainID:i}=await h(t.infoClient,{alias:"P"}),{blockchainID:o}=await h(t.infoClient,{alias:"C"}),{networkID:c}=await async function(t){return t.request({method:"info.getNetworkID",params:{}})}(t.infoClient),u=Number(c),d=await async function(t){const e=await t.request({method:"platform.getFeeConfig",params:{}});return{...e,maxCapacity:BigInt(e.maxCapacity),maxPerSecond:BigInt(e.maxPerSecond),minPrice:BigInt(e.minPrice),targetPerSecond:BigInt(e.targetPerSecond),excessConversionConstant:BigInt(e.excessConversionConstant)}}(t.pChainClient);return Object.freeze({xBlockchainID:r,pBlockchainID:i,cBlockchainID:o,avaxAssetID:n,baseTxFee:BigInt(a),createAssetTxFee:BigInt(s),networkID:u,hrp:A(u),platformFeeConfig:d})};function P(t){return"string"==typeof t?{address:t,type:"json-rpc"}:t}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const B=2n**256n,C=B-0x1000003d1n,S=B-0x14551231950b75fc4402da1732fc9bebfn,O={a:0n,b:7n},k=t=>M(M(t*t)*t+O.b),V=(t="")=>{throw new Error(t)},D=t=>"bigint"==typeof t,N=t=>"string"==typeof t,E=t=>D(t)&&0n<t&&t<C,q=t=>D(t)&&0n<t&&t<S,L=t=>new Uint8Array(t),U=(t,e)=>((t,e)=>!(t instanceof Uint8Array)||"number"==typeof e&&e>0&&t.length!==e?V("Uint8Array expected"):t)(N(t)?Y(t):L(t),e),M=(t,e=C)=>{let n=t%e;return n>=0n?n:e+n},F=t=>t instanceof R?t:V("Point expected");let K;class R{constructor(t,e,n){this.px=t,this.py=e,this.pz=n}static fromAffine(t){return new R(t.x,t.y,1n)}static fromHex(t){let e;const n=(t=U(t))[0],a=t.subarray(1),s=J(a,0,32),r=t.length;if(33===r&&[2,3].includes(n)){E(s)||V("Point hex invalid: x not FE");let t=Z(k(s));!(1&~n)!==(1n==(1n&t))&&(t=M(-t)),e=new R(s,t,1n)}return 65===r&&4===n&&(e=new R(s,J(a,32,64),1n)),e?e.ok():V("Point is not on curve")}static fromPrivateKey(t){return j.mul(_(t))}get x(){return this.aff().x}get y(){return this.aff().y}equals(t){const{px:e,py:n,pz:a}=this,{px:s,py:r,pz:i}=F(t),o=M(e*i),c=M(s*a),u=M(n*i),d=M(r*a);return o===c&&u===d}negate(){return new R(this.px,M(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:e,py:n,pz:a}=this,{px:s,py:r,pz:i}=F(t),{a:o,b:c}=O;let u=0n,d=0n,l=0n;const x=M(3n*c);let m=M(e*s),h=M(n*r),f=M(a*i),w=M(e+n),b=M(s+r);w=M(w*b),b=M(m+h),w=M(w-b),b=M(e+a);let p=M(s+i);return b=M(b*p),p=M(m+f),b=M(b-p),p=M(n+a),u=M(r+i),p=M(p*u),u=M(h+f),p=M(p-u),l=M(o*b),u=M(x*f),l=M(u+l),u=M(h-l),l=M(h+l),d=M(u*l),h=M(m+m),h=M(h+m),f=M(o*f),b=M(x*b),h=M(h+f),f=M(m-f),f=M(o*f),b=M(b+f),m=M(h*b),d=M(d+m),m=M(p*b),u=M(w*u),u=M(u-m),m=M(w*h),l=M(p*l),l=M(l+m),new R(u,d,l)}mul(t,e=!0){if(!e&&0n===t)return $;if(q(t)||V("invalid scalar"),this.equals(j))return G(t).p;let n=$,a=j;for(let s=this;t>0n;s=s.double(),t>>=1n)1n&t?n=n.add(s):e&&(a=a.add(s));return n}mulAddQUns(t,e,n){return this.mul(e,!1).add(t.mul(n,!1)).ok()}toAffine(){const{px:t,py:e,pz:n}=this;if(this.equals($))return{x:0n,y:0n};if(1n===n)return{x:t,y:e};const a=W(n);return 1n!==M(n*a)&&V("invalid inverse"),{x:M(t*a),y:M(e*a)}}assertValidity(){const{x:t,y:e}=this.aff();return E(t)&&E(e)||V("Point invalid: x or y"),M(e*e)===k(t)?this:V("Point invalid: not on curve")}multiply(t){return this.mul(t)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(t=!0){const{x:e,y:n}=this.aff();return(t?0n==(1n&n)?"02":"03":"04")+Q(e)+(t?"":Q(n))}toRawBytes(t=!0){return Y(this.toHex(t))}}R.BASE=new R(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),R.ZERO=new R(0n,1n,0n);const{BASE:j,ZERO:$}=R,z=(t,e)=>t.toString(16).padStart(e,"0"),X=t=>Array.from(t).map(t=>z(t,2)).join(""),Y=t=>{const e=t.length;(!N(t)||e%2)&&V("hex invalid 1");const n=L(e/2);for(let e=0;e<n.length;e++){const a=2*e,s=t.slice(a,a+2),r=Number.parseInt(s,16);(Number.isNaN(r)||r<0)&&V("hex invalid 2"),n[e]=r}return n},H=t=>BigInt("0x"+(X(t)||"0")),J=(t,e,n)=>H(t.slice(e,n)),Q=t=>X((t=>D(t)&&t>=0n&&t<B?Y(z(t,64)):V("bigint expected"))(t)),W=(t,e=C)=>{(0n===t||e<=0n)&&V("no inverse n="+t+" mod="+e);let n=M(t,e),a=e,s=0n,r=1n;for(;0n!==n;){const t=a%n,e=s-r*(a/n);a=n,n=t,s=r,r=e}return 1n===a?M(s,e):V("no inverse")},Z=t=>{let e=1n;for(let n=t,a=(C+1n)/4n;a>0n;a>>=1n)1n&a&&(e=e*n%C),n=n*n%C;return M(e*e)===t?e:V("sqrt invalid")},_=t=>(D(t)||(t=H(U(t,32))),q(t)?t:V("private key out of range")),G=t=>{const e=K||(K=(()=>{const t=[];let e=j,n=e;for(let a=0;a<33;a++){n=e,t.push(n);for(let a=1;a<128;a++)n=n.add(e),t.push(n);e=n.double()}return t})()),n=(t,e)=>{let n=e.negate();return t?n:e};let a=$,s=j;const r=BigInt(255),i=BigInt(8);for(let o=0;o<33;o++){const c=128*o;let u=Number(t&r);t>>=i,u>128&&(u-=256,t+=1n);const d=c,l=c+Math.abs(u)-1,x=o%2!=0,m=u<0;0===u?s=s.add(n(x,e[d])):a=a.add(n(m,e[l]))}return{p:a,f:s}};function tt(t,a){const s=R.fromHex(e.strip0x(t)),r=new Uint8Array(s.toRawBytes(!0)),i=n.publicKeyBytesToAddress(r);return e.formatBech32(a,i)}function et(t){return"string"==typeof t?{evmAccount:P(t)}:t}function nt(t,n){let s;s="string"==typeof t?e.hexToBuffer(t):t;return e.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(s,a)}function at(t){return t.includes("-")?e.bech32ToBytes(t):e.bech32ToBytes(`P-${t}`)}function st(t,e){if(1!==e&&5!==e)throw new Error(`Invalid network ID: ${e}`);switch(t){case"X":return 1===e?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case m:return 1===e?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case x:return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${t}`)}}async function rt(t,n){const{txParams:a,sourceChain:u,chainAlias:d,subnetId:l,l1ValidationId:h,account:f,context:w}=n,b=await async function(t,e,n,a){const s=et(e)?.xpAccount||t.xpAccount,r=et(e)?.evmAccount||t.account;if(!s||!r){const{xp:e,evm:s}=await async function(t){return t.request({method:"avalanche_getAccountPubKey",params:{}})}(t);return`${n}-${tt(n===m?s:e,a)}`}if(n===m&&!r.publicKey)throw new Error("EVM public key not found for evm account");return`${n}-${tt(n===m?r.publicKey:s.publicKey,a)}`}(t,f,d||x,w.hrp),p=new Set(a.fromAddresses||[b]);let g,I;if(l){const n=await async function(t,e){return t.request({method:"platform.getTx",params:e})}(t.pChainClient,{txID:l,encoding:"hex"}),a=e.strip0x(n.tx),c=e.getManagerForVM("X"===d?"AVM":"C"===d?"EVM":"PVM").unpack(e.hexToBuffer(a),s.SignedTx);r.isCreateSubnetTx(c.unsignedTx)&&(g=new i(new o(c.unsignedTx.getSubnetOwners().threshold.value()),c.unsignedTx.getSubnetOwners().addrs),c.unsignedTx.getSubnetOwners().addrs.forEach(t=>{p.add(`${x}-${t.toString(w.hrp)}`)}))}if(h){const e=await async function(t,e){const n=await t.request({method:"platform.getL1Validator",params:e});return{...n,startTime:BigInt(n.startTime),weight:BigInt(n.weight),...n.minNonce&&{minNonce:BigInt(n.minNonce)},...n.balance&&{balance:BigInt(n.balance)},...n.height&&{height:BigInt(n.height)}}}(t.pChainClient,{validationID:h});I=new i(new o(Number(e.deactivationOwner.threshold)),e.deactivationOwner.addresses.map(c.fromString)),e.deactivationOwner.addresses.forEach(t=>{const e=t.startsWith("P-")?t:`${x}-${t}`;p.add(e)})}const T=Array.from(p),y=a.utxos||(await Promise.all(T.map(e=>async function(t,e){const n=n=>"P"===e.chainAlias?async function(t,e){return t.request({method:"platform.getUTXOs",params:e})}(t.pChainClient,n):"X"===e.chainAlias?async function(t,e){return t.request({method:"avm.getUTXOs",params:e})}(t.xChainClient,n):async function(t,e){return t.request({method:"avax.getUTXOs",params:e})}(t.cChainClient,n),a=[];let s,r=!1;do{const t=await n({addresses:[e.address],...e.sourceChain?{sourceChain:e.sourceChain}:{},...void 0===s?{}:{startIndex:s}});if(a.push(...t.utxos.map(t=>nt(t,e.chainAlias))),Number(t.numFetched)>=1024?(r=!0,s={address:t.endIndex.address,utxo:t.endIndex.utxo}):r=!1,a.length>=5e3)break}while(r);return a}(t,{address:e,chainAlias:d||x,...u?{sourceChain:u}:{}})))).flat(),A=await async function(t){const e=await t.request({method:"platform.getFeeState",params:{}});return{...e,capacity:BigInt(e.capacity),excess:BigInt(e.excess),price:BigInt(e.price)}}(t.pChainClient),v={feeState:A,fromAddressesBytes:T.map(at),utxos:y,memo:a.memo?new Uint8Array(Buffer.from(a.memo)):new Uint8Array};return a.changeAddresses&&(v.changeAddressesBytes=a.changeAddresses.map(at)),a.minIssuanceTime&&(v.minIssuanceTime=a.minIssuanceTime),{commonTxParams:v,subnetOwners:g,disableOwners:I}}function it(t,n){return u.fromNative(t.assetId??n.avaxAssetID,t.amount,t.addresses.map(e.bech32ToBytes),BigInt(t.locktime??0),t.threshold??1)}async function ot(t,e){const n=e.context||await v(t),{commonTxParams:a}=await rt(t,{txParams:e,context:n}),s=d.newAddPermissionlessDelegatorTx({...a,weight:e.stakeInAvax,nodeId:e.nodeId,start:0n,end:e.end,rewardAddresses:e.rewardAddresses.map(at),threshold:e.threshold??1,locktime:e.locktime??0n,subnetId:"11111111111111111111111111111111LpoYY"},n);return{tx:s,addPermissionlessDelegatorTx:s.getTx(),chainAlias:x}}async function ct(t,n){const a=n.context||await v(t),{commonTxParams:s}=await rt(t,{txParams:n,context:a}),r=d.newAddPermissionlessValidatorTx({...s,weight:n.stakeInAvax,nodeId:n.nodeId,start:0n,end:BigInt(n.end),rewardAddresses:n.rewardAddresses.map(at),delegatorRewardsOwner:n.delegatorRewardAddresses.map(at),shares:1e4*n.delegatorRewardPercentage,threshold:n.threshold??1,locktime:BigInt(n.locktime??0n),subnetId:"11111111111111111111111111111111LpoYY",...n.publicKey?{publicKey:e.hexToBuffer(n.publicKey)}:{},...n.signature?{signature:e.hexToBuffer(n.signature)}:{}},a);return{tx:r,addPermissionlessValidatorTx:r.getTx(),chainAlias:x}}async function ut(t,e){const n=e.context||await v(t),{commonTxParams:a,subnetOwners:s}=await rt(t,{txParams:e,context:n,chainAlias:x,subnetId:e.subnetId});if(!s)throw new Error("Subnet owners not found for a Subnet tx");const r=d.newAddSubnetValidatorTx({...a,subnetId:e.subnetId,nodeId:e.nodeId,weight:e.weight,start:0n,end:e.end,subnetAuth:e.subnetAuth},n);return{tx:r,addSubnetValidatorTx:r.getTx(),subnetOwners:s,subnetAuth:r.getTx().getSubnetAuth().values(),chainAlias:x}}async function dt(t,e){const n=e.context||await v(t),{commonTxParams:a}=await rt(t,{txParams:e,context:n}),s=e.outputs?e.outputs.map(t=>it(t,n)):[],r=d.newBaseTx({...a,outputs:s},n);return{tx:r,baseTx:r.getTx(),chainAlias:x}}async function lt(t,n){const a=n.context||await v(t),{commonTxParams:s,subnetOwners:o}=await rt(t,{txParams:n,context:a,chainAlias:x,subnetId:n.subnetId});if(!o)throw new Error("Subnet owners not found for a Subnet tx");const c=n.validators.map(t=>l.fromNative(t.nodeId,t.weight,t.initialBalanceInAvax,new r.ProofOfPossession(e.hexToBuffer(t.nodePoP.publicKey),e.hexToBuffer(t.nodePoP.proofOfPossession)),i.fromNative(t.remainingBalanceOwner.addresses.map(t=>at(t)),t.remainingBalanceOwner.threshold),i.fromNative(t.deactivationOwner.addresses.map(t=>at(t)),t.deactivationOwner.threshold))),u=d.newConvertSubnetToL1Tx({...s,subnetId:n.subnetId,chainId:n.blockchainId,address:e.hexToBuffer(n.managerContractAddress),subnetAuth:n.subnetAuth,validators:c},a);return{tx:u,convertSubnetToL1Tx:u.getTx(),subnetOwners:o,subnetAuth:u.getTx().getSubnetAuth().values(),chainAlias:x}}async function xt(t,e){const n=e.context||await v(t),{commonTxParams:a,subnetOwners:s}=await rt(t,{txParams:e,context:n,chainAlias:x,subnetId:e.subnetId});if(!s)throw new Error("Subnet owners not found for a Subnet tx");const r=d.newCreateChainTx({...a,subnetId:e.subnetId,vmId:e.vmId,chainName:e.chainName,genesisData:e.genesisData,subnetAuth:e.subnetAuth,fxIds:e.fxIds??[]},n);return{tx:r,createChainTx:r.getTx(),subnetOwners:s,subnetAuth:r.getTx().getSubnetAuth().values(),chainAlias:x}}async function mt(t,n){const a=n.context||await v(t),{commonTxParams:s}=await rt(t,{txParams:n,context:a}),r=n.subnetOwners.addresses.map(e.bech32ToBytes),i=d.newCreateSubnetTx({...s,subnetOwners:r,locktime:n.subnetOwners.locktime??0n,threshold:n.subnetOwners.threshold??1},a);return{tx:i,createSubnetTx:i.getTx(),chainAlias:x}}async function ht(t,e){const n=e.context||await v(t),{commonTxParams:a,disableOwners:s}=await rt(t,{txParams:e,context:n,l1ValidationId:e.validationId});if(!s)throw new Error("Disable owners not found for a DisableL1ValidatorTx. Either the validator is removed, or incorrect.");const r=d.newDisableL1ValidatorTx({...a,validationId:e.validationId,disableAuth:e.disableAuth},n);return{tx:r,disableL1ValidatorTx:r.getTx(),disableOwners:s,disableAuth:r.getTx().getDisableAuth().values(),chainAlias:x}}async function ft(t,e){const n=e.context||await v(t),{commonTxParams:a}=await rt(t,{txParams:e,context:n}),s=e.exportedOutputs.map(t=>it(t,n)),r=d.newExportTx({...a,outputs:s,destinationChainId:st(e.destinationChain,n.networkID)},n);return{tx:r,exportTx:r.getTx(),chainAlias:x}}async function wt(t,n){const a=n.context||await v(t),{commonTxParams:s}=await rt(t,{txParams:n,context:a,sourceChain:st(n.sourceChain,a.networkID)}),r=d.newImportTx({...s,sourceChainId:st(n.sourceChain,a.networkID),toAddressesBytes:n.importedOutput.addresses.map(e.bech32ToBytes),locktime:BigInt(n.importedOutput.locktime??0),threshold:n.importedOutput.threshold??1},a);return{tx:r,importTx:r.getTx(),chainAlias:x}}async function bt(t,e){const n=e.context||await v(t),{commonTxParams:a}=await rt(t,{txParams:e,context:n}),s=d.newIncreaseL1ValidatorBalanceTx({...a,balance:e.balanceInAvax,validationId:e.validationId},n);return{tx:s,increaseL1ValidatorBalanceTx:s.getTx(),chainAlias:x}}async function pt(t,n){const a=n.context||await v(t),{commonTxParams:s}=await rt(t,{txParams:n,context:a}),r=d.newRegisterL1ValidatorTx({...s,balance:n.initialBalanceInAvax,blsSignature:e.hexToBuffer(n.blsSignature),message:e.hexToBuffer(n.message)},a);return{tx:r,registerL1ValidatorTx:r.getTx(),chainAlias:x}}async function gt(t,e){const n=e.context||await v(t),{commonTxParams:a,subnetOwners:s}=await rt(t,{txParams:e,context:n,chainAlias:x,subnetId:e.subnetId});if(!s)throw new Error("Subnet owners not found for a Subnet tx");const r=d.newRemoveSubnetValidatorTx({...a,subnetId:e.subnetId,nodeId:e.nodeId,subnetAuth:e.subnetAuth},n);return{tx:r,removeSubnetValidatorTx:r.getTx(),subnetOwners:s,subnetAuth:r.getTx().getSubnetAuth().values(),chainAlias:x}}async function It(t,n){const a=n.context||await v(t),{commonTxParams:s}=await rt(t,{txParams:n,context:a}),r=d.newSetL1ValidatorWeightTx({...s,message:e.hexToBuffer(n.message)},a);return{tx:r,setL1ValidatorWeightTx:r.getTx(),chainAlias:x}}export{ot as prepareAddPermissionlessDelegatorTx,ct as prepareAddPermissionlessValidatorTxn,ut as prepareAddSubnetValidatorTxn,dt as prepareBaseTxn,lt as prepareConvertSubnetToL1Txn,xt as prepareCreateChainTxn,mt as prepareCreateSubnetTxn,ht as prepareDisableL1ValidatorTxn,ft as prepareExportTxn,wt as prepareImportTxn,bt as prepareIncreaseL1ValidatorBalanceTxn,pt as prepareRegisterL1ValidatorTxn,gt as prepareRemoveSubnetValidatorTxn,It as prepareSetL1ValidatorWeightTxn};
