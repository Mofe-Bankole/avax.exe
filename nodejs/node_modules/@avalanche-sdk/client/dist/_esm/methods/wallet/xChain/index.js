import{Id as e,utils as t,secp256k1 as n,Utxo as s,TransferableOutput as a,avm as r}from"@avalabs/avalanchejs";import"viem";const i="X",o="C";async function c(e,t){return e.request({method:"info.getBlockchainID",params:t})}new e(new Uint8Array(32)),new e(new Uint8Array(32));const u=1,m=2,d=3,f=4,l=5,h=10,x=12345,p={[u]:"avax",[m]:"cascade",[d]:"denali",[f]:"everest",[l]:"fuji",[h]:"testing",[x]:"local"},y=e=>p[e]??"custom",g=async(e,t="AVAX")=>{const{assetID:n}=await async function(e,t){return e.request({method:"avm.getAssetDescription",params:t})}(e.xChainClient,{assetID:t}),{txFee:s,createAssetTxFee:a}=await async function(e){return e.request({method:"avm.getTxFee",params:{}})}(e.xChainClient),{blockchainID:r}=await c(e.infoClient,{alias:"X"}),{blockchainID:i}=await c(e.infoClient,{alias:"P"}),{blockchainID:o}=await c(e.infoClient,{alias:"C"}),{networkID:u}=await async function(e){return e.request({method:"info.getNetworkID",params:{}})}(e.infoClient),m=Number(u),d=await async function(e){const t=await e.request({method:"platform.getFeeConfig",params:{}});return{...t,maxCapacity:BigInt(t.maxCapacity),maxPerSecond:BigInt(t.maxPerSecond),minPrice:BigInt(t.minPrice),targetPerSecond:BigInt(t.targetPerSecond),excessConversionConstant:BigInt(t.excessConversionConstant)}}(e.pChainClient);return Object.freeze({xBlockchainID:r,pBlockchainID:i,cBlockchainID:o,avaxAssetID:n,baseTxFee:BigInt(s),createAssetTxFee:BigInt(a),networkID:m,hrp:y(m),platformFeeConfig:d})};function w(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const A=2n**256n,b=A-0x1000003d1n,I=A-0x14551231950b75fc4402da1732fc9bebfn,B={a:0n,b:7n},T=e=>F(F(e*e)*e+B.b),v=(e="")=>{throw new Error(e)},C=e=>"bigint"==typeof e,P=e=>"string"==typeof e,k=e=>C(e)&&0n<e&&e<b,D=e=>C(e)&&0n<e&&e<I,q=e=>new Uint8Array(e),N=(e,t)=>((e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?v("Uint8Array expected"):e)(P(e)?O(e):q(e),t),F=(e,t=b)=>{let n=e%t;return n>=0n?n:t+n},U=e=>e instanceof E?e:v("Point expected");let V;class E{constructor(e,t,n){this.px=e,this.py=t,this.pz=n}static fromAffine(e){return new E(e.x,e.y,1n)}static fromHex(e){let t;const n=(e=N(e))[0],s=e.subarray(1),a=H(s,0,32),r=e.length;if(33===r&&[2,3].includes(n)){k(a)||v("Point hex invalid: x not FE");let e=$(T(a));!(1&~n)!==(1n==(1n&e))&&(e=F(-e)),t=new E(a,e,1n)}return 65===r&&4===n&&(t=new E(a,H(s,32,64),1n)),t?t.ok():v("Point is not on curve")}static fromPrivateKey(e){return j.mul(J(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:t,py:n,pz:s}=this,{px:a,py:r,pz:i}=U(e),o=F(t*i),c=F(a*s),u=F(n*i),m=F(r*s);return o===c&&u===m}negate(){return new E(this.px,F(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:t,py:n,pz:s}=this,{px:a,py:r,pz:i}=U(e),{a:o,b:c}=B;let u=0n,m=0n,d=0n;const f=F(3n*c);let l=F(t*a),h=F(n*r),x=F(s*i),p=F(t+n),y=F(a+r);p=F(p*y),y=F(l+h),p=F(p-y),y=F(t+s);let g=F(a+i);return y=F(y*g),g=F(l+x),y=F(y-g),g=F(n+s),u=F(r+i),g=F(g*u),u=F(h+x),g=F(g-u),d=F(o*y),u=F(f*x),d=F(u+d),u=F(h-d),d=F(h+d),m=F(u*d),h=F(l+l),h=F(h+l),x=F(o*x),y=F(f*y),h=F(h+x),x=F(l-x),x=F(o*x),y=F(y+x),l=F(h*y),m=F(m+l),l=F(g*y),u=F(p*u),u=F(u-l),l=F(p*h),d=F(g*d),d=F(d+l),new E(u,m,d)}mul(e,t=!0){if(!t&&0n===e)return S;if(D(e)||v("invalid scalar"),this.equals(j))return Q(e).p;let n=S,s=j;for(let a=this;e>0n;a=a.double(),e>>=1n)1n&e?n=n.add(a):t&&(s=s.add(a));return n}mulAddQUns(e,t,n){return this.mul(t,!1).add(e.mul(n,!1)).ok()}toAffine(){const{px:e,py:t,pz:n}=this;if(this.equals(S))return{x:0n,y:0n};if(1n===n)return{x:e,y:t};const s=R(n);return 1n!==F(n*s)&&v("invalid inverse"),{x:F(e*s),y:F(t*s)}}assertValidity(){const{x:e,y:t}=this.aff();return k(e)&&k(t)||v("Point invalid: x or y"),F(t*t)===T(e)?this:v("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:t,y:n}=this.aff();return(e?0n==(1n&n)?"02":"03":"04")+K(t)+(e?"":K(n))}toRawBytes(e=!0){return O(this.toHex(e))}}E.BASE=new E(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),E.ZERO=new E(0n,1n,0n);const{BASE:j,ZERO:S}=E,z=(e,t)=>e.toString(16).padStart(t,"0"),M=e=>Array.from(e).map(e=>z(e,2)).join(""),O=e=>{const t=e.length;(!P(e)||t%2)&&v("hex invalid 1");const n=q(t/2);for(let t=0;t<n.length;t++){const s=2*t,a=e.slice(s,s+2),r=Number.parseInt(a,16);(Number.isNaN(r)||r<0)&&v("hex invalid 2"),n[t]=r}return n},X=e=>BigInt("0x"+(M(e)||"0")),H=(e,t,n)=>X(e.slice(t,n)),K=e=>M((e=>C(e)&&e>=0n&&e<A?O(z(e,64)):v("bigint expected"))(e)),R=(e,t=b)=>{(0n===e||t<=0n)&&v("no inverse n="+e+" mod="+t);let n=F(e,t),s=t,a=0n,r=1n;for(;0n!==n;){const e=s%n,t=a-r*(s/n);s=n,n=e,a=r,r=t}return 1n===s?F(a,t):v("no inverse")},$=e=>{let t=1n;for(let n=e,s=(b+1n)/4n;s>0n;s>>=1n)1n&s&&(t=t*n%b),n=n*n%b;return F(t*t)===e?t:v("sqrt invalid")},J=e=>(C(e)||(e=X(N(e,32))),D(e)?e:v("private key out of range")),Q=e=>{const t=V||(V=(()=>{const e=[];let t=j,n=t;for(let s=0;s<33;s++){n=t,e.push(n);for(let s=1;s<128;s++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let s=S,a=j;const r=BigInt(255),i=BigInt(8);for(let o=0;o<33;o++){const c=128*o;let u=Number(e&r);e>>=i,u>128&&(u-=256,e+=1n);const m=c,d=c+Math.abs(u)-1,f=o%2!=0,l=u<0;0===u?a=a.add(n(f,t[m])):s=s.add(n(l,t[d]))}return{p:s,f:a}};function Y(e,s){const a=E.fromHex(t.strip0x(e)),r=new Uint8Array(a.toRawBytes(!0)),i=n.publicKeyBytesToAddress(r);return t.formatBech32(s,i)}function L(e){return"string"==typeof e?{evmAccount:w(e)}:e}function Z(e,n){let a;a="string"==typeof e?t.hexToBuffer(e):e;return t.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(a,s)}function W(e){return e.includes("-")?t.bech32ToBytes(e):t.bech32ToBytes(`P-${e}`)}function _(e,t){if(1!==t&&5!==t)throw new Error(`Invalid network ID: ${t}`);switch(e){case i:return 1===t?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case o:return 1===t?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case"P":return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${e}`)}}async function G(e,t){const{txParams:n,sourceChain:s,chainAlias:a,account:r,context:c}=t,u=await async function(e,t,n,s){const a=L(t)?.xpAccount||e.xpAccount,r=L(t)?.evmAccount||e.account;if(!a||!r){const{xp:t,evm:a}=await async function(e){return e.request({method:"avalanche_getAccountPubKey",params:{}})}(e);return`${n}-${Y(n===o?a:t,s)}`}if(n===o&&!r.publicKey)throw new Error("EVM public key not found for evm account");return`${n}-${Y(n===o?r.publicKey:a.publicKey,s)}`}(e,r,a||i,c.hrp),m=new Set(n.fromAddresses||[u]),d=Array.from(m),f=n.utxos||(await Promise.all(d.map(t=>async function(e,t){const n=n=>"P"===t.chainAlias?async function(e,t){return e.request({method:"platform.getUTXOs",params:t})}(e.pChainClient,n):"X"===t.chainAlias?async function(e,t){return e.request({method:"avm.getUTXOs",params:t})}(e.xChainClient,n):async function(e,t){return e.request({method:"avax.getUTXOs",params:t})}(e.cChainClient,n),s=[];let a,r=!1;do{const e=await n({addresses:[t.address],...t.sourceChain?{sourceChain:t.sourceChain}:{},...void 0===a?{}:{startIndex:a}});if(s.push(...e.utxos.map(e=>Z(e,t.chainAlias))),Number(e.numFetched)>=1024?(r=!0,a={address:e.endIndex.address,utxo:e.endIndex.utxo}):r=!1,s.length>=5e3)break}while(r);return s}(e,{address:t,chainAlias:a||i,...s?{sourceChain:s}:{}})))).flat(),l={txFee:{txFee:c.baseTxFee,createAssetTxFee:c.createAssetTxFee},fromAddressesBytes:d.map(W),utxos:f,memo:n.memo?new Uint8Array(Buffer.from(n.memo)):new Uint8Array};return n.changeAddresses&&(l.changeAddressesBytes=n.changeAddresses.map(W)),n.minIssuanceTime&&(l.minIssuanceTime=n.minIssuanceTime),{commonTxParams:l}}function ee(e,n){return a.fromNative(e.assetId??n.avaxAssetID,e.amount,e.addresses.map(t.bech32ToBytes),BigInt(e.locktime??0),e.threshold??1)}async function te(e,t){const n=t.context||await g(e),{commonTxParams:s}=await G(e,{txParams:t,context:n}),a=t.outputs?t.outputs.map(e=>ee(e,n)):[],o=r.newBaseTx(n,s.fromAddressesBytes,s.utxos,a,{...s.changeAddressesBytes&&{changeAddresses:s.changeAddressesBytes},...s.minIssuanceTime&&{minIssuanceTime:s.minIssuanceTime},...s.memo&&{memo:s.memo}});return{tx:o,baseTx:o.getTx(),chainAlias:i}}async function ne(e,t){const n=t.context||await g(e),{commonTxParams:s}=await G(e,{txParams:t,context:n}),a=t.exportedOutputs.map(e=>ee(e,n)),o=r.newExportTx(n,_(t.destinationChain,n.networkID),s.fromAddressesBytes,s.utxos,a,{...s.changeAddressesBytes&&{changeAddresses:s.changeAddressesBytes},...s.minIssuanceTime&&{minIssuanceTime:s.minIssuanceTime},...s.memo&&{memo:s.memo}});return{tx:o,exportTx:o.getTx(),chainAlias:i}}async function se(e,n){const s=n.context||await g(e),{commonTxParams:a}=await G(e,{txParams:n,context:s,sourceChain:_(n.sourceChain,s.networkID)}),o=r.newImportTx(s,_(n.sourceChain,s.networkID),a.utxos,n.importedOutput.addresses.map(t.bech32ToBytes),a.fromAddressesBytes,{...a.memo&&{memo:a.memo},...a.minIssuanceTime&&{minIssuanceTime:a.minIssuanceTime}},n.importedOutput.threshold??1,BigInt(n.importedOutput.locktime??0));return{tx:o,importTx:o.getTx(),chainAlias:i}}export{te as prepareBaseTxn,ne as prepareExportTxn,se as prepareImportTxn};
