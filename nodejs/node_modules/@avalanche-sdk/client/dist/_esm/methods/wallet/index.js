import{utils as e,secp256k1 as t,Credential as n,Utxo as r,TypeSymbols as s,Address as o,avaxSerial as i,pvmSerial as a,PChainOwner as c,Int as u,TransferableOutput as l,Id as d,evm as h,pvm as f,Signature as p,UnsignedTx as m}from"@avalabs/avalanchejs";import{parseAbiItem as g,isAddress as w}from"viem";import*as b from"node:crypto";async function y(e){return e.request({method:"avalanche_getAccountPubKey",params:{}})}function x(e,{strict:t=!0}={}){return!!e&&("string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")))}function v(e){return x(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}const P="2.38.6";let B=({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,E=`viem@${P}`;class I extends Error{constructor(e,t={}){const n=t.cause instanceof I?t.cause.details:t.cause?.message?t.cause.message:t.details,r=t.cause instanceof I&&t.cause.docsPath||t.docsPath,s=B?.({...t,docsPath:r});super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...s?[`Docs: ${s}`]:[],...n?[`Details: ${n}`]:[],...E?[`Version: ${E}`]:[]].join("\n"),t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=n,this.docsPath=r,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=P}walk(e){return A(this,e)}}function A(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e&&void 0!==e.cause?A(e.cause,t):t?null:e}class T extends I{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}class k extends I{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}class F extends I{constructor({size:e,targetSize:t,type:n}){super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${t} ${n} long, but is ${e} ${n} long.`,{name:"InvalidBytesLengthError"})}}function C(e,{dir:t,size:n=32}={}){return"string"==typeof e?function(e,{dir:t,size:n=32}={}){if(null===n)return e;const r=e.replace("0x","");if(r.length>2*n)throw new k({size:Math.ceil(r.length/2),targetSize:n,type:"hex"});return`0x${r["right"===t?"padEnd":"padStart"](2*n,"0")}`}(e,{dir:t,size:n}):function(e,{dir:t,size:n=32}={}){if(null===n)return e;if(e.length>n)throw new k({size:e.length,targetSize:n,type:"bytes"});const r=new Uint8Array(n);for(let s=0;s<n;s++){const o="right"===t;r[o?s:n-s-1]=e[o?s:e.length-s-1]}return r}(e,{dir:t,size:n})}class N extends I{constructor({max:e,min:t,signed:n,size:r,value:s}){super(`Number "${s}" is not in safe ${r?`${8*r}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class S extends I{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}function O(e,{size:t}){if(v(e)>t)throw new S({givenSize:v(e),maxSize:t})}function $(e,t={}){const{signed:n}=t;t.size&&O(e,{size:t.size});const r=BigInt(e);if(!n)return r;const s=(e.length-2)/2;return r<=(1n<<8n*BigInt(s)-1n)-1n?r:r-BigInt(`0x${"f".padStart(2*s,"f")}`)-1n}function z(e,t={}){return Number($(e,t))}const G=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function U(e,t={}){return"number"==typeof e||"bigint"==typeof e?H(e,t):"string"==typeof e?function(e,t={}){const n=q.encode(e);return R(n,t)}(e,t):"boolean"==typeof e?function(e,t={}){const n=`0x${Number(e)}`;if("number"==typeof t.size)return O(n,{size:t.size}),C(n,{size:t.size});return n}(e,t):R(e,t)}function R(e,t={}){let n="";for(let t=0;t<e.length;t++)n+=G[e[t]];const r=`0x${n}`;return"number"==typeof t.size?(O(r,{size:t.size}),C(r,{dir:"right",size:t.size})):r}function H(e,t={}){const{signed:n,size:r}=t,s=BigInt(e);let o;r?o=n?(1n<<8n*BigInt(r)-1n)-1n:2n**(8n*BigInt(r))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const i="bigint"==typeof o&&n?-o-1n:0;if(o&&s>o||s<i){const t="bigint"==typeof e?"n":"";throw new N({max:o?`${o}${t}`:void 0,min:`${i}${t}`,signed:n,size:r,value:`${e}${t}`})}const a=`0x${(n&&s<0?(1n<<BigInt(8*r))+BigInt(s):s).toString(16)}`;return r?C(a,{size:r}):a}const q=new TextEncoder;const L=new TextEncoder;function M(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){const n=H(e,t);return D(n)}(e,t):"boolean"==typeof e?function(e,t={}){const n=new Uint8Array(1);if(n[0]=Number(e),"number"==typeof t.size)return O(n,{size:t.size}),C(n,{size:t.size});return n}(e,t):x(e)?D(e,t):_(e,t)}const V={zero:48,nine:57,A:65,F:70,a:97,f:102};function j(e){return e>=V.zero&&e<=V.nine?e-V.zero:e>=V.A&&e<=V.F?e-(V.A-10):e>=V.a&&e<=V.f?e-(V.a-10):void 0}function D(e,t={}){let n=e;t.size&&(O(n,{size:t.size}),n=C(n,{dir:"right",size:t.size}));let r=n.slice(2);r.length%2&&(r=`0${r}`);const s=r.length/2,o=new Uint8Array(s);for(let e=0,t=0;e<s;e++){const n=j(r.charCodeAt(t++)),s=j(r.charCodeAt(t++));if(void 0===n||void 0===s)throw new I(`Invalid byte sequence ("${r[t-2]}${r[t-1]}" in "${r}").`);o[e]=16*n+s}return o}function _(e,t={}){const n=L.encode(e);return"number"==typeof t.size?(O(n,{size:t.size}),C(n,{dir:"right",size:t.size})):n}const X=BigInt(2**32-1),Z=BigInt(32);function K(e,t=!1){return t?{h:Number(e&X),l:Number(e>>Z&X)}:{h:0|Number(e>>Z&X),l:0|Number(e&X)}}const W=b&&"object"==typeof b&&"webcrypto"in b?b.webcrypto:b&&"object"==typeof b&&"randomBytes"in b?b:void 0;function Y(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function J(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Q(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function ee(e,t){J(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function te(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function ne(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function re(e,t){return e<<32-t|e>>>t}function se(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const oe=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?e=>e:function(e){for(let t=0;t<e.length;t++)e[t]=se(e[t]);return e};function ie(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),J(e),e}class ae{}function ce(e){const t=t=>e().update(ie(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function ue(e=32){if(W&&"function"==typeof W.getRandomValues)return W.getRandomValues(new Uint8Array(e));if(W&&"function"==typeof W.randomBytes)return Uint8Array.from(W.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}const le=BigInt(0),de=BigInt(1),he=BigInt(2),fe=BigInt(7),pe=BigInt(256),me=BigInt(113),ge=[],we=[],be=[];for(let e=0,t=de,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],ge.push(2*(5*r+n)),we.push((e+1)*(e+2)/2%64);let s=le;for(let e=0;e<7;e++)t=(t<<de^(t>>fe)*me)%pe,t&he&&(s^=de<<(de<<BigInt(e))-de);be.push(s)}const ye=function(e,t=!1){const n=e.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let o=0;o<n;o++){const{h:n,l:i}=K(e[o],t);[r[o],s[o]]=[n,i]}return[r,s]}(be,!0),xe=ye[0],ve=ye[1],Pe=(e,t,n)=>n>32?((e,t,n)=>t<<n-32|e>>>64-n)(e,t,n):((e,t,n)=>e<<n|t>>>32-n)(e,t,n),Be=(e,t,n)=>n>32?((e,t,n)=>e<<n-32|t>>>64-n)(e,t,n):((e,t,n)=>t<<n|e>>>32-n)(e,t,n);class Ee extends ae{constructor(e,t,n,r=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=r,this.rounds=s,Y(n),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");var o;this.state=new Uint8Array(200),this.state32=(o=this.state,new Uint32Array(o.buffer,o.byteOffset,Math.floor(o.byteLength/4)))}clone(){return this._cloneInto()}keccak(){oe(this.state32),function(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let t=0;t<10;t++)n[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const r=(t+8)%10,s=(t+2)%10,o=n[s],i=n[s+1],a=Pe(o,i,1)^n[r],c=Be(o,i,1)^n[r+1];for(let n=0;n<50;n+=10)e[t+n]^=a,e[t+n+1]^=c}let t=e[2],s=e[3];for(let n=0;n<24;n++){const r=we[n],o=Pe(t,s,r),i=Be(t,s,r),a=ge[n];t=e[a],s=e[a+1],e[a]=o,e[a+1]=i}for(let t=0;t<50;t+=10){for(let r=0;r<10;r++)n[r]=e[t+r];for(let r=0;r<10;r++)e[t+r]^=~n[(r+2)%10]&n[(r+4)%10]}e[0]^=xe[r],e[1]^=ve[r]}te(n)}(this.state32,this.rounds),oe(this.state32),this.posOut=0,this.pos=0}update(e){Q(this),J(e=ie(e));const{blockLen:t,state:n}=this,r=e.length;for(let s=0;s<r;){const o=Math.min(t-this.pos,r-s);for(let t=0;t<o;t++)n[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:r}=this;e[n]^=t,128&t&&n===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){Q(this,!1),J(e),this.finish();const t=this.state,{blockLen:n}=this;for(let r=0,s=e.length;r<s;){this.posOut>=n&&this.keccak();const o=Math.min(n-this.posOut,s-r);e.set(t.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Y(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ee(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,te(this.state)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:r,rounds:s,enableXOF:o}=this;return e||(e=new Ee(t,n,r,o,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=n,e.outputLen=r,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Ie=(()=>{return e=1,t=136,n=32,ce(()=>new Ee(t,e,n));var e,t,n})();function Ae(e,t){const n=t||"hex",r=Ie(x(e,{strict:!1})?M(e):e);return"bytes"===n?r:U(r)}class Te extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&void 0!==t&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const e=this.keys().next().value;e&&this.delete(e)}return this}}const ke=/^0x[a-fA-F0-9]{40}$/,Fe=new Te(8192);function Ce(e,t){const{strict:n=!0}=t??{},r=`${e}.${n}`;if(Fe.has(r))return Fe.get(r);const s=!(!ke.test(e)||e.toLowerCase()!==e&&n&&Se(e)!==e);return Fe.set(r,s),s}const Ne=new Te(8192);function Se(e,t){if(Ne.has(`${e}.${t}`))return Ne.get(`${e}.${t}`);const n=e.substring(2).toLowerCase(),r=Ae(_(n),"bytes"),s=n.split("");for(let e=0;e<40;e+=2)r[e>>1]>>4>=8&&s[e]&&(s[e]=s[e].toUpperCase()),(15&r[e>>1])>=8&&s[e+1]&&(s[e+1]=s[e+1].toUpperCase());const o=`0x${s.join("")}`;return Ne.set(`${e}.${t}`,o),o}class Oe extends I{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class $e extends I{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`,{name:"PositionOutOfBoundsError"})}}class ze extends I{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`,{name:"RecursiveReadLimitExceededError"})}}const Ge={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new ze({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new $e({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new Oe({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new Oe({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function Ue(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(Ge);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}class Re extends I{constructor({chain:e,currentChainId:t}){super(`The current chain of the wallet (id: ${t}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e.id} – ${e.name}`],name:"ChainMismatchError"})}}class He extends I{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n"),{name:"ChainNotFoundError"})}}function qe(e){return"string"==typeof e?{address:e,type:"json-rpc"}:e}const Le=(e,t,n)=>JSON.stringify(e,(e,t)=>"bigint"==typeof t?t.toString():t,n),Me={gwei:9,wei:18},Ve={ether:-9,wei:9};function je(e,t){let n=e.toString();const r=n.startsWith("-");r&&(n=n.slice(1)),n=n.padStart(t,"0");let[s,o]=[n.slice(0,n.length-t),n.slice(n.length-t)];return o=o.replace(/(0+)$/,""),`${r?"-":""}${s||"0"}${o?`.${o}`:""}`}function De(e,t="wei"){return je(e,Me[t])}function _e(e,t="wei"){return je(e,Ve[t])}class Xe extends I{constructor({address:e}){super(`State for account "${e}" is set multiple times.`,{name:"AccountStateConflictError"})}}class Ze extends I{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function Ke(e){const t=Object.entries(e).map(([e,t])=>void 0===t||!1===t?null:[e,t]).filter(Boolean),n=t.reduce((e,[t])=>Math.max(e,t.length),0);return t.map(([e,t])=>`  ${`${e}:`.padEnd(n+1)}  ${t}`).join("\n")}class We extends I{constructor(){super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.","Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n"),{name:"FeeConflictError"})}}class Ye extends I{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",Ke(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}class Je extends I{constructor(e,{account:t,docsPath:n,chain:r,data:s,gas:o,gasPrice:i,maxFeePerGas:a,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const h=Ke({chain:r&&`${r?.name} (id: ${r?.id})`,from:t?.address,to:l,value:void 0!==d&&`${De(d)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:s,gas:o,gasPrice:void 0!==i&&`${_e(i)} gwei`,maxFeePerGas:void 0!==a&&`${_e(a)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${_e(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Request Arguments:",h].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class Qe extends I{constructor({blockHash:e,blockNumber:t,blockTag:n,hash:r,index:s}){let o="Transaction";n&&void 0!==s&&(o=`Transaction at block time "${n}" at index "${s}"`),e&&void 0!==s&&(o=`Transaction at block hash "${e}" at index "${s}"`),t&&void 0!==s&&(o=`Transaction at block number "${t}" at index "${s}"`),r&&(o=`Transaction with hash "${r}"`),super(`${o} could not be found.`,{name:"TransactionNotFoundError"})}}class et extends I{constructor({hash:e}){super(`Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class tt extends I{constructor({hash:e}){super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}function nt(e,t,n){const r=e[t.name];if("function"==typeof r)return r;const s=e[n];return"function"==typeof s?s:n=>t(e,n)}class rt extends I{constructor({cause:e,message:t}={}){const n=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`,{cause:e,name:"ExecutionRevertedError"})}}Object.defineProperty(rt,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(rt,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class st extends I{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${_e(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e,name:"FeeCapTooHighError"})}}Object.defineProperty(st,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class ot extends I{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${_e(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e,name:"FeeCapTooLowError"})}}Object.defineProperty(ot,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class it extends I{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e,name:"NonceTooHighError"})}}Object.defineProperty(it,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class at extends I{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e,name:"NonceTooLowError"})}}Object.defineProperty(at,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class ct extends I{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e,name:"NonceMaxValueError"})}}Object.defineProperty(ct,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class ut extends I{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(ut,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class lt extends I{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(lt,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class dt extends I{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(dt,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class ht extends I{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(ht,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class ft extends I{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:n}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${_e(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${_e(n)} gwei`:""}).`].join("\n"),{cause:e,name:"TipAboveFeeCapError"})}}Object.defineProperty(ft,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class pt extends I{constructor({cause:e}){super(`An error occurred while executing: ${e?.shortMessage}`,{cause:e,name:"UnknownNodeError"})}}function mt(e,t){const n=(e.details||"").toLowerCase(),r=e instanceof I?e.walk(e=>e?.code===rt.code):e;return r instanceof I?new rt({cause:e,message:r.details}):rt.nodeMessage.test(n)?new rt({cause:e,message:e.details}):st.nodeMessage.test(n)?new st({cause:e,maxFeePerGas:t?.maxFeePerGas}):ot.nodeMessage.test(n)?new ot({cause:e,maxFeePerGas:t?.maxFeePerGas}):it.nodeMessage.test(n)?new it({cause:e,nonce:t?.nonce}):at.nodeMessage.test(n)?new at({cause:e,nonce:t?.nonce}):ct.nodeMessage.test(n)?new ct({cause:e,nonce:t?.nonce}):ut.nodeMessage.test(n)?new ut({cause:e}):lt.nodeMessage.test(n)?new lt({cause:e,gas:t?.gas}):dt.nodeMessage.test(n)?new dt({cause:e,gas:t?.gas}):ht.nodeMessage.test(n)?new ht({cause:e}):ft.nodeMessage.test(n)?new ft({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new pt({cause:e})}function gt(e,{format:t}){if(!t)return{};const n={};return function t(r){const s=Object.keys(r);for(const o of s)o in e&&(n[o]=e[o]),r[o]&&"object"==typeof r[o]&&!Array.isArray(r[o])&&t(r[o])}(t(e||{})),n}const wt={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function bt(e,t){const n={};return void 0!==e.authorizationList&&(n.authorizationList=e.authorizationList.map(e=>({address:e.address,r:e.r?H(BigInt(e.r)):e.r,s:e.s?H(BigInt(e.s)):e.s,chainId:H(e.chainId),nonce:H(e.nonce),...void 0!==e.yParity?{yParity:H(e.yParity)}:{},...void 0!==e.v&&void 0===e.yParity?{v:H(e.v)}:{}}))),void 0!==e.accessList&&(n.accessList=e.accessList),void 0!==e.blobVersionedHashes&&(n.blobVersionedHashes=e.blobVersionedHashes),void 0!==e.blobs&&("string"!=typeof e.blobs[0]?n.blobs=e.blobs.map(e=>R(e)):n.blobs=e.blobs),void 0!==e.data&&(n.data=e.data),e.account&&(n.from=e.account.address),void 0!==e.from&&(n.from=e.from),void 0!==e.gas&&(n.gas=H(e.gas)),void 0!==e.gasPrice&&(n.gasPrice=H(e.gasPrice)),void 0!==e.maxFeePerBlobGas&&(n.maxFeePerBlobGas=H(e.maxFeePerBlobGas)),void 0!==e.maxFeePerGas&&(n.maxFeePerGas=H(e.maxFeePerGas)),void 0!==e.maxPriorityFeePerGas&&(n.maxPriorityFeePerGas=H(e.maxPriorityFeePerGas)),void 0!==e.nonce&&(n.nonce=H(e.nonce)),void 0!==e.to&&(n.to=e.to),void 0!==e.type&&(n.type=wt[e.type]),void 0!==e.value&&(n.value=H(e.value)),n}function yt(e){if(e&&0!==e.length)return e.reduce((e,{slot:t,value:n})=>{if(66!==t.length)throw new F({size:t.length,targetSize:66,type:"hex"});if(66!==n.length)throw new F({size:n.length,targetSize:66,type:"hex"});return e[t]=n,e},{})}function xt(e){const{balance:t,nonce:n,state:r,stateDiff:s,code:o}=e,i={};if(void 0!==o&&(i.code=o),void 0!==t&&(i.balance=H(t)),void 0!==n&&(i.nonce=H(n)),void 0!==r&&(i.state=yt(r)),void 0!==s){if(i.state)throw new Ze;i.stateDiff=yt(s)}return i}const vt=2n**256n-1n;function Pt(e){const{account:t,gasPrice:n,maxFeePerGas:r,maxPriorityFeePerGas:s,to:o}=e,i=t?qe(t):void 0;if(i&&!Ce(i.address))throw new T({address:i.address});if(o&&!Ce(o))throw new T({address:o});if(void 0!==n&&(void 0!==r||void 0!==s))throw new We;if(r&&r>vt)throw new st({maxFeePerGas:r});if(s&&r&&s>r)throw new ft({maxFeePerGas:r,maxPriorityFeePerGas:s})}function Bt(e){if(0===e||1===e)return e;if(27===e)return 0;if(28===e)return 1;throw new Error("Invalid yParityOrV value")}async function Et({hash:e,signature:t}){return n=await async function({hash:e,signature:t}){const n=x(e)?e:U(e),{secp256k1:r}=await Promise.resolve().then(function(){return ts});return`0x${(()=>{if("object"==typeof t&&"r"in t&&"s"in t){const{r:e,s:n,v:s,yParity:o}=t,i=Bt(Number(o??s));return new r.Signature($(e),$(n)).addRecoveryBit(i)}const e=x(t)?t:U(t);if(65!==v(e))throw new Error("invalid signature length");const n=Bt(z(`0x${e.slice(130)}`));return r.Signature.fromCompact(e.substring(2,130)).addRecoveryBit(n)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}({hash:e,signature:t}),Se(`0x${Ae(`0x${n.substring(4)}`).substring(26)}`);var n}function It(e,t="hex"){const n=At(e),r=Ue(new Uint8Array(n.length));return n.encode(r),"hex"===t?R(r.bytes):r.bytes}function At(e){return Array.isArray(e)?function(e){const t=e.reduce((e,t)=>e+t.length,0),n=Tt(t);return{length:t<=55?1+t:1+n+t,encode(r){t<=55?r.pushByte(192+t):(r.pushByte(247+n),1===n?r.pushUint8(t):2===n?r.pushUint16(t):3===n?r.pushUint24(t):r.pushUint32(t));for(const{encode:t}of e)t(r)}}}(e.map(e=>At(e))):function(e){const t="string"==typeof e?D(e):e,n=Tt(t.length),r=1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length;return{length:r,encode(e){1===t.length&&t[0]<128?e.pushBytes(t):t.length<=55?(e.pushByte(128+t.length),e.pushBytes(t)):(e.pushByte(183+n),1===n?e.pushUint8(t.length):2===n?e.pushUint16(t.length):3===n?e.pushUint24(t.length):e.pushUint32(t.length),e.pushBytes(t))}}}(e)}function Tt(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new I("Length is too large.")}function kt(e){const{chainId:t,nonce:n,to:r}=e,s=e.contractAddress??e.address,o=Ae(`0x${["0x05",It([t?H(t):"0x",s,n?H(n):"0x"])].reduce((e,t)=>e+t.replace("0x",""),"")}`);return"bytes"===r?D(o):o}async function Ft(e){const{authorization:t,signature:n}=e;return Et({hash:kt(t),signature:n??t})}class Ct extends I{constructor(e,{account:t,docsPath:n,chain:r,data:s,gas:o,gasPrice:i,maxFeePerGas:a,maxPriorityFeePerGas:c,nonce:u,to:l,value:d}){const h=Ke({from:t?.address,to:l,value:void 0!==d&&`${De(d)} ${r?.nativeCurrency?.symbol||"ETH"}`,data:s,gas:o,gasPrice:void 0!==i&&`${_e(i)} gwei`,maxFeePerGas:void 0!==a&&`${_e(a)} gwei`,maxPriorityFeePerGas:void 0!==c&&`${_e(c)} gwei`,nonce:u});super(e.shortMessage,{cause:e,docsPath:n,metaMessages:[...e.metaMessages?[...e.metaMessages," "]:[],"Estimate Gas Arguments:",h].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=e}}class Nt extends I{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class St extends I{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class Ot extends I{constructor({maxPriorityFeePerGas:e}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${_e(e)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class $t extends I{constructor({blockHash:e,blockNumber:t}){let n="Block";e&&(n=`Block at hash "${e}"`),t&&(n=`Block at number "${t}"`),super(`${n} could not be found.`,{name:"BlockNotFoundError"})}}const zt={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function Gt(e,t){const n={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?z(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?z(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?zt[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};return e.authorizationList&&(n.authorizationList=e.authorizationList.map(e=>({address:e.address,chainId:Number(e.chainId),nonce:Number(e.nonce),r:e.r,s:e.s,yParity:Number(e.yParity)}))),n.yParity=(()=>{if(e.yParity)return Number(e.yParity);if("bigint"==typeof n.v){if(0n===n.v||27n===n.v)return 0;if(1n===n.v||28n===n.v)return 1;if(n.v>=35n)return n.v%2n==0n?1:0}})(),"legacy"===n.type&&(delete n.accessList,delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas,delete n.yParity),"eip2930"===n.type&&(delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas),"eip1559"===n.type&&delete n.maxFeePerBlobGas,n}function Ut(e,t){const n=(e.transactions??[]).map(e=>"string"==typeof e?e:Gt(e));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:n,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function Rt(e,{blockHash:t,blockNumber:n,blockTag:r=e.experimental_blockTag??"latest",includeTransactions:s}={}){const o=s??!1,i=void 0!==n?H(n):void 0;let a=null;if(a=t?await e.request({method:"eth_getBlockByHash",params:[t,o]},{dedupe:!0}):await e.request({method:"eth_getBlockByNumber",params:[i||r,o]},{dedupe:Boolean(i)}),!a)throw new $t({blockHash:t,blockNumber:n});return(e.chain?.formatters?.block?.format||Ut)(a,"getBlock")}async function Ht(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function qt(e,t){const{block:n,chain:r=e.chain,request:s,type:o="eip1559"}=t||{},i=await(async()=>"function"==typeof r?.fees?.baseFeeMultiplier?r.fees.baseFeeMultiplier({block:n,client:e,request:s}):r?.fees?.baseFeeMultiplier??1.2)();if(i<1)throw new Nt;const a=10**(i.toString().split(".")[1]?.length??0),c=e=>e*BigInt(Math.ceil(i*a))/BigInt(a),u=n||await nt(e,Rt,"getBlock")({});if("function"==typeof r?.fees?.estimateFeesPerGas){const t=await r.fees.estimateFeesPerGas({block:n,client:e,multiply:c,request:s,type:o});if(null!==t)return t}if("eip1559"===o){if("bigint"!=typeof u.baseFeePerGas)throw new St;const t="bigint"==typeof s?.maxPriorityFeePerGas?s.maxPriorityFeePerGas:await async function(e,t){const{block:n,chain:r=e.chain,request:s}=t||{};try{const t=r?.fees?.maxPriorityFeePerGas??r?.fees?.defaultPriorityFee;if("function"==typeof t){const r=n||await nt(e,Rt,"getBlock")({}),o=await t({block:r,client:e,request:s});if(null===o)throw new Error;return o}return void 0!==t?t:$(await e.request({method:"eth_maxPriorityFeePerGas"}))}catch{const[t,r]=await Promise.all([n?Promise.resolve(n):nt(e,Rt,"getBlock")({}),nt(e,Ht,"getGasPrice")({})]);if("bigint"!=typeof t.baseFeePerGas)throw new St;const s=r-t.baseFeePerGas;return s<0n?0n:s}}(e,{block:u,chain:r,request:s}),n=c(u.baseFeePerGas);return{maxFeePerGas:s?.maxFeePerGas??n+t,maxPriorityFeePerGas:t}}return{gasPrice:s?.gasPrice??c(await nt(e,Ht,"getGasPrice")({}))}}async function Lt(e,{address:t,blockTag:n="latest",blockNumber:r}){return z(await e.request({method:"eth_getTransactionCount",params:[t,"bigint"==typeof r?H(r):n]},{dedupe:Boolean(r)}))}function Mt(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),r="string"==typeof e.blobs[0]?e.blobs.map(e=>D(e)):e.blobs,s=[];for(const e of r)s.push(Uint8Array.from(t.blobToKzgCommitment(e)));return"bytes"===n?s:s.map(e=>R(e))}function Vt(e){const{kzg:t}=e,n=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),r="string"==typeof e.blobs[0]?e.blobs.map(e=>D(e)):e.blobs,s="string"==typeof e.commitments[0]?e.commitments.map(e=>D(e)):e.commitments,o=[];for(let e=0;e<r.length;e++){const n=r[e],i=s[e];o.push(Uint8Array.from(t.computeBlobKzgProof(n,i)))}return"bytes"===n?o:o.map(e=>R(e))}function jt(e,t,n){return e&t^~e&n}function Dt(e,t,n){return e&t^e&n^t&n}class _t extends ae{constructor(e,t,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(e),this.view=ne(this.buffer)}update(e){Q(this),J(e=ie(e));const{view:t,buffer:n,blockLen:r}=this,s=e.length;for(let o=0;o<s;){const i=Math.min(r-this.pos,s-o);if(i===r){const t=ne(e);for(;r<=s-o;o+=r)this.process(t,o);continue}n.set(e.subarray(o,o+i),this.pos),this.pos+=i,o+=i,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Q(this),ee(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:s}=this;let{pos:o}=this;t[o++]=128,te(this.buffer.subarray(o)),this.padOffset>r-o&&(this.process(n,0),o=0);for(let e=o;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(n>>s&o),a=Number(n&o),c=r?4:0,u=r?0:4;e.setUint32(t+c,i,r),e.setUint32(t+u,a,r)}(n,r-8,BigInt(8*this.length),s),this.process(n,0);const i=ne(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)i.setUint32(4*e,u[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:s,destroyed:o,pos:i}=this;return e.destroyed=o,e.finished=s,e.length=r,e.pos=i,r%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Xt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Zt=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Kt=new Uint32Array(64);class Wt extends _t{constructor(e=32){super(64,e,8,!1),this.A=0|Xt[0],this.B=0|Xt[1],this.C=0|Xt[2],this.D=0|Xt[3],this.E=0|Xt[4],this.F=0|Xt[5],this.G=0|Xt[6],this.H=0|Xt[7]}get(){const{A:e,B:t,C:n,D:r,E:s,F:o,G:i,H:a}=this;return[e,t,n,r,s,o,i,a]}set(e,t,n,r,s,o,i,a){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|s,this.F=0|o,this.G=0|i,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)Kt[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Kt[e-15],n=Kt[e-2],r=re(t,7)^re(t,18)^t>>>3,s=re(n,17)^re(n,19)^n>>>10;Kt[e]=s+Kt[e-7]+r+Kt[e-16]|0}let{A:n,B:r,C:s,D:o,E:i,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(re(i,6)^re(i,11)^re(i,25))+jt(i,a,c)+Zt[e]+Kt[e]|0,l=(re(n,2)^re(n,13)^re(n,22))+Dt(n,r,s)|0;u=c,c=a,a=i,i=o+t|0,o=s,s=r,r=n,n=t+l|0}n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,o=o+this.D|0,i=i+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(n,r,s,o,i,a,c,u)}roundClean(){te(Kt)}destroy(){this.set(0,0,0,0,0,0,0,0),te(this.buffer)}}const Yt=ce(()=>new Wt),Jt=Yt;function Qt(e){const{commitment:t,version:n=1}=e,r=e.to??("string"==typeof t?"hex":"bytes"),s=Jt(x(o=t,{strict:!1})?M(o):o);var o;return s.set([n],0),"bytes"===r?s:R(s)}const en=4096,tn=131072,nn=761855;class rn extends I{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`],name:"BlobSizeTooLargeError"})}}class sn extends I{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}function on(e){const{data:t,kzg:n,to:r}=e,s=e.blobs??function(e){const t="string"==typeof e.data?D(e.data):e.data,n=v(t);if(!n)throw new sn;if(n>nn)throw new rn({maxSize:nn,size:n});const r=[];let s=!0,o=0;for(;s;){const e=Ue(new Uint8Array(tn));let n=0;for(;n<en;){const r=t.slice(o,o+31);if(e.pushByte(0),e.pushBytes(r),r.length<31){e.pushByte(128),s=!1;break}n++,o+=31}r.push(e)}return r.map(e=>R(e.bytes))}({data:t}),o=e.commitments??Mt({blobs:s,kzg:n,to:r}),i=e.proofs??Vt({blobs:s,commitments:o,kzg:n,to:r}),a=[];for(let e=0;e<s.length;e++)a.push({blob:s[e],commitment:o[e],proof:i[e]});return a}async function an(e){return z(await e.request({method:"eth_chainId"},{dedupe:!0}))}const cn=["blobVersionedHashes","chainId","fees","gas","nonce","type"],un=new Map;async function ln(e,t){const{account:n=e.account,blobs:r,chain:s,gas:o,kzg:i,nonce:a,nonceManager:c,parameters:u=cn,type:l}=t,d=n?qe(n):n,h={...t,...d?{from:d?.address}:{}};let f,p;async function m(){return f||(f=await nt(e,Rt,"getBlock")({blockTag:"latest"}),f)}async function g(){if(p)return p;if(s)return s.id;if(void 0!==t.chainId)return t.chainId;const n=await nt(e,an,"getChainId")({});return p=n,p}if(u.includes("nonce")&&void 0===a&&d)if(c){const t=await g();h.nonce=await c.consume({address:d.address,chainId:t,client:e})}else h.nonce=await nt(e,Lt,"getTransactionCount")({address:d.address,blockTag:"pending"});if((u.includes("blobVersionedHashes")||u.includes("sidecars"))&&r&&i){const e=Mt({blobs:r,kzg:i});if(u.includes("blobVersionedHashes")){const t=function(e){const{commitments:t,version:n}=e,r=e.to,s=[];for(const e of t)s.push(Qt({commitment:e,to:r,version:n}));return s}({commitments:e,to:"hex"});h.blobVersionedHashes=t}if(u.includes("sidecars")){const t=on({blobs:r,commitments:e,proofs:Vt({blobs:r,commitments:e,kzg:i}),to:"hex"});h.sidecars=t}}if(u.includes("chainId")&&(h.chainId=await g()),(u.includes("fees")||u.includes("type"))&&void 0===l)try{h.type=function(e){if(e.type)return e.type;if(void 0!==e.authorizationList)return"eip7702";if(void 0!==e.blobs||void 0!==e.blobVersionedHashes||void 0!==e.maxFeePerBlobGas||void 0!==e.sidecars)return"eip4844";if(void 0!==e.maxFeePerGas||void 0!==e.maxPriorityFeePerGas)return"eip1559";if(void 0!==e.gasPrice)return void 0!==e.accessList?"eip2930":"legacy";throw new Ye({transaction:e})}(h)}catch{let t=un.get(e.uid);if(void 0===t){const n=await m();t="bigint"==typeof n?.baseFeePerGas,un.set(e.uid,t)}h.type=t?"eip1559":"legacy"}if(u.includes("fees"))if("legacy"!==h.type&&"eip2930"!==h.type){if(void 0===h.maxFeePerGas||void 0===h.maxPriorityFeePerGas){const n=await m(),{maxFeePerGas:r,maxPriorityFeePerGas:o}=await qt(e,{block:n,chain:s,request:h});if(void 0===t.maxPriorityFeePerGas&&t.maxFeePerGas&&t.maxFeePerGas<o)throw new Ot({maxPriorityFeePerGas:o});h.maxPriorityFeePerGas=o,h.maxFeePerGas=r}}else{if(void 0!==t.maxFeePerGas||void 0!==t.maxPriorityFeePerGas)throw new St;if(void 0===t.gasPrice){const t=await m(),{gasPrice:n}=await qt(e,{block:t,chain:s,request:h,type:"legacy"});h.gasPrice=n}}return u.includes("gas")&&void 0===o&&(h.gas=await nt(e,dn,"estimateGas")({...h,account:d,prepare:"local"===d?.type?[]:["blobVersionedHashes"]})),Pt(h),delete h.parameters,h}async function dn(e,t){const{account:n=e.account,prepare:r=!0}=t,s=n?qe(n):void 0,o=Array.isArray(r)?r:"local"!==s?.type?["blobVersionedHashes"]:void 0;try{const{accessList:n,authorizationList:i,blobs:a,blobVersionedHashes:c,blockNumber:u,blockTag:l,data:d,gas:h,gasPrice:f,maxFeePerBlobGas:p,maxFeePerGas:m,maxPriorityFeePerGas:g,nonce:w,value:b,stateOverride:y,...x}=r?await ln(e,{...t,parameters:o}):t,v=("bigint"==typeof u?H(u):void 0)||l,P=function(e){if(!e)return;const t={};for(const{address:n,...r}of e){if(!Ce(n,{strict:!1}))throw new T({address:n});if(t[n])throw new Xe({address:n});t[n]=xt(r)}return t}(y),B=await(async()=>x.to?x.to:i&&i.length>0?await Ft({authorization:i[0]}).catch(()=>{throw new I("`to` is required. Could not infer from `authorizationList`")}):void 0)();Pt(t);const E=e.chain?.formatters?.transactionRequest?.format,A=(E||bt)({...gt(x,{format:E}),account:s,accessList:n,authorizationList:i,blobs:a,blobVersionedHashes:c,data:d,gas:h,gasPrice:f,maxFeePerBlobGas:p,maxFeePerGas:m,maxPriorityFeePerGas:g,nonce:w,to:B,value:b},"estimateGas");return BigInt(await e.request({method:"eth_estimateGas",params:P?[A,v??e.experimental_blockTag??"latest",P]:v?[A,v]:[A]}))}catch(n){throw function(e,{docsPath:t,...n}){const r=(()=>{const t=mt(e,n);return t instanceof pt?e:t})();return new Ct(r,{docsPath:t,...n})}(n,{...t,account:s,chain:e.chain})}}async function hn(e,{address:t,blockNumber:n,blockTag:r=e.experimental_blockTag??"latest"}){const s="bigint"==typeof n?H(n):void 0,o=await e.request({method:"eth_getBalance",params:[t,s||r]});return BigInt(o)}const fn=new Map,pn=new Map;async function mn(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const r=function(e){const t=(e,t)=>({clear:()=>t.delete(e),get:()=>t.get(e),set:n=>t.set(e,n)}),n=t(e,fn),r=t(e,pn);return{clear:()=>{n.clear(),r.clear()},promise:n,response:r}}(t),s=r.response.get();if(s&&n>0){if(Date.now()-s.created.getTime()<n)return s.data}let o=r.promise.get();o||(o=e(),r.promise.set(o));try{const e=await o;return r.response.set({created:new Date,data:e}),e}finally{r.promise.clear()}}async function gn(e,{cacheTime:t=e.cacheTime}={}){const n=await mn(()=>e.request({method:"eth_blockNumber"}),{cacheKey:(r=e.uid,`blockNumber.${r}`),cacheTime:t});var r;return BigInt(n)}async function wn(e){return new Promise(t=>setTimeout(t,e))}function bn(e,{delay:t=100,retryCount:n=2,shouldRetry:r=()=>!0}={}){return new Promise((s,o)=>{const i=async({count:a=0}={})=>{try{const t=await e();s(t)}catch(e){if(a<n&&await r({count:a,error:e}))return(async({error:e})=>{const n="function"==typeof t?t({count:a,error:e}):t;n&&await wn(n),i({count:a+1})})({error:e});o(e)}};i()})}function yn({chain:e,currentChainId:t}){if(!e)throw new He;if(t!==e.id)throw new Re({chain:e,currentChainId:t})}const xn={"0x0":"reverted","0x1":"success"};function vn(e,t){const n={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(e=>function(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}(e)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?z(e.transactionIndex):null,status:e.status?xn[e.status]:null,type:e.type?zt[e.type]||e.type:null};return e.blobGasPrice&&(n.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(n.blobGasUsed=BigInt(e.blobGasUsed)),n}async function Pn(e,{blockHash:t,blockNumber:n,blockTag:r,hash:s,index:o}){const i=r||"latest",a=void 0!==n?H(n):void 0;let c=null;if(c=s?await e.request({method:"eth_getTransactionByHash",params:[s]},{dedupe:!0}):t?await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,H(o)]},{dedupe:!0}):await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[a||i,H(o)]},{dedupe:Boolean(a)}),!c)throw new Qe({blockHash:t,blockNumber:n,blockTag:i,hash:s,index:o});return(e.chain?.formatters?.transaction?.format||Gt)(c,"getTransaction")}async function Bn(e,{hash:t}){const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new et({hash:t});return(e.chain?.formatters?.transactionReceipt?.format||vn)(n,"getTransactionReceipt")}class En extends ae{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.createHasher");Y(e.outputLen),Y(e.blockLen)}(e);const n=ie(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?e.create().update(n).digest():n);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),te(s)}update(e){return Q(this),this.iHash.update(e),this}digestInto(e){Q(this),J(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:r,destroyed:s,blockLen:o,outputLen:i}=this;return e.finished=r,e.destroyed=s,e.blockLen=o,e.outputLen=i,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const In=(e,t,n)=>new En(e,t).update(n).digest();In.create=(e,t)=>new En(e,t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const An=BigInt(0),Tn=BigInt(1);function kn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function Fn(e){if(!kn(e))throw new Error("Uint8Array expected")}function Cn(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}function Nn(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function Sn(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?An:BigInt("0x"+e)}const On="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,$n=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function zn(e){if(Fn(e),On)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=$n[e[n]];return t}const Gn=48,Un=57,Rn=65,Hn=70,qn=97,Ln=102;function Mn(e){return e>=Gn&&e<=Un?e-Gn:e>=Rn&&e<=Hn?e-(Rn-10):e>=qn&&e<=Ln?e-(qn-10):void 0}function Vn(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(On)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,s=0;t<n;t++,s+=2){const n=Mn(e.charCodeAt(s)),o=Mn(e.charCodeAt(s+1));if(void 0===n||void 0===o){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}r[t]=16*n+o}return r}function jn(e){return Sn(zn(e))}function Dn(e){return Fn(e),Sn(zn(Uint8Array.from(e).reverse()))}function _n(e,t){return Vn(e.toString(16).padStart(2*t,"0"))}function Xn(e,t){return _n(e,t).reverse()}function Zn(e,t,n){let r;if("string"==typeof t)try{r=Vn(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!kn(t))throw new Error(e+" must be hex string or Uint8Array");r=Uint8Array.from(t)}const s=r.length;if("number"==typeof n&&s!==n)throw new Error(e+" of length "+n+" expected, got "+s);return r}function Kn(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];Fn(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}const Wn=e=>"bigint"==typeof e&&An<=e;function Yn(e,t,n){return Wn(e)&&Wn(t)&&Wn(n)&&t<=e&&e<n}function Jn(e,t,n,r){if(!Yn(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}const Qn=e=>(Tn<<BigInt(e))-Tn,er=e=>new Uint8Array(e),tr=e=>Uint8Array.from(e);const nr={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||kn(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function rr(e,t,n={}){const r=(t,n,r)=>{const s=nr[n];if("function"!=typeof s)throw new Error("invalid validator function");const o=e[t];if(!(r&&void 0===o||s(o,e)))throw new Error("param "+String(t)+" is invalid. Expected "+n+", got "+o)};for(const[e,n]of Object.entries(t))r(e,n,!1);for(const[e,t]of Object.entries(n))r(e,t,!0);return e}function sr(e){const t=new WeakMap;return(n,...r)=>{const s=t.get(n);if(void 0!==s)return s;const o=e(n,...r);return t.set(n,o),o}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const or=BigInt(0),ir=BigInt(1),ar=BigInt(2),cr=BigInt(3),ur=BigInt(4),lr=BigInt(5),dr=BigInt(8);function hr(e,t){const n=e%t;return n>=or?n:t+n}function fr(e,t,n){let r=e;for(;t-- >or;)r*=r,r%=n;return r}function pr(e,t){if(e===or)throw new Error("invert: expected non-zero number");if(t<=or)throw new Error("invert: expected positive modulus, got "+t);let n=hr(e,t),r=t,s=or,o=ir;for(;n!==or;){const e=r%n,t=s-o*(r/n);r=n,n=e,s=o,o=t}if(r!==ir)throw new Error("invert: does not exist");return hr(s,t)}function mr(e,t){const n=(e.ORDER+ir)/ur,r=e.pow(t,n);if(!e.eql(e.sqr(r),t))throw new Error("Cannot find square root");return r}function gr(e,t){const n=(e.ORDER-lr)/dr,r=e.mul(t,ar),s=e.pow(r,n),o=e.mul(t,s),i=e.mul(e.mul(o,ar),s),a=e.mul(o,e.sub(i,e.ONE));if(!e.eql(e.sqr(a),t))throw new Error("Cannot find square root");return a}function wr(e){return e%ur===cr?mr:e%dr===lr?gr:function(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let t=e-ir,n=0;for(;t%ar===or;)t/=ar,n++;let r=ar;const s=Pr(e);for(;1===xr(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return mr;let o=s.pow(r,t);const i=(t+ir)/ar;return function(e,r){if(e.is0(r))return r;if(1!==xr(e,r))throw new Error("Cannot find square root");let s=n,a=e.mul(e.ONE,o),c=e.pow(r,t),u=e.pow(r,i);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,n=e.sqr(c);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===s)throw new Error("Cannot find square root");const r=ir<<BigInt(s-t-1),o=e.pow(a,r);s=t,a=e.sqr(o),c=e.mul(c,a),u=e.mul(u,o)}return u}}(e)}const br=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function yr(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),s=t.reduce((t,n,s)=>e.is0(n)?t:(r[s]=t,e.mul(t,n)),e.ONE),o=e.inv(s);return t.reduceRight((t,n,s)=>e.is0(n)?t:(r[s]=e.mul(t,r[s]),e.mul(t,n)),o),r}function xr(e,t){const n=(e.ORDER-ir)/ar,r=e.pow(t,n),s=e.eql(r,e.ONE),o=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function vr(e,t){void 0!==t&&Y(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Pr(e,t,n=!1,r={}){if(e<=or)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:s,nByteLength:o}=vr(e,t);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const a=Object.freeze({ORDER:e,isLE:n,BITS:s,BYTES:o,MASK:Qn(s),ZERO:or,ONE:ir,create:t=>hr(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return or<=t&&t<e},is0:e=>e===or,isOdd:e=>(e&ir)===ir,neg:t=>hr(-t,e),eql:(e,t)=>e===t,sqr:t=>hr(t*t,e),add:(t,n)=>hr(t+n,e),sub:(t,n)=>hr(t-n,e),mul:(t,n)=>hr(t*n,e),pow:(e,t)=>function(e,t,n){if(n<or)throw new Error("invalid exponent, negatives unsupported");if(n===or)return e.ONE;if(n===ir)return t;let r=e.ONE,s=t;for(;n>or;)n&ir&&(r=e.mul(r,s)),s=e.sqr(s),n>>=ir;return r}(a,e,t),div:(t,n)=>hr(t*pr(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>pr(t,e),sqrt:r.sqrt||(t=>(i||(i=wr(e)),i(a,t))),toBytes:e=>n?Xn(e,o):_n(e,o),fromBytes:e=>{if(e.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+e.length);return n?Dn(e):jn(e)},invertBatch:e=>yr(a,e),cmov:(e,t,n)=>n?t:e});return Object.freeze(a)}function Br(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Er(e){const t=Br(e);return t+Math.ceil(t/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ir=BigInt(0),Ar=BigInt(1);function Tr(e,t){const n=t.negate();return e?n:t}function kr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Fr(e,t){kr(e,t);const n=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:Qn(e),maxNumber:n,shiftBy:BigInt(e)}}function Cr(e,t,n){const{windowSize:r,mask:s,maxNumber:o,shiftBy:i}=n;let a=Number(e&s),c=e>>i;a>r&&(a-=o,c+=Ar);const u=t*r;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:u}}const Nr=new WeakMap,Sr=new WeakMap;function Or(e){return Sr.get(e)||1}function $r(e,t,n,r){!function(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}(n,e),function(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}(r,t);const s=n.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,a=function(e){let t;for(t=0;e>An;e>>=Tn,t+=1);return t}(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=Qn(c),l=new Array(Number(u)+1).fill(i);let d=i;for(let e=Math.floor((t.BITS-1)/c)*c;e>=0;e-=c){l.fill(i);for(let t=0;t<o;t++){const s=r[t],o=Number(s>>BigInt(e)&u);l[o]=l[o].add(n[t])}let t=i;for(let e=l.length-1,n=i;e>0;e--)n=n.add(l[e]),t=t.add(n);if(d=d.add(t),0!==e)for(let e=0;e<c;e++)d=d.double()}return d}function zr(e){return rr(e.Fp,br.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),rr(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...vr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Gr(e){void 0!==e.lowS&&Cn("lowS",e.lowS),void 0!==e.prehash&&Cn("prehash",e.prehash)}class Ur extends Error{constructor(e=""){super(e)}}const Rr={Err:Ur,_tlv:{encode:(e,t)=>{const{Err:n}=Rr;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const r=t.length/2,s=Nn(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?Nn(s.length/2|128):"";return Nn(e)+o+s+t},decode(e,t){const{Err:n}=Rr;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const s=t[r++];let o=0;if(!!(128&s)){const e=127&s;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const i=t.subarray(r,r+e);if(i.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===i[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of i)o=o<<8|e;if(r+=e,o<128)throw new n("tlv.decode(long): not minimal encoding")}else o=s;const i=t.subarray(r,r+o);if(i.length!==o)throw new n("tlv.decode: wrong value length");return{v:i,l:t.subarray(r+o)}}},_int:{encode(e){const{Err:t}=Rr;if(e<qr)throw new t("integer: negative integers are not allowed");let n=Nn(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Rr;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return jn(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Rr,s=Zn("signature",e),{v:o,l:i}=r.decode(48,s);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,o),{v:u,l:l}=r.decode(2,c);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(u)}},hexFromSig(e){const{_tlv:t,_int:n}=Rr,r=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,r)}};function Hr(e,t){return zn(_n(e,t))}const qr=BigInt(0),Lr=BigInt(1);BigInt(2);const Mr=BigInt(3),Vr=BigInt(4);function jr(e){const t=function(e){const t=zr(e);rr(t,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:n,Fp:r,a:s}=t;if(n){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...t})}(e),{Fp:n}=t,r=Pr(t.n,t.nBitLength),s=t.toBytes||((e,t,r)=>{const s=t.toAffine();return Kn(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),o=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function i(e){const{a:r,b:s}=t,o=n.sqr(e),i=n.mul(o,e);return n.add(n.add(i,n.mul(e,r)),s)}function a(e,t){const r=n.sqr(t),s=i(e);return n.eql(r,s)}if(!a(t.Gx,t.Gy))throw new Error("bad curve params: generator point");const c=n.mul(n.pow(t.a,Mr),Vr),u=n.mul(n.sqr(t.b),BigInt(27));if(n.is0(n.add(c,u)))throw new Error("bad curve params: a or b");function l(e){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:s,n:o}=t;if(n&&"bigint"!=typeof e){if(kn(e)&&(e=zn(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("invalid private key");e=e.padStart(2*r,"0")}let i;try{i="bigint"==typeof e?e:jn(Zn("private key",e,r))}catch(t){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof e)}return s&&(i=hr(i,o)),Jn("private key",i,Lr,o),i}function d(e){if(!(e instanceof p))throw new Error("ProjectivePoint expected")}const h=sr((e,t)=>{const{px:r,py:s,pz:o}=e;if(n.eql(o,n.ONE))return{x:r,y:s};const i=e.is0();null==t&&(t=i?n.ONE:n.inv(o));const a=n.mul(r,t),c=n.mul(s,t),u=n.mul(o,t);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),f=sr(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:r,y:s}=e.toAffine();if(!n.isValid(r)||!n.isValid(s))throw new Error("bad point: x or y not FE");if(!a(r,s))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(e,t,r){if(null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t)||n.is0(t))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");this.px=e,this.py=t,this.pz=r,Object.freeze(this)}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof p)throw new Error("projective point not allowed");const s=e=>n.eql(e,n.ZERO);return s(t)&&s(r)?p.ZERO:new p(t,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=yr(n,e.map(e=>e.pz));return e.map((e,n)=>e.toAffine(t[n])).map(p.fromAffine)}static fromHex(e){const t=p.fromAffine(o(Zn("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return p.BASE.multiply(l(e))}static msm(e,t){return $r(p,r,e,t)}_setWindowSize(e){w.setWindowSize(this,e)}assertValidity(){f(this)}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){d(e);const{px:t,py:r,pz:s}=this,{px:o,py:i,pz:a}=e,c=n.eql(n.mul(t,a),n.mul(o,s)),u=n.eql(n.mul(r,a),n.mul(i,s));return c&&u}negate(){return new p(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:r}=t,s=n.mul(r,Mr),{px:o,py:i,pz:a}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO,d=n.mul(o,o),h=n.mul(i,i),f=n.mul(a,a),m=n.mul(o,i);return m=n.add(m,m),l=n.mul(o,a),l=n.add(l,l),c=n.mul(e,l),u=n.mul(s,f),u=n.add(c,u),c=n.sub(h,u),u=n.add(h,u),u=n.mul(c,u),c=n.mul(m,c),l=n.mul(s,l),f=n.mul(e,f),m=n.sub(d,f),m=n.mul(e,m),m=n.add(m,l),l=n.add(d,d),d=n.add(l,d),d=n.add(d,f),d=n.mul(d,m),u=n.add(u,d),f=n.mul(i,a),f=n.add(f,f),d=n.mul(f,m),c=n.sub(c,d),l=n.mul(f,h),l=n.add(l,l),l=n.add(l,l),new p(c,u,l)}add(e){d(e);const{px:r,py:s,pz:o}=this,{px:i,py:a,pz:c}=e;let u=n.ZERO,l=n.ZERO,h=n.ZERO;const f=t.a,m=n.mul(t.b,Mr);let g=n.mul(r,i),w=n.mul(s,a),b=n.mul(o,c),y=n.add(r,s),x=n.add(i,a);y=n.mul(y,x),x=n.add(g,w),y=n.sub(y,x),x=n.add(r,o);let v=n.add(i,c);return x=n.mul(x,v),v=n.add(g,b),x=n.sub(x,v),v=n.add(s,o),u=n.add(a,c),v=n.mul(v,u),u=n.add(w,b),v=n.sub(v,u),h=n.mul(f,x),u=n.mul(m,b),h=n.add(u,h),u=n.sub(w,h),h=n.add(w,h),l=n.mul(u,h),w=n.add(g,g),w=n.add(w,g),b=n.mul(f,b),x=n.mul(m,x),w=n.add(w,b),b=n.sub(g,b),b=n.mul(f,b),x=n.add(x,b),g=n.mul(w,x),l=n.add(l,g),g=n.mul(v,x),u=n.mul(y,u),u=n.sub(u,g),g=n.mul(y,w),h=n.mul(v,h),h=n.add(h,g),new p(u,l,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(p.ZERO)}wNAF(e){return w.wNAFCached(this,e,p.normalizeZ)}multiplyUnsafe(e){const{endo:r,n:s}=t;Jn("scalar",e,qr,s);const o=p.ZERO;if(e===qr)return o;if(this.is0()||e===Lr)return this;if(!r||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,e,p.normalizeZ);let{k1neg:i,k1:a,k2neg:c,k2:u}=r.splitScalar(e),l=o,d=o,h=this;for(;a>qr||u>qr;)a&Lr&&(l=l.add(h)),u&Lr&&(d=d.add(h)),h=h.double(),a>>=Lr,u>>=Lr;return i&&(l=l.negate()),c&&(d=d.negate()),d=new p(n.mul(d.px,r.beta),d.py,d.pz),l.add(d)}multiply(e){const{endo:r,n:s}=t;let o,i;if(Jn("scalar",e,Lr,s),r){const{k1neg:t,k1:s,k2neg:a,k2:c}=r.splitScalar(e);let{p:u,f:l}=this.wNAF(s),{p:d,f:h}=this.wNAF(c);u=w.constTimeNegate(t,u),d=w.constTimeNegate(a,d),d=new p(n.mul(d.px,r.beta),d.py,d.pz),o=u.add(d),i=l.add(h)}else{const{p:t,f:n}=this.wNAF(e);o=t,i=n}return p.normalizeZ([o,i])[0]}multiplyAndAddUnsafe(e,t,n){const r=p.BASE,s=(e,t)=>t!==qr&&t!==Lr&&e.equals(r)?e.multiply(t):e.multiplyUnsafe(t),o=s(this,t).add(s(e,n));return o.is0()?void 0:o}toAffine(e){return h(this,e)}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===Lr)return!0;if(n)return n(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===Lr?this:n?n(p,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return Cn("isCompressed",e),this.assertValidity(),s(p,this,e)}toHex(e=!0){return Cn("isCompressed",e),zn(this.toRawBytes(e))}}p.BASE=new p(t.Gx,t.Gy,n.ONE),p.ZERO=new p(n.ZERO,n.ONE,n.ZERO);const{endo:m,nBitLength:g}=t,w=(b=p,y=m?Math.ceil(g/2):g,{constTimeNegate:Tr,hasPrecomputes:e=>1!==Or(e),unsafeLadder(e,t,n=b.ZERO){let r=e;for(;t>Ir;)t&Ar&&(n=n.add(r)),r=r.double(),t>>=Ar;return n},precomputeWindow(e,t){const{windows:n,windowSize:r}=Fr(t,y),s=[];let o=e,i=o;for(let e=0;e<n;e++){i=o,s.push(i);for(let e=1;e<r;e++)i=i.add(o),s.push(i);o=i.double()}return s},wNAF(e,t,n){let r=b.ZERO,s=b.BASE;const o=Fr(e,y);for(let e=0;e<o.windows;e++){const{nextN:i,offset:a,isZero:c,isNeg:u,isNegF:l,offsetF:d}=Cr(n,e,o);n=i,c?s=s.add(Tr(l,t[d])):r=r.add(Tr(u,t[a]))}return{p:r,f:s}},wNAFUnsafe(e,t,n,r=b.ZERO){const s=Fr(e,y);for(let e=0;e<s.windows&&n!==Ir;e++){const{nextN:o,offset:i,isZero:a,isNeg:c}=Cr(n,e,s);if(n=o,!a){const e=t[i];r=r.add(c?e.negate():e)}}return r},getPrecomputes(e,t,n){let r=Nr.get(t);return r||(r=this.precomputeWindow(t,e),1!==e&&Nr.set(t,n(r))),r},wNAFCached(e,t,n){const r=Or(e);return this.wNAF(r,this.getPrecomputes(r,e,n),t)},wNAFCachedUnsafe(e,t,n,r){const s=Or(e);return 1===s?this.unsafeLadder(e,t,r):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),t,r)},setWindowSize(e,t){kr(t,y),Sr.set(e,t),Nr.delete(e)}});var b,y;return{CURVE:t,ProjectivePoint:p,normPrivateKeyToScalar:l,weierstrassEquation:i,isWithinCurveOrder:function(e){return Yn(e,Lr,t.n)}}}function Dr(e){const t=function(e){const t=zr(e);return rr(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:r,nByteLength:s,nBitLength:o}=t,i=n.BYTES+1,a=2*n.BYTES+1;function c(e){return hr(e,r)}function u(e){return pr(e,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:f}=jr({...t,toBytes(e,t,r){const s=t.toAffine(),o=n.toBytes(s.x),i=Kn;return Cn("isCompressed",r),r?i(Uint8Array.from([t.hasEvenY()?2:3]),o):i(Uint8Array.from([4]),o,n.toBytes(s.y))},fromBytes(e){const t=e.length,r=e[0],s=e.subarray(1);if(t!==i||2!==r&&3!==r){if(t===a&&4===r){return{x:n.fromBytes(s.subarray(0,n.BYTES)),y:n.fromBytes(s.subarray(n.BYTES,2*n.BYTES))}}throw new Error("invalid Point, expected length of "+i+", or uncompressed "+a+", got "+t)}{const e=jn(s);if(!Yn(e,Lr,n.ORDER))throw new Error("Point is not on curve");const t=h(e);let o;try{o=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~r)!==((o&Lr)===Lr)&&(o=n.neg(o)),{x:e,y:o}}}});function p(e){return e>r>>Lr}const m=(e,t,n)=>jn(e.slice(t,n));class g{constructor(e,t,n){Jn("r",e,Lr,r),Jn("s",t,Lr,r),this.r=e,this.s=t,null!=n&&(this.recovery=n),Object.freeze(this)}static fromCompact(e){const t=s;return e=Zn("compactSignature",e,2*t),new g(m(e,0,t),m(e,t,2*t))}static fromDER(e){const{r:t,s:n}=Rr.toSig(Zn("DER",e));return new g(t,n)}assertValidity(){}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:r,s:s,recovery:o}=this,i=x(Zn("msgHash",e));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?r+t.n:r;if(a>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const d=1&o?"03":"02",h=l.fromHex(d+Hr(a,n.BYTES)),f=u(a),p=c(-i*f),m=c(s*f),g=l.BASE.multiplyAndAddUnsafe(h,p,m);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Vn(this.toDERHex())}toDERHex(){return Rr.hexFromSig(this)}toCompactRawBytes(){return Vn(this.toCompactHex())}toCompactHex(){const e=s;return Hr(this.r,e)+Hr(this.s,e)}}const w={isValidPrivateKey(e){try{return d(e),!0}catch(e){return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const e=Er(t.n);return function(e,t,n=!1){const r=e.length,s=Br(t),o=Er(t);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const i=hr(n?Dn(e):jn(e),t-ir)+ir;return n?Xn(i,s):_n(i,s)}(t.randomBytes(e),t.n)},precompute:(e=8,t=l.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function b(e){if("bigint"==typeof e)return!1;if(e instanceof l)return!0;const r=Zn("key",e).length,o=n.BYTES,i=o+1,a=2*o+1;return t.allowedPrivateKeyLengths||s===i?void 0:r===i||r===a}const y=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=jn(e),n=8*e.length-o;return n>0?t>>BigInt(n):t},x=t.bits2int_modN||function(e){return c(y(e))},v=Qn(o);function P(e){return Jn("num < 2^"+o,e,qr,v),_n(e,s)}function B(e,r,s=E){if(["recovered","canonical"].some(e=>e in s))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:i}=t;let{lowS:a,prehash:h,extraEntropy:m}=s;null==a&&(a=!0),e=Zn("msgHash",e),Gr(s),h&&(e=Zn("prehashed msgHash",o(e)));const w=x(e),b=d(r),v=[P(b),P(w)];if(null!=m&&!1!==m){const e=!0===m?i(n.BYTES):m;v.push(Zn("extraEntropy",e))}const B=Kn(...v),I=w;return{seed:B,k2sig:function(e){const t=y(e);if(!f(t))return;const n=u(t),r=l.BASE.multiply(t).toAffine(),s=c(r.x);if(s===qr)return;const o=c(n*c(I+s*b));if(o===qr)return;let i=(r.x===s?0:2)|Number(r.y&Lr),d=o;return a&&p(o)&&(d=function(e){return p(e)?c(-e):e}(o),i^=1),new g(s,d,i)}}}const E={lowS:t.lowS,prehash:!1},I={lowS:t.lowS,prehash:!1};return l.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return l.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(!0===b(e))throw new Error("first arg must be private key");if(!1===b(t))throw new Error("second arg must be public key");return l.fromHex(t).multiply(d(e)).toRawBytes(n)},sign:function(e,n,r=E){const{seed:s,k2sig:o}=B(e,n,r),i=t,a=function(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=er(e),s=er(e),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},a=(...e)=>n(s,r,...e),c=(e=er(0))=>{s=a(tr([0]),e),r=a(),0!==e.length&&(s=a(tr([1]),e),r=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){r=a();const t=r.slice();n.push(t),e+=r.length}return Kn(...n)};return(e,t)=>{let n;for(i(),c(e);!(n=t(u()));)c();return i(),n}}(i.hash.outputLen,i.nByteLength,i.hmac);return a(s,o)},verify:function(e,n,r,s=I){const o=e;n=Zn("msgHash",n),r=Zn("publicKey",r);const{lowS:i,prehash:a,format:d}=s;if(Gr(s),"strict"in s)throw new Error("options.strict was renamed to lowS");if(void 0!==d&&"compact"!==d&&"der"!==d)throw new Error("format must be compact or der");const h="string"==typeof o||kn(o),f=!h&&!d&&"object"==typeof o&&null!==o&&"bigint"==typeof o.r&&"bigint"==typeof o.s;if(!h&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,m;try{if(f&&(p=new g(o.r,o.s)),h){try{"compact"!==d&&(p=g.fromDER(o))}catch(e){if(!(e instanceof Rr.Err))throw e}p||"der"===d||(p=g.fromCompact(o))}m=l.fromHex(r)}catch(e){return!1}if(!p)return!1;if(i&&p.hasHighS())return!1;a&&(n=t.hash(n));const{r:w,s:b}=p,y=x(n),v=u(b),P=c(y*v),B=c(w*v),E=l.BASE.multiplyAndAddUnsafe(m,P,B)?.toAffine();return!!E&&c(E.x)===w},ProjectivePoint:l,Signature:g,utils:w}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _r(e){return{hash:e,hmac:(t,...n)=>In(e,t,function(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];J(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}(...n)),randomBytes:ue}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Xr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Kr=BigInt(0),Wr=BigInt(1),Yr=BigInt(2),Jr=(e,t)=>(e+t/Yr)/t;const Qr=Pr(Xr,void 0,void 0,{sqrt:function(e){const t=Xr,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,l=u*u*e%t,d=fr(l,n,t)*l%t,h=fr(d,n,t)*l%t,f=fr(h,Yr,t)*u%t,p=fr(f,s,t)*f%t,m=fr(p,o,t)*p%t,g=fr(m,a,t)*m%t,w=fr(g,c,t)*g%t,b=fr(w,a,t)*m%t,y=fr(b,n,t)*l%t,x=fr(y,i,t)*p%t,v=fr(x,r,t)*u%t,P=fr(v,Yr,t);if(!Qr.eql(Qr.sqr(P),e))throw new Error("Cannot find square root");return P}}),es=function(e,t){const n=t=>Dr({...e,..._r(t)});return{...n(t),create:n}}({a:Kr,b:BigInt(7),Fp:Qr,n:Zr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Zr,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Wr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,i=BigInt("0x100000000000000000000000000000000"),a=Jr(o*e,t),c=Jr(-r*e,t);let u=hr(e-a*n-c*s,t),l=hr(-a*r-c*o,t);const d=u>i,h=l>i;if(d&&(u=t-u),h&&(l=t-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:u,k2neg:h,k2:l}}}},Yt);var ts=Object.freeze({__proto__:null,secp256k1:es});const ns=new Map,rs=new Map;let ss=0;function os(e,t,n){const r=++ss,s=()=>ns.get(e)||[],o=()=>{const t=s();if(!t.some(e=>e.id===r))return;const n=rs.get(e);if(1===t.length&&n){const e=n();e instanceof Promise&&e.catch(()=>{})}(()=>{const t=s();ns.set(e,t.filter(e=>e.id!==r))})()},i=s();if(ns.set(e,[...i,{id:r,fns:t}]),i&&i.length>0)return o;const a={};for(const e in t)a[e]=(...t)=>{const n=s();if(0!==n.length)for(const r of n)r.fns[e]?.(...t)};const c=n(a);return"function"==typeof c&&rs.set(e,c),o}function is(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:r,onError:s,poll:o,pollingInterval:i=e.pollingInterval}){let a;return(void 0!==o?o:"webSocket"!==e.transport.type&&"ipc"!==e.transport.type&&("fallback"!==e.transport.type||"webSocket"!==e.transport.transports[0].config.type&&"ipc"!==e.transport.transports[0].config.type))?os(Le(["watchBlockNumber",e.uid,t,n,i]),{onBlockNumber:r,onError:s},r=>function(e,{emitOnBegin:t,initialWaitTime:n,interval:r}){let s=!0;const o=()=>s=!1;return(async()=>{let i;t&&(i=await e({unpoll:o}));const a=await(n?.(i))??r;await wn(a);const c=async()=>{s&&(await e({unpoll:o}),await wn(r),c())};c()})(),o}(async()=>{try{const t=await nt(e,gn,"getBlockNumber")({cacheTime:0});if(void 0!==a){if(t===a)return;if(t-a>1&&n)for(let e=a+1n;e<t;e++)r.onBlockNumber(e,a),a=e}(void 0===a||t>a)&&(r.onBlockNumber(t,a),a=t)}catch(e){r.onError?.(e)}},{emitOnBegin:t,interval:i})):os(Le(["watchBlockNumber",e.uid,t,n]),{onBlockNumber:r,onError:s},t=>{let n=!0,r=()=>n=!1;return(async()=>{try{const s=(()=>{if("fallback"===e.transport.type){const t=e.transport.transports.find(e=>"webSocket"===e.config.type||"ipc"===e.config.type);return t?t.value:e.transport}return e.transport})(),{unsubscribe:o}=await s.subscribe({params:["newHeads"],onData(e){if(!n)return;const r=$(e.result?.number);t.onBlockNumber(r,a),a=r},onError(e){t.onError?.(e)}});r=o,n||r()}catch(e){s?.(e)}})(),()=>r()})}async function as(e,t){const{checkReplacement:n=!0,confirmations:r=1,hash:s,onReplaced:o,retryCount:i=6,retryDelay:a=({count:e})=>200*(1<<e),timeout:c=18e4}=t,u=Le(["waitForTransactionReceipt",e.uid,s]),l=t.pollingInterval?t.pollingInterval:e.chain?.experimental_preconfirmationTime?e.chain.experimental_preconfirmationTime:e.pollingInterval;let d,h,f,p,m,g=!1;const{promise:w,resolve:b,reject:y}=function(){let e=()=>{},t=()=>{};return{promise:new Promise((n,r)=>{e=n,t=r}),resolve:e,reject:t}}(),x=c?setTimeout(()=>{m?.(),p?.(),y(new tt({hash:s}))},c):void 0;return p=os(u,{onReplaced:o,resolve:b,reject:y},async t=>{if(f=await nt(e,Bn,"getTransactionReceipt")({hash:s}).catch(()=>{}),f&&r<=1)return clearTimeout(x),t.resolve(f),void p?.();m=nt(e,is,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:l,async onBlockNumber(o){const c=e=>{clearTimeout(x),m?.(),e(),p?.()};let u=o;if(!g)try{if(f){if(r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;return void c(()=>t.resolve(f))}if(n&&!d&&(g=!0,await bn(async()=>{d=await nt(e,Pn,"getTransaction")({hash:s}),d.blockNumber&&(u=d.blockNumber)},{delay:a,retryCount:i}),g=!1),f=await nt(e,Bn,"getTransactionReceipt")({hash:s}),r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;c(()=>t.resolve(f))}catch(n){if(n instanceof Qe||n instanceof et){if(!d)return void(g=!1);try{h=d,g=!0;const n=await bn(()=>nt(e,Rt,"getBlock")({blockNumber:u,includeTransactions:!0}),{delay:a,retryCount:i,shouldRetry:({error:e})=>e instanceof $t});g=!1;const s=n.transactions.find(({from:e,nonce:t})=>e===h.from&&t===h.nonce);if(!s)return;if(f=await nt(e,Bn,"getTransactionReceipt")({hash:s.hash}),r>1&&(!f.blockNumber||u-f.blockNumber+1n<r))return;let o="replaced";s.to===h.to&&s.value===h.value&&s.input===h.input?o="repriced":s.from===s.to&&0n===s.value&&(o="cancelled"),c(()=>{t.onReplaced?.({reason:o,replacedTransaction:h,transaction:s,transactionReceipt:f}),t.resolve(f)})}catch(e){c(()=>t.reject(e))}}else c(()=>t.reject(n))}}})}),w}class cs extends I{constructor({docsPath:e}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join("\n"),{docsPath:e,docsSlug:"account",name:"AccountNotFoundError"})}}class us extends I{constructor({docsPath:e,metaMessages:t,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:e,metaMessages:t,name:"AccountTypeNotSupportedError"})}}async function ls(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const ds=new Te(128);async function hs(e,t){const{account:n=e.account,chain:r=e.chain,accessList:s,authorizationList:o,blobs:i,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:h,nonce:f,type:p,value:m,...g}=t;if(void 0===n)throw new cs({docsPath:"/docs/actions/wallet/sendTransaction"});const w=n?qe(n):null;try{Pt(t);const n=await(async()=>t.to?t.to:null!==t.to&&o&&o.length>0?await Ft({authorization:o[0]}).catch(()=>{throw new I("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if("json-rpc"===w?.type||null===w){let t;null!==r&&(t=await nt(e,an,"getChainId")({}),yn({currentChainId:t,chain:r}));const b=e.chain?.formatters?.transactionRequest?.format,y=(b||bt)({...gt(g,{format:b}),accessList:s,account:w,authorizationList:o,blobs:i,chainId:t,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:h,nonce:f,to:n,type:p,value:m},"sendTransaction"),x=ds.get(e.uid),v=x?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:v,params:[y]},{retryCount:0})}catch(t){if(!1===x)throw t;const n=t;if("InvalidInputRpcError"===n.name||"InvalidParamsRpcError"===n.name||"MethodNotFoundRpcError"===n.name||"MethodNotSupportedRpcError"===n.name)return await e.request({method:"wallet_sendTransaction",params:[y]},{retryCount:0}).then(t=>(ds.set(e.uid,!0),t)).catch(t=>{const r=t;if("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name)throw ds.set(e.uid,!1),n;throw r});throw n}}if("local"===w?.type){const t=await nt(e,ln,"prepareTransactionRequest")({account:w,accessList:s,authorizationList:o,blobs:i,chain:r,data:a,gas:c,gasPrice:u,maxFeePerBlobGas:l,maxFeePerGas:d,maxPriorityFeePerGas:h,nonce:f,nonceManager:w.nonceManager,parameters:[...cn,"sidecars"],type:p,value:m,...g,to:n}),b=r?.serializers?.transaction,y=await w.signTransaction(t,{serializer:b});return await nt(e,ls,"sendRawTransaction")({serializedTransaction:y})}if("smart"===w?.type)throw new us({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new us({docsPath:"/docs/actions/wallet/sendTransaction",type:w?.type})}catch(e){if(e instanceof us)throw e;throw function(e,{docsPath:t,...n}){const r=(()=>{const t=mt(e,n);return t instanceof pt?e:t})();return new Je(r,{docsPath:t,...n})}(e,{...t,account:w,chain:t.chain||void 0})}}
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const fs=2n**256n,ps=fs-0x1000003d1n,ms=fs-0x14551231950b75fc4402da1732fc9bebfn,gs={a:0n,b:7n},ws=e=>Is(Is(e*e)*e+gs.b),bs=(e="")=>{throw new Error(e)},ys=e=>"bigint"==typeof e,xs=e=>"string"==typeof e,vs=e=>ys(e)&&0n<e&&e<ps,Ps=e=>ys(e)&&0n<e&&e<ms,Bs=e=>new Uint8Array(e),Es=(e,t)=>((e,t)=>!(e instanceof Uint8Array)||"number"==typeof t&&t>0&&e.length!==t?bs("Uint8Array expected"):e)(xs(e)?Os(e):Bs(e),t),Is=(e,t=ps)=>{let n=e%t;return n>=0n?n:t+n},As=e=>e instanceof ks?e:bs("Point expected");let Ts;class ks{constructor(e,t,n){this.px=e,this.py=t,this.pz=n}static fromAffine(e){return new ks(e.x,e.y,1n)}static fromHex(e){let t;const n=(e=Es(e))[0],r=e.subarray(1),s=zs(r,0,32),o=e.length;if(33===o&&[2,3].includes(n)){vs(s)||bs("Point hex invalid: x not FE");let e=Rs(ws(s));!(1&~n)!==(1n==(1n&e))&&(e=Is(-e)),t=new ks(s,e,1n)}return 65===o&&4===n&&(t=new ks(s,zs(r,32,64),1n)),t?t.ok():bs("Point is not on curve")}static fromPrivateKey(e){return Fs.mul(Hs(e))}get x(){return this.aff().x}get y(){return this.aff().y}equals(e){const{px:t,py:n,pz:r}=this,{px:s,py:o,pz:i}=As(e),a=Is(t*i),c=Is(s*r),u=Is(n*i),l=Is(o*r);return a===c&&u===l}negate(){return new ks(this.px,Is(-this.py),this.pz)}double(){return this.add(this)}add(e){const{px:t,py:n,pz:r}=this,{px:s,py:o,pz:i}=As(e),{a:a,b:c}=gs;let u=0n,l=0n,d=0n;const h=Is(3n*c);let f=Is(t*s),p=Is(n*o),m=Is(r*i),g=Is(t+n),w=Is(s+o);g=Is(g*w),w=Is(f+p),g=Is(g-w),w=Is(t+r);let b=Is(s+i);return w=Is(w*b),b=Is(f+m),w=Is(w-b),b=Is(n+r),u=Is(o+i),b=Is(b*u),u=Is(p+m),b=Is(b-u),d=Is(a*w),u=Is(h*m),d=Is(u+d),u=Is(p-d),d=Is(p+d),l=Is(u*d),p=Is(f+f),p=Is(p+f),m=Is(a*m),w=Is(h*w),p=Is(p+m),m=Is(f-m),m=Is(a*m),w=Is(w+m),f=Is(p*w),l=Is(l+f),f=Is(b*w),u=Is(g*u),u=Is(u-f),f=Is(g*p),d=Is(b*d),d=Is(d+f),new ks(u,l,d)}mul(e,t=!0){if(!t&&0n===e)return Cs;if(Ps(e)||bs("invalid scalar"),this.equals(Fs))return qs(e).p;let n=Cs,r=Fs;for(let s=this;e>0n;s=s.double(),e>>=1n)1n&e?n=n.add(s):t&&(r=r.add(s));return n}mulAddQUns(e,t,n){return this.mul(t,!1).add(e.mul(n,!1)).ok()}toAffine(){const{px:e,py:t,pz:n}=this;if(this.equals(Cs))return{x:0n,y:0n};if(1n===n)return{x:e,y:t};const r=Us(n);return 1n!==Is(n*r)&&bs("invalid inverse"),{x:Is(e*r),y:Is(t*r)}}assertValidity(){const{x:e,y:t}=this.aff();return vs(e)&&vs(t)||bs("Point invalid: x or y"),Is(t*t)===ws(e)?this:bs("Point invalid: not on curve")}multiply(e){return this.mul(e)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(e=!0){const{x:t,y:n}=this.aff();return(e?0n==(1n&n)?"02":"03":"04")+Gs(t)+(e?"":Gs(n))}toRawBytes(e=!0){return Os(this.toHex(e))}}ks.BASE=new ks(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,1n),ks.ZERO=new ks(0n,1n,0n);const{BASE:Fs,ZERO:Cs}=ks,Ns=(e,t)=>e.toString(16).padStart(t,"0"),Ss=e=>Array.from(e).map(e=>Ns(e,2)).join(""),Os=e=>{const t=e.length;(!xs(e)||t%2)&&bs("hex invalid 1");const n=Bs(t/2);for(let t=0;t<n.length;t++){const r=2*t,s=e.slice(r,r+2),o=Number.parseInt(s,16);(Number.isNaN(o)||o<0)&&bs("hex invalid 2"),n[t]=o}return n},$s=e=>BigInt("0x"+(Ss(e)||"0")),zs=(e,t,n)=>$s(e.slice(t,n)),Gs=e=>Ss((e=>ys(e)&&e>=0n&&e<fs?Os(Ns(e,64)):bs("bigint expected"))(e)),Us=(e,t=ps)=>{(0n===e||t<=0n)&&bs("no inverse n="+e+" mod="+t);let n=Is(e,t),r=t,s=0n,o=1n;for(;0n!==n;){const e=r%n,t=s-o*(r/n);r=n,n=e,s=o,o=t}return 1n===r?Is(s,t):bs("no inverse")},Rs=e=>{let t=1n;for(let n=e,r=(ps+1n)/4n;r>0n;r>>=1n)1n&r&&(t=t*n%ps),n=n*n%ps;return Is(t*t)===e?t:bs("sqrt invalid")},Hs=e=>(ys(e)||(e=$s(Es(e,32))),Ps(e)?e:bs("private key out of range")),qs=e=>{const t=Ts||(Ts=(()=>{const e=[];let t=Fs,n=t;for(let r=0;r<33;r++){n=t,e.push(n);for(let r=1;r<128;r++)n=n.add(t),e.push(n);t=n.double()}return e})()),n=(e,t)=>{let n=t.negate();return e?n:t};let r=Cs,s=Fs;const o=BigInt(255),i=BigInt(8);for(let a=0;a<33;a++){const c=128*a;let u=Number(e&o);e>>=i,u>128&&(u-=256,e+=1n);const l=c,d=c+Math.abs(u)-1,h=a%2!=0,f=u<0;0===u?s=s.add(n(h,t[l])):r=r.add(n(f,t[d]))}return{p:r,f:s}};function Ls(n,r){const s=ks.fromHex(e.strip0x(n)),o=new Uint8Array(s.toRawBytes(!0)),i=t.publicKeyBytesToAddress(o);return e.formatBech32(r,i)}function Ms(e){return"string"==typeof e?{evmAccount:qe(e)}:e}function Vs(t,n){let s;s="string"==typeof t?e.hexToBuffer(t):t;return e.getManagerForVM("P"===n?"PVM":"X"===n?"AVM":"EVM").unpack(s,r)}async function js(e,t){const n=n=>"P"===t.chainAlias?async function(e,t){return e.request({method:"platform.getUTXOs",params:t})}(e.pChainClient,n):"X"===t.chainAlias?async function(e,t){return e.request({method:"avm.getUTXOs",params:t})}(e.xChainClient,n):async function(e,t){return e.request({method:"avax.getUTXOs",params:t})}(e.cChainClient,n),r=[];let s,o=!1;do{const e=await n({addresses:[t.address],...t.sourceChain?{sourceChain:t.sourceChain}:{},...void 0===s?{}:{startIndex:s}});if(r.push(...e.utxos.map(e=>Vs(e,t.chainAlias))),Number(e.numFetched)>=1024?(o=!0,s={address:e.endIndex.address,utxo:e.endIndex.utxo}):o=!1,r.length>=5e3)break}while(o);return r}const Ds="P",_s="C";async function Xs(e){const t=await e.request({method:"platform.getFeeState",params:{}});return{...t,capacity:BigInt(t.capacity),excess:BigInt(t.excess),price:BigInt(t.price)}}async function Zs(e,t,n,r){const s=Ms(t)?.xpAccount||e.xpAccount,o=Ms(t)?.evmAccount||e.account;if(!s||!o){const{xp:t,evm:s}=await y(e);return`${n}-${Ls(n===_s?s:t,r)}`}if(n===_s&&!o.publicKey)throw new Error("EVM public key not found for evm account");return`${n}-${Ls(n===_s?o.publicKey:s.publicKey,r)}`}async function Ks(e,t){let n=t?.getEVMAddress()||e.account?.address;if(!n){const t=await async function(e){return"local"===e.account?.type?[e.account.address]:(await e.request({method:"eth_accounts"},{dedupe:!0})).map(e=>Se(e))}(e);if(0===t.length)throw new Error("No EVM address found from wallet");if(t.length>1)throw new Error("Multiple EVM addresses found from wallet, pass the from address");n=t[0]}return n}function Ws(t){return t.includes("-")?e.bech32ToBytes(t):e.bech32ToBytes(`P-${t}`)}function Ys(e){return e/BigInt(1e9)}function Js(e,t){if(1!==t&&5!==t)throw new Error(`Invalid network ID: ${t}`);switch(e){case"X":return 1===t?"2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM":"2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm";case _s:return 1===t?"2q9e4r6Mu3U68nU1fYjgbR6JvwrRx36CohpAX5UQxse55x1Q5":"yH8D7ThNJkxmtkuv2jgBa4P1Rn3Qpr4pPr7QYNfcdoS6k6HWp";case Ds:return"11111111111111111111111111111111LpoYY";default:throw new Error(`Invalid chain alias: ${e}`)}}async function Qs(t,n){const{txParams:r,sourceChain:s,chainAlias:l,subnetId:d,l1ValidationId:h,account:f,context:p}=n,m=await Zs(t,f,l||Ds,p.hrp),g=new Set(r.fromAddresses||[m]);let w,b;if(d){const n=await async function(e,t){return e.request({method:"platform.getTx",params:t})}(t.pChainClient,{txID:d,encoding:"hex"}),r=e.strip0x(n.tx),s=e.getManagerForVM("X"===l?"AVM":"C"===l?"EVM":"PVM").unpack(e.hexToBuffer(r),i.SignedTx);a.isCreateSubnetTx(s.unsignedTx)&&(w=new c(new u(s.unsignedTx.getSubnetOwners().threshold.value()),s.unsignedTx.getSubnetOwners().addrs),s.unsignedTx.getSubnetOwners().addrs.forEach(e=>{g.add(`${Ds}-${e.toString(p.hrp)}`)}))}if(h){const e=await async function(e,t){const n=await e.request({method:"platform.getL1Validator",params:t});return{...n,startTime:BigInt(n.startTime),weight:BigInt(n.weight),...n.minNonce&&{minNonce:BigInt(n.minNonce)},...n.balance&&{balance:BigInt(n.balance)},...n.height&&{height:BigInt(n.height)}}}(t.pChainClient,{validationID:h});b=new c(new u(Number(e.deactivationOwner.threshold)),e.deactivationOwner.addresses.map(o.fromString)),e.deactivationOwner.addresses.forEach(e=>{const t=e.startsWith("P-")?e:`${Ds}-${e}`;g.add(t)})}const y=Array.from(g),x=r.utxos||(await Promise.all(y.map(e=>js(t,{address:e,chainAlias:l||Ds,...s?{sourceChain:s}:{}})))).flat(),v={feeState:await Xs(t.pChainClient),fromAddressesBytes:y.map(Ws),utxos:x,memo:r.memo?new Uint8Array(Buffer.from(r.memo)):new Uint8Array};return r.changeAddresses&&(v.changeAddressesBytes=r.changeAddresses.map(Ws)),r.minIssuanceTime&&(v.minIssuanceTime=r.minIssuanceTime),{commonTxParams:v,subnetOwners:w,disableOwners:b}}function eo(t,n){return l.fromNative(t.assetId??n.avaxAssetID,t.amount,t.addresses.map(e.bech32ToBytes),BigInt(t.locktime??0),t.threshold??1)}function to(e){return e._type===s.AvmExportTx||e._type===s.AvmImportTx||e._type===s.EvmExportTx||e._type===s.EvmImportTx||e._type===s.PvmImportTx||e._type===s.PvmExportTx}function no(e,t){if(e)return e.map(e=>function(e,t){if(!e)return;return e.startsWith(t)?e:`${t}-${1===e.split("-").length?e:e.split("-")[1]}`}(e,t)).filter(e=>void 0!==e)}async function ro(e,t){const n=!!t.account||!!e.account,r=t.from||await Ks(e,t.account),[s,o,i]=await Promise.all([await dn(e,{to:t.to,value:t.amount,account:r}),await Ht(e),await hn(e,{address:r})]),a=s*o;if(i<a||i<t.amount)throw new Error(`Insufficient balance: ${a} AVAX (in wei) is required, but only ${i} AVAX (in wei) is available`);let c;if(n){const n=await ln(e,{to:t.to,value:t.amount,account:r}),s=t.account?.evmAccount||e.account,o=await async function(e,t){const{account:n=e.account,chain:r=e.chain,...s}=t;if(!n)throw new cs({docsPath:"/docs/actions/wallet/signTransaction"});const o=qe(n);Pt({account:o,...t});const i=await nt(e,an,"getChainId")({});null!==r&&yn({currentChainId:i,chain:r});const a=r?.formatters||e.chain?.formatters,c=a?.transactionRequest?.format||bt;return o.signTransaction?o.signTransaction({...s,chainId:i},{serializer:e.chain?.serializers?.transaction}):await e.request({method:"eth_signTransaction",params:[{...c({...s,account:o},"signTransaction"),chainId:H(i),from:o.address}]},{retryCount:0})}(e,{...n,account:s});c=await ls(e,{serializedTransaction:o})}else c=await hs(e,{to:t.to,value:t.amount,account:r});return await as(e,{hash:c}),{txHashes:[{txHash:c,chainAlias:"C"}]}}async function so(e){return e.request({method:"eth_baseFee",params:[]})}async function oo(e,t){return e.request({method:"info.getBlockchainID",params:t})}g("event SendWarpMessage(address indexed sourceAddress, bytes32 indexed unsignedMessageID, bytes message)"),new d(new Uint8Array(32)),new d(new Uint8Array(32));const io=1,ao=2,co=3,uo=4,lo=5,ho=10,fo=12345,po={[io]:"avax",[ao]:"cascade",[co]:"denali",[uo]:"everest",[lo]:"fuji",[ho]:"testing",[fo]:"local"},mo=e=>po[e]??"custom",go=async(e,t="AVAX")=>{const{assetID:n}=await async function(e,t){return e.request({method:"avm.getAssetDescription",params:t})}(e.xChainClient,{assetID:t}),{txFee:r,createAssetTxFee:s}=await async function(e){return e.request({method:"avm.getTxFee",params:{}})}(e.xChainClient),{blockchainID:o}=await oo(e.infoClient,{alias:"X"}),{blockchainID:i}=await oo(e.infoClient,{alias:"P"}),{blockchainID:a}=await oo(e.infoClient,{alias:"C"}),{networkID:c}=await async function(e){return e.request({method:"info.getNetworkID",params:{}})}(e.infoClient),u=Number(c),l=await async function(e){const t=await e.request({method:"platform.getFeeConfig",params:{}});return{...t,maxCapacity:BigInt(t.maxCapacity),maxPerSecond:BigInt(t.maxPerSecond),minPrice:BigInt(t.minPrice),targetPerSecond:BigInt(t.targetPerSecond),excessConversionConstant:BigInt(t.excessConversionConstant)}}(e.pChainClient);return Object.freeze({xBlockchainID:o,pBlockchainID:i,cBlockchainID:a,avaxAssetID:n,baseTxFee:BigInt(r),createAssetTxFee:BigInt(s),networkID:u,hrp:mo(u),platformFeeConfig:l})};function wo(t,n,r,s,o,i=0n){const a=function(t,n,r,s,o,i=0n,a){const c=h.newImportTx(t,n,r,s,o,i,a);return i*e.costCorethTx(c)}(t,n,r,s,o,i);let c=Ys(a);return 0n===c&&(c=1n),h.newImportTx(t,n,r,s,o,c)}async function bo(t,n){const r=n.context||await go(t),[s,o]=await Promise.all([Lt(t,{address:`0x${e.strip0x(n.fromAddress)}`}),so(t)]),i=n.exportedOutput.addresses.map(e=>Ws(e)),a=function(e,t,n,r,s,o,i){let a=Ys(h.estimateExportCost(e,t,n,r,s,o,i));return 0n===a&&(a=1n),h.newExportTx(e,n,r,s,o,a,i)}(r,BigInt(o),n.exportedOutput.amount,Js(n.destinationChain,r.networkID),e.hexToBuffer(n.fromAddress),i,BigInt(s));return{tx:a,exportTx:a.getTx(),chainAlias:"C"}}function yo(e,t){return`${e}-${t}`}async function xo(r,s){const{tx:a,signedTxHex:c,chainAlias:u,account:l,utxoIds:d,subnetAuth:h,subnetOwners:f,disableOwners:g,disableAuth:w}=s,b=a||c;if(!b)throw new Error("Either tx or signedTxHex must be provided");const y=Ms(l),x=y?.xpAccount||r.xpAccount;let v,P;if(r.chain?.testnet)v=r.chain?.testnet,P=v?5:1;else{const e=s.context||await go(r);v=5===e.networkID,P=e.networkID}if(x){const s=Ls(x.publicKey,v?"fuji":"avax");if("string"==typeof b){let[t,o]=function(t,r){const s=e.strip0x(t),o=e.getManagerForVM("P"===r?"PVM":"X"===r?"AVM":"EVM"),i=o.unpackTransaction(Buffer.from(s,"hex")),a=e.bufferToHex(i.toBytes(o.getDefaultCodec())),c=s.slice(0,12),u=s.replace(c+e.strip0x(a),""),l=Buffer.from(e.strip0x(u).slice(8),"hex"),d=[];let h=new Uint8Array(l);for(;h.length>=65;){const[e,t]=n.fromBytes(h.slice(4),o.getDefaultCodec());d.push(e),h=t.buffer instanceof ArrayBuffer?new Uint8Array(t.buffer,t.byteOffset,t.length):new Uint8Array(t)}return[i,d]}(b,u);const a=t.getSigIndices();0===o.length&&(o=a.map(e=>{const t=e.map(e=>new p(new Uint8Array(Array(65).fill(0))));return new n(t)}));const c=e.hexToBuffer(await x.signTransaction(new m(t,[],new e.AddressMaps,o).toBytes())),l=t.baseTx.inputs.map(e=>e.utxoID),d=await js(r,{address:yo(u,s),chainAlias:u,...to(t)&&{sourceChain:Js(u,P)}});if(0===d.length)throw new Error("No utxos found for the account address");const y=[];if(l.forEach((e,t)=>{const n=d.find(t=>t.utxoId.ID()===e.ID()&&t.utxoId.outputIdx.toJSON()===e.outputIdx.toJSON());n&&y.push([t,n.getOutputOwners().addrs.findIndex(e=>e.toString(v?"fuji":"avax")===s)])}),y.forEach(e=>{const t=e[0],n=e[1];o[t]?.setSignature(n,c)}),f&&h||g&&w){const e=(h??w)||[],t=(f??g).addresses.filter((t,n)=>e.includes(n)),n=o.length-1,r=t.findIndex(e=>e.toString(v?"fuji":"avax")===s);-1!==r&&(y.push([n,r]),o[n]?.setSignature(r,c))}return{signedTxHex:e.bufferToHex(e.addChecksum(new i.SignedTx(t,o).toBytes())),signatures:y.map(t=>({signature:e.bufferToHex(c),sigIndices:t})),subnetAuth:h,subnetOwners:f,disableOwners:g,disableAuth:w,chainAlias:u}}{const n=b,r=e.hexToBuffer(await x.signTransaction(b.toBytes()));return n.addSignature(r),(f&&h||g&&w)&&async function(n,r,s,i,a){const c=r.addresses.filter((e,t)=>s.includes(t)),u=n.getCredentials().length-1,l=new o(t.publicKeyBytesToAddress(e.hexToBuffer(a))),d=c.findIndex(e=>e.value()===l.value());-1!==d&&n.addSignatureAt(i,u,d)}(n,f??g,(h??w)||[],r,x.publicKey),{signedTxHex:e.bufferToHex(e.addChecksum(n.getSignedTx().toBytes())),signatures:n.getSigIndicesForPubKey(e.hexToBuffer(x.publicKey))?.map(t=>({signature:e.bufferToHex(r),sigIndices:t})),subnetAuth:h,subnetOwners:f,disableOwners:g,disableAuth:w,chainAlias:u}}}const B=await r.request({method:"avalanche_signTransaction",params:{transactionHex:"string"==typeof b?b:e.bufferToHex(b.toBytes()),chainAlias:u,utxos:d}});return{signedTxHex:B.signedTransactionHex,signatures:B.signatures,subnetAuth:h,subnetOwners:f,disableOwners:g,disableAuth:w,chainAlias:u}}async function vo(t,n){const{tx:r,chainAlias:s,account:o,utxoIds:i,subnetAuth:a,subnetOwners:c,disableOwners:u,disableAuth:l,...d}=n,h=Ms(o);if(h?.xpAccount||t.xpAccount){let e=await xo(t,{tx:r,chainAlias:s,subnetOwners:c,subnetAuth:a,disableOwners:u,disableAuth:l});const n=e=>{switch(s){case"P":return async function(e,t){return e.request({method:"platform.issueTx",params:t})}(t.pChainClient,e);case"C":return async function(e,t){return e.request({method:"avax.issueTx",params:t})}(t.cChainClient,e);case"X":return async function(e,t){return e.request({method:"avm.issueTx",params:t})}(t.xChainClient,e)}};return{txHash:(await n({tx:e.signedTxHex,encoding:"hex"})).txID,chainAlias:s}}return{txHash:await t.request({method:"avalanche_sendTransaction",params:{externalIndices:d.externalIndices,internalIndices:d.internalIndices,feeTolerance:d.feeTolerance,transactionHex:"string"==typeof r?r:e.bufferToHex(r.toBytes()),chainAlias:s,utxos:i}}),chainAlias:s}}async function Po(e,t){let{txHash:n,chainAlias:r,sleepTime:s=300,maxRetries:o=10}=t;const i=t=>"P"===r?async function(e,t){return e.request({method:"platform.getTxStatus",params:t})}(e.pChainClient,t):"X"===r?async function(e,t){return e.request({method:"avm.getTxStatus",params:t})}(e.xChainClient,t):async function(e,t){return e.request({method:"avax.getAtomicTxStatus",params:t})}(e.cChainClient,t);for(;o>0;){const e=await i({txID:n});if(["Accepted","Committed"].includes(e.status))return;if(["Rejected","Dropped"].includes(e.status))throw new Error(`Transaction ${n} rejected with status ${e.status}`);o--,await new Promise(e=>setTimeout(e,s))}throw new Error("Transaction status not found")}async function Bo(t,n){const r=n.context||await go(t),s=n.from||await Ks(t,n.account),o=await Zs(t,n.account,Ds,5===r.networkID?"fuji":"avax");if(!n.to.startsWith("P-"))throw new Error("Invalid P chain address, it should start with P-");const[i,a,c,u,l]=await Promise.all([bo(t,{destinationChain:"P",fromAddress:s,exportedOutput:{addresses:[o],amount:Ys(n.amount)},context:r}),Xs(t.pChainClient),so(t),Lt(t,{address:`0x${e.strip0x(s)}`}),await hn(t,{address:`0x${e.strip0x(s)}`})]);if(l<n.amount)throw new Error(`Insufficient balance: ${n.amount} ${n.token} (in wei) is required, but only ${l} ${n.token} (in wei) is available`);const d=h.estimateExportCost(r,BigInt(c),Ys(n.amount),Js("P",r.networkID),e.hexToBuffer(s),[Ws(n.to)],BigInt(u));if(d>Ys(n.amount))throw new Error(`Transfer amount is too low: ${d} nAVAX Fee is required for C chain export txn, but only ${Ys(n.amount)} nAVAX is being transferred, try sending a higher amount.`);const p=await vo(t,i);await Po(t,p);const m=await async function(t,n){const r=n.context||await go(t),{commonTxParams:s}=await Qs(t,{txParams:n,context:r,sourceChain:Js(n.sourceChain,r.networkID)}),o=f.newImportTx({...s,sourceChainId:Js(n.sourceChain,r.networkID),toAddressesBytes:n.importedOutput.addresses.map(e.bech32ToBytes),locktime:BigInt(n.importedOutput.locktime??0),threshold:n.importedOutput.threshold??1},r);return{tx:o,importTx:o.getTx(),chainAlias:Ds}}(t,{sourceChain:"C",importedOutput:{addresses:[n.to]},context:r}),g=f.calculateFee(m.tx.getTx(),r.platformFeeConfig.weights,a.price);if(g+d>Ys(n.amount))throw new Error(`Transfer amount is too low: ${g} nAVAX Fee is required for P chain import txn, \n      try sending a higher amount.\n      C chain export txn hash: ${p.txHash}`);const w=await vo(t,m);return await Po(t,w),{txHashes:[{txHash:p.txHash,chainAlias:"C"},{txHash:w.txHash,chainAlias:"P"}]}}async function Eo(e,t){const n=await e.request({method:"platform.getBalance",params:t});return{...n,balance:BigInt(n.balance),unlocked:BigInt(n.unlocked),lockedNotStakeable:BigInt(n.lockedNotStakeable),lockedStakeable:BigInt(n.lockedStakeable)}}async function Io(e,t){const n=t.context||await go(e),{commonTxParams:r}=await Qs(e,{txParams:t,context:n}),s=t.exportedOutputs.map(e=>eo(e,n)),o=f.newExportTx({...r,outputs:s,destinationChainId:Js(t.destinationChain,n.networkID)},n);return{tx:o,exportTx:o.getTx(),chainAlias:Ds}}async function Ao(t,n){const r=n.context||await go(t),s=5===r.networkID;let o=n.from;o||(o=await Zs(t,n.account,_s,s?"fuji":"avax"));let i=n.from;if(i||(i=await Zs(t,n.account,Ds,s?"fuji":"avax")),!w(n.to))throw new Error("Invalid `to` address");const[a,c,u,l]=await Promise.all([await Io(t,{exportedOutputs:[{addresses:[o],amount:Ys(n.amount)}],destinationChain:"C",context:r}),Xs(t.pChainClient),so(t),(await Eo(t.pChainClient,{addresses:[i]})).balance]);if(l<Ys(n.amount))throw new Error(`Insufficient balance: ${Ys(n.amount)} nAVAX is required, but only ${l} nAVAX is available`);const d=f.calculateFee(a.tx.getTx(),r.platformFeeConfig.weights,c.price);if(d>Ys(n.amount))throw new Error(`Transfer amount is too low: ${d} nAVAX Fee is required for P chain export txn, but only ${Ys(n.amount)} nAVAX is being transferred, try sending a higher amount`);const h=await vo(t,a);await Po(t,h);const p=await async function(t,n){const{account:r}=n,s=n.context||await go(t),o=await so(t),i=no(n.fromAddresses,_s)||[];if(0===i.length){const e=Ms(r),n=await Zs(t,e,_s,s.hrp);i.push(n)}const a=i.map(e=>Ws(e));let c=n.utxos||[];c.length||(c=(await Promise.all(i.map(async e=>await js(t,{address:e,chainAlias:"C",sourceChain:Js(n.sourceChain,s.networkID)})))).flat());const u=wo(s,e.hexToBuffer(n.toAddress),a,c,Js(n.sourceChain,s.networkID),BigInt(o));return{tx:u,importTx:u.getTx(),chainAlias:_s}}(t,{fromAddresses:[o],sourceChain:"P",toAddress:n.to,context:r}),m=BigInt(u)*BigInt(e.costCorethTx(p.tx));if(d+m>Ys(n.amount))throw new Error(`Transfer amount is too low: ${m} nAVAX Fee is required for C chain import txn,\n      try sending a higher amount.\n      P chain export txn hash: ${h.txHash}`);const g=await vo(t,p);return await Po(t,g),{txHashes:[{txHash:h.txHash,chainAlias:"P"},{txHash:g.txHash,chainAlias:"C"}]}}async function To(e,t){const n=t.context||await go(e),{commonTxParams:r}=await Qs(e,{txParams:t,context:n}),s=t.outputs?t.outputs.map(e=>eo(e,n)):[],o=f.newBaseTx({...r,outputs:s},n);return{tx:o,baseTx:o.getTx(),chainAlias:Ds}}async function ko(e,t){const{sourceChain:n="C",destinationChain:r="C",token:s="AVAX"}=t;if("AVAX"!==s)throw new Error(`Invalid token: ${s}, only AVAX is supported.`);switch(n){case"C":switch(r){case"C":return ro(e,t);case"P":return Bo(e,t);default:throw new Error(`Invalid destination chain: ${r}`)}case"P":switch(r){case"P":return async function(e,t){const n=t.context||await go(e),r=5===n.networkID,s=await Zs(e,t.account,"P",r?"fuji":"avax");if(!t.to.startsWith("P-"))throw new Error("Invalid P chain address, it should start with P-");const[o,i,a]=await Promise.all([To(e,{fromAddresses:[s],outputs:[{addresses:[t.to],amount:Ys(t.amount)}],context:n}),Xs(e.pChainClient),(await Eo(e.pChainClient,{addresses:[s]})).balance]),c=f.calculateFee(o.tx.getTx(),n.platformFeeConfig.weights,i.price);if(a<Ys(t.amount))throw new Error(`Insufficient balance: ${Ys(t.amount)} nAVAX is required, but only ${a} nAVAX is available`);if(c>Ys(t.amount))throw new Error(`Transfer amount is too low: ${c} nAVAX Fee is required, but only ${Ys(t.amount)} nAVAX is being transferred`);const u=await vo(e,o);return await Po(e,u),{txHashes:[{txHash:u.txHash,chainAlias:"P"}]}}(e,t);case"C":return Ao(e,t);default:throw new Error(`Invalid destination chain: ${r}`)}default:throw new Error(`Invalid source chain: ${n}`)}}async function Fo(e,t){const{message:n,account:r,accountIndex:s}=t,o=Ms(r),i=o?.xpAccount||e.xpAccount;if(i){return{signature:await i.signMessage(n)}}return e.request({method:"avalanche_signMessage",params:{message:n,accountIndex:s}})}export{no as addOrModifyXPAddressAlias,y as getAccountPubKey,ko as send,vo as sendXPTransaction,Fo as signXPMessage,xo as signXPTransaction,Po as waitForTxn};
