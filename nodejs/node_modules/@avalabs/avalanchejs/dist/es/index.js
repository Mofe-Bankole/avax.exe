import{bech32 as t,base58 as e,bytesToString as r}from"@scure/base";import{concatBytes as n,randomBytes as s,hexToBytes as a,bytesToHex as i}from"@noble/hashes/utils";import{sha256 as o}from"@noble/hashes/sha256";import{ripemd160 as u}from"@noble/hashes/ripemd160";import c from"util";function d(t,e,r,n){var s,a=arguments.length,i=a<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,n);else for(var o=t.length-1;o>=0;o--)(s=t[o])&&(i=(a<3?s(i):a>3?s(e,r,i):s(e,r))||i);return a>3&&i&&Object.defineProperty(e,r,i),i}function f(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}const l=Symbol.for("nodejs.util.inspect.custom");function h(t){const e=t.split("-");if(e.length<2)throw new Error(`Invalid address: ${t}`);const r=e[0],n=e[1],[s,a]=m(n);return[r,s,a]}function p(t){return h(t)[2]}function m(e){const{prefix:r,words:n}=t.decode(e);return[r,t.fromWords(n)]}function g(e,r){const n=t.toWords(r);return t.encode(e,n)}function b(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function y(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Expected Uint8Array");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function w(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const x=BigInt(2**32-1),I=BigInt(32);function B(t,e=!1){return e?{h:Number(t&x),l:Number(t>>I&x)}:{h:0|Number(t>>I&x),l:0|Number(t&x)}}function T(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:a,l:i}=B(t[s],e);[r[s],n[s]]=[a,i]}return[r,n]}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function v(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);var e;return t}class O{clone(){return this._cloneInto()}}const[S,A,E]=[[],[],[]],k=BigInt(0),R=BigInt(1),D=BigInt(2),P=BigInt(7),_=BigInt(256),C=BigInt(113);for(let t=0,e=R,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],S.push(2*(5*n+r)),A.push((t+1)*(t+2)/2%64);let s=k;for(let t=0;t<7;t++)e=(e<<R^(e>>P)*C)%_,e&D&&(s^=R<<(R<<BigInt(t))-R);E.push(s)}const[N,V]=T(E,!0),U=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),L=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class M extends O{constructor(t,e,r,n=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=n,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,b(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var a;this.state=new Uint8Array(200),this.state32=(a=this.state,new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4)))}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,s=(e+2)%10,a=r[s],i=r[s+1],o=U(a,i,1)^r[n],u=L(a,i,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=o,t[e+r+1]^=u}let e=t[2],s=t[3];for(let r=0;r<24;r++){const n=A[r],a=U(e,s,n),i=L(e,s,n),o=S[r];e=t[o],s=t[o+1],t[o]=a,t[o+1]=i}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=N[n],t[1]^=V[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){w(this);const{blockLen:e,state:r}=this,n=(t=v(t)).length;for(let s=0;s<n;){const a=Math.min(e-this.pos,n-s);for(let e=0;e<a;e++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,128&e&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){w(this,!1),y(t),this.finish();const e=this.state,{blockLen:r}=this;for(let n=0,s=t.length;n<s;){this.posOut>=r&&this.keccak();const a=Math.min(r-this.posOut,s-n);t.set(e.subarray(this.posOut,this.posOut+a),n),this.posOut+=a,n+=a}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return b(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){y(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:n,rounds:s,enableXOF:a}=this;return t||(t=new M(e,r,n,a,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=n,t.enableXOF=a,t.destroyed=this.destroyed,t}}const F=((t,e,r)=>function(t){const e=e=>t().update(v(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}((()=>new M(e,t,r))))(1,136,32),q=BigInt(0),X=BigInt(1),j=BigInt(2);function H(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const K=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function W(t){if(!H(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=K[t[r]];return e}function G(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function Z(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const $=48,z=57,Y=65,J=70,Q=97,tt=102;function et(t){return t>=$&&t<=z?t-$:t>=Y&&t<=J?t-(Y-10):t>=Q&&t<=tt?t-(Q-10):void 0}function rt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,s=0;e<r;e++,s+=2){const r=et(t.charCodeAt(s)),a=et(t.charCodeAt(s+1));if(void 0===r||void 0===a){const e=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+s)}n[e]=16*r+a}return n}function nt(t){return Z(W(t))}function st(t){if(!H(t))throw new Error("Uint8Array expected");return Z(W(Uint8Array.from(t).reverse()))}function at(t,e){return rt(t.toString(16).padStart(2*e,"0"))}function it(t,e){return at(t,e).reverse()}function ot(t,e,r){let n;if("string"==typeof e)try{n=rt(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!H(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const s=n.length;if("number"==typeof r&&s!==r)throw new Error(`${t} expected ${r} bytes, got ${s}`);return n}function ut(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];if(!H(n))throw new Error("Uint8Array expected");e+=n.length}let r=new Uint8Array(e),n=0;for(let e=0;e<t.length;e++){const s=t[e];r.set(s,n),n+=s.length}return r}function ct(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function dt(t){let e;for(e=0;t>q;t>>=X,e+=1);return e}function ft(t,e){return t>>BigInt(e)&X}const lt=t=>(j<<BigInt(t-1))-X,ht=t=>new Uint8Array(t),pt=t=>Uint8Array.from(t);function mt(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=ht(t),s=ht(t),a=0;const i=()=>{n.fill(1),s.fill(0),a=0},o=(...t)=>r(s,n,...t),u=(t=ht())=>{s=o(pt([0]),t),n=o(),0!==t.length&&(s=o(pt([1]),t),n=o())},c=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=o();const e=n.slice();r.push(e),t+=n.length}return ut(...r)};return(t,e)=>{let r;for(i(),u(t);!(r=e(c()));)u();return i(),r}}const gt={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||H(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function bt(t,e,r={}){const n=(e,r,n)=>{const s=gt[r];if("function"!=typeof s)throw new Error(`Invalid validator "${r}", expected function`);const a=t[e];if(!(n&&void 0===a||s(a,t)))throw new Error(`Invalid param ${String(e)}=${a} (${typeof a}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}var yt=Object.freeze({__proto__:null,bitGet:ft,bitLen:dt,bitMask:lt,bitSet:(t,e,r)=>t|(r?X:q)<<BigInt(e),bytesToHex:W,bytesToNumberBE:nt,bytesToNumberLE:st,concatBytes:ut,createHmacDrbg:mt,ensureBytes:ot,equalBytes:function(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return 0===r},hexToBytes:rt,hexToNumber:Z,isBytes:H,numberToBytesBE:at,numberToBytesLE:it,numberToHexUnpadded:G,numberToVarBytesBE:function(t){return rt(G(t))},utf8ToBytes:ct,validateObject:bt});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wt=BigInt(0),xt=BigInt(1),It=BigInt(2),Bt=BigInt(3),Tt=BigInt(4),vt=BigInt(5),Ot=BigInt(8);function St(t,e){const r=t%e;return r>=wt?r:e+r}function At(t,e,r){if(r<=wt||e<wt)throw new Error("Expected power/modulo > 0");if(r===xt)return wt;let n=xt;for(;e>wt;)e&xt&&(n=n*t%r),t=t*t%r,e>>=xt;return n}function Et(t,e,r){let n=t;for(;e-- >wt;)n*=n,n%=r;return n}function kt(t,e){if(t===wt||e<=wt)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=St(t,e),n=e,s=wt,a=xt;for(;r!==wt;){const t=n%r,e=s-a*(n/r);n=r,r=t,s=a,a=e}if(n!==xt)throw new Error("invert: does not exist");return St(s,e)}function Rt(t){if(t%Tt===Bt){const e=(t+xt)/Tt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%Ot===vt){const e=(t-vt)/Ot;return function(t,r){const n=t.mul(r,It),s=t.pow(n,e),a=t.mul(r,s),i=t.mul(t.mul(a,It),s),o=t.mul(a,t.sub(i,t.ONE));if(!t.eql(t.sqr(o),r))throw new Error("Cannot find square root");return o}}return function(t){const e=(t-xt)/It;let r,n,s;for(r=t-xt,n=0;r%It===wt;r/=It,n++);for(s=It;s<t&&At(s,e,t)!==t-xt;s++);if(1===n){const e=(t+xt)/Tt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const a=(r+xt)/It;return function(t,i){if(t.pow(i,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let o=n,u=t.pow(t.mul(t.ONE,s),r),c=t.pow(i,a),d=t.pow(i,r);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(d);e<o&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(u,xt<<BigInt(o-e-1));u=t.sqr(r),c=t.mul(c,r),d=t.mul(d,u),o=e}return c}}(t)}BigInt(9),BigInt(16);const Dt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Pt(t){return bt(t,Dt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function _t(t,e,r){if(r<wt)throw new Error("Expected power > 0");if(r===wt)return t.ONE;if(r===xt)return e;let n=t.ONE,s=e;for(;r>wt;)r&xt&&(n=t.mul(n,s)),s=t.sqr(s),r>>=xt;return n}function Ct(t,e){const r=new Array(e.length),n=e.reduce(((e,n,s)=>t.is0(n)?e:(r[s]=e,t.mul(e,n))),t.ONE),s=t.inv(n);return e.reduceRight(((e,n,s)=>t.is0(n)?e:(r[s]=t.mul(e,r[s]),t.mul(e,n))),s),r}function Nt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Vt(t,e,r=!1,n={}){if(t<=wt)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:a}=Nt(t,e);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=Rt(t),o=Object.freeze({ORDER:t,BITS:s,BYTES:a,MASK:lt(s),ZERO:wt,ONE:xt,create:e=>St(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return wt<=e&&e<t},is0:t=>t===wt,isOdd:t=>(t&xt)===xt,neg:e=>St(-e,t),eql:(t,e)=>t===e,sqr:e=>St(e*e,t),add:(e,r)=>St(e+r,t),sub:(e,r)=>St(e-r,t),mul:(e,r)=>St(e*r,t),pow:(t,e)=>_t(o,t,e),div:(e,r)=>St(e*kt(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>kt(e,t),sqrt:n.sqrt||(t=>i(o,t)),invertBatch:t=>Ct(o,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?it(t,a):at(t,a),fromBytes:t=>{if(t.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${t.length}`);return r?st(t):nt(t)}});return Object.freeze(o)}function Ut(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Lt(t){const e=Ut(t);return e+Math.ceil(e/2)}function Mt(t,e,r=!1){const n=t.length,s=Ut(e),a=Lt(e);if(n<16||n<a||n>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${n}`);const i=St(r?nt(t):st(t),e-xt)+xt;return r?it(i,s):at(i,s)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),qt=BigInt(1);function Xt(t){return Pt(t.Fp),bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Nt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:jt,hexToBytes:Ht}=yt,Kt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=Kt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:jt(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=Kt,r="string"==typeof t?Ht(t):t;if(!H(r))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:s,l:a}=Kt._parseInt(r.subarray(2)),{d:i,l:o}=Kt._parseInt(a);if(o.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),s=e(r(t.r)),a=n.length/2,i=s.length/2,o=r(a),u=r(i);return`30${r(i+a+4)}02${u}${s}02${o}${n}`}},Wt=BigInt(0),Gt=BigInt(1),Zt=BigInt(2),$t=BigInt(3),zt=BigInt(4);function Yt(t){const e=function(t){const e=Xt(t);bt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:s}=e;if(r){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const s=e.toAffine();return ut(Uint8Array.from([4]),r.toBytes(s.x),r.toBytes(s.y))}),s=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function a(t){const{a:n,b:s}=e,a=r.sqr(t),i=r.mul(a,t);return r.add(r.add(i,r.mul(t,n)),s)}if(!r.eql(r.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function i(t){return"bigint"==typeof t&&Wt<t&&t<e.n}function o(t){if(!i(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function u(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:s,n:a}=e;if(r&&"bigint"!=typeof t){if(H(t)&&(t=W(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let i;try{i="bigint"==typeof t?t:nt(ot("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return s&&(i=St(i,a)),o(i),i}const c=new Map;function d(t){if(!(t instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof f)throw new Error("projective point not allowed");const s=t=>r.eql(t,r.ZERO);return s(e)&&s(n)?f.ZERO:new f(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(f.fromAffine)}static fromHex(t){const e=f.fromAffine(s(ot("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return f.BASE.multiply(u(t))}_setWindowSize(t){this._WINDOW_SIZE=t,c.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const s=r.sqr(n),i=a(t);if(!r.eql(s,i))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){d(t);const{px:e,py:n,pz:s}=this,{px:a,py:i,pz:o}=t,u=r.eql(r.mul(e,o),r.mul(a,s)),c=r.eql(r.mul(n,o),r.mul(i,s));return u&&c}negate(){return new f(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,s=r.mul(n,$t),{px:a,py:i,pz:o}=this;let u=r.ZERO,c=r.ZERO,d=r.ZERO,l=r.mul(a,a),h=r.mul(i,i),p=r.mul(o,o),m=r.mul(a,i);return m=r.add(m,m),d=r.mul(a,o),d=r.add(d,d),u=r.mul(t,d),c=r.mul(s,p),c=r.add(u,c),u=r.sub(h,c),c=r.add(h,c),c=r.mul(u,c),u=r.mul(m,u),d=r.mul(s,d),p=r.mul(t,p),m=r.sub(l,p),m=r.mul(t,m),m=r.add(m,d),d=r.add(l,l),l=r.add(d,l),l=r.add(l,p),l=r.mul(l,m),c=r.add(c,l),p=r.mul(i,o),p=r.add(p,p),l=r.mul(p,m),u=r.sub(u,l),d=r.mul(p,h),d=r.add(d,d),d=r.add(d,d),new f(u,c,d)}add(t){d(t);const{px:n,py:s,pz:a}=this,{px:i,py:o,pz:u}=t;let c=r.ZERO,l=r.ZERO,h=r.ZERO;const p=e.a,m=r.mul(e.b,$t);let g=r.mul(n,i),b=r.mul(s,o),y=r.mul(a,u),w=r.add(n,s),x=r.add(i,o);w=r.mul(w,x),x=r.add(g,b),w=r.sub(w,x),x=r.add(n,a);let I=r.add(i,u);return x=r.mul(x,I),I=r.add(g,y),x=r.sub(x,I),I=r.add(s,a),c=r.add(o,u),I=r.mul(I,c),c=r.add(b,y),I=r.sub(I,c),h=r.mul(p,x),c=r.mul(m,y),h=r.add(c,h),c=r.sub(b,h),h=r.add(b,h),l=r.mul(c,h),b=r.add(g,g),b=r.add(b,g),y=r.mul(p,y),x=r.mul(m,x),b=r.add(b,y),y=r.sub(g,y),y=r.mul(p,y),x=r.add(x,y),g=r.mul(b,x),l=r.add(l,g),g=r.mul(I,x),c=r.mul(w,c),c=r.sub(c,g),g=r.mul(w,b),h=r.mul(I,h),h=r.add(h,g),new f(c,l,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(f.ZERO)}wNAF(t){return h.wNAFCached(this,c,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(f.fromAffine)}))}multiplyUnsafe(t){const n=f.ZERO;if(t===Wt)return n;if(o(t),t===Gt)return this;const{endo:s}=e;if(!s)return h.unsafeLadder(this,t);let{k1neg:a,k1:i,k2neg:u,k2:c}=s.splitScalar(t),d=n,l=n,p=this;for(;i>Wt||c>Wt;)i&Gt&&(d=d.add(p)),c&Gt&&(l=l.add(p)),p=p.double(),i>>=Gt,c>>=Gt;return a&&(d=d.negate()),u&&(l=l.negate()),l=new f(r.mul(l.px,s.beta),l.py,l.pz),d.add(l)}multiply(t){o(t);let n,s,a=t;const{endo:i}=e;if(i){const{k1neg:t,k1:e,k2neg:o,k2:u}=i.splitScalar(a);let{p:c,f:d}=this.wNAF(e),{p:l,f:p}=this.wNAF(u);c=h.constTimeNegate(t,c),l=h.constTimeNegate(o,l),l=new f(r.mul(l.px,i.beta),l.py,l.pz),n=c.add(l),s=d.add(p)}else{const{p:t,f:e}=this.wNAF(a);n=t,s=e}return f.normalizeZ([n,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=f.BASE,s=(t,e)=>e!==Wt&&e!==Gt&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),a=s(this,e).add(s(t,r));return a.is0()?void 0:a}toAffine(t){const{px:e,py:n,pz:s}=this,a=this.is0();null==t&&(t=a?r.ONE:r.inv(s));const i=r.mul(e,t),o=r.mul(n,t),u=r.mul(s,t);if(a)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:i,y:o}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Gt)return!0;if(r)return r(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Gt?this:r?r(f,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(f,this,t)}toHex(t=!0){return W(this.toRawBytes(t))}}f.BASE=new f(e.Gx,e.Gy,r.ONE),f.ZERO=new f(r.ZERO,r.ONE,r.ZERO);const l=e.nBitLength,h=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,s=e;for(;r>Ft;)r&qt&&(n=n.add(s)),s=s.double(),r>>=qt;return n},precomputeWindow(t,e){const{windows:r,windowSize:s}=n(e),a=[];let i=t,o=i;for(let t=0;t<r;t++){o=i,a.push(o);for(let t=1;t<s;t++)o=o.add(i),a.push(o);i=o.double()}return a},wNAF(e,s,a){const{windows:i,windowSize:o}=n(e);let u=t.ZERO,c=t.BASE;const d=BigInt(2**e-1),f=2**e,l=BigInt(e);for(let t=0;t<i;t++){const e=t*o;let n=Number(a&d);a>>=l,n>o&&(n-=f,a+=qt);const i=e,h=e+Math.abs(n)-1,p=t%2!=0,m=n<0;0===n?c=c.add(r(p,s[i])):u=u.add(r(m,s[h]))}return{p:u,f:c}},wNAFCached(t,e,r,n){const s=t._WINDOW_SIZE||1;let a=e.get(t);return a||(a=this.precomputeWindow(t,s),1!==s&&e.set(t,n(a))),this.wNAF(s,a,r)}}}(f,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:a,isWithinCurveOrder:i}}function Jt(t){const e=function(t){const e=Xt(t);return bt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:n}=e,s=r.BYTES+1,a=2*r.BYTES+1;function i(t){return St(t,n)}function o(t){return kt(t,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:d,isWithinCurveOrder:f}=Yt({...e,toBytes(t,e,n){const s=e.toAffine(),a=r.toBytes(s.x),i=ut;return n?i(Uint8Array.from([e.hasEvenY()?2:3]),a):i(Uint8Array.from([4]),a,r.toBytes(s.y))},fromBytes(t){const e=t.length,n=t[0],i=t.subarray(1);if(e!==s||2!==n&&3!==n){if(e===a&&4===n){return{x:r.fromBytes(i.subarray(0,r.BYTES)),y:r.fromBytes(i.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`)}{const t=nt(i);if(!(Wt<(o=t)&&o<r.ORDER))throw new Error("Point is not on curve");const e=d(t);let s=r.sqrt(e);return!(1&~n)!==((s&Gt)===Gt)&&(s=r.neg(s)),{x:t,y:s}}var o}}),l=t=>W(at(t,e.nByteLength));function h(t){return t>n>>Gt}const p=(t,e,r)=>nt(t.slice(e,r));class m{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=ot("compactSignature",t,2*r),new m(p(t,0,r),p(t,r,2*r))}static fromDER(t){const{r:e,s:r}=Kt.toSig(ot("DER",t));return new m(e,r)}assertValidity(){if(!f(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!f(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new m(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:s,recovery:a}=this,c=w(ot("msgHash",t));if(null==a||![0,1,2,3].includes(a))throw new Error("recovery id invalid");const d=2===a||3===a?n+e.n:n;if(d>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=1&a?"03":"02",h=u.fromHex(f+l(d)),p=o(d),m=i(-c*p),g=i(s*p),b=u.BASE.multiplyAndAddUnsafe(h,m,g);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return rt(this.toDERHex())}toDERHex(){return Kt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return rt(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const g={isValidPrivateKey(t){try{return c(t),!0}catch(t){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const t=Lt(e.n);return Mt(e.randomBytes(t),e.n)},precompute:(t=8,e=u.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function b(t){const e=H(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===s||n===a:r?n===2*s||n===2*a:t instanceof u}const y=e.bits2int||function(t){const r=nt(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},w=e.bits2int_modN||function(t){return i(y(t))},x=lt(e.nBitLength);function I(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Wt<=t&&t<x))throw new Error(`bigint expected < 2^${e.nBitLength}`);return at(t,e.nByteLength)}function B(t,n,s=T){if(["recovered","canonical"].some((t=>t in s)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:d}=e;let{lowS:l,prehash:p,extraEntropy:g}=s;null==l&&(l=!0),t=ot("msgHash",t),p&&(t=ot("prehashed msgHash",a(t)));const b=w(t),x=c(n),B=[I(x),I(b)];if(null!=g){const t=!0===g?d(r.BYTES):g;B.push(ot("extraEntropy",t))}const v=ut(...B),O=b;return{seed:v,k2sig:function(t){const e=y(t);if(!f(e))return;const r=o(e),n=u.BASE.multiply(e).toAffine(),s=i(n.x);if(s===Wt)return;const a=i(r*i(O+s*x));if(a===Wt)return;let c=(n.x===s?0:2)|Number(n.y&Gt),d=a;return l&&h(a)&&(d=function(t){return h(t)?i(-t):t}(a),c^=1),new m(s,d,c)}}}const T={lowS:e.lowS,prehash:!1},v={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return u.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(b(t))throw new Error("first arg must be private key");if(!b(e))throw new Error("second arg must be public key");return u.fromHex(e).multiply(c(t)).toRawBytes(r)},sign:function(t,r,n=T){const{seed:s,k2sig:a}=B(t,r,n),i=e;return mt(i.hash.outputLen,i.nByteLength,i.hmac)(s,a)},verify:function(t,r,n,s=v){const a=t;if(r=ot("msgHash",r),n=ot("publicKey",n),"strict"in s)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:d}=s;let f,l;try{if("string"==typeof a||H(a))try{f=m.fromDER(a)}catch(t){if(!(t instanceof Kt.Err))throw t;f=m.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:t,s:e}=a;f=new m(t,e)}}l=u.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&f.hasHighS())return!1;d&&(r=e.hash(r));const{r:h,s:p}=f,g=w(r),b=o(p),y=i(g*b),x=i(h*b),I=u.BASE.multiplyAndAddUnsafe(l,y,x)?.toAffine();return!!I&&i(I.x)===h},ProjectivePoint:u,Signature:m,utils:g}}function Qt(t,e){if(Pt(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=function(t,e){const r=t.ORDER;let n=Wt;for(let t=r-Gt;t%Zt===Wt;t/=Zt)n+=Gt;const s=n,a=Zt<<s-Gt-Gt,i=a*Zt,o=(r-Gt)/i,u=(o-Gt)/Zt,c=i-Gt,d=a,f=t.pow(e,o),l=t.pow(e,(o+Gt)/Zt);let h=(e,r)=>{let n=f,a=t.pow(r,c),i=t.sqr(a);i=t.mul(i,r);let o=t.mul(e,i);o=t.pow(o,u),o=t.mul(o,a),a=t.mul(o,r),i=t.mul(o,e);let h=t.mul(i,a);o=t.pow(h,d);let p=t.eql(o,t.ONE);a=t.mul(i,l),o=t.mul(h,n),i=t.cmov(a,i,p),h=t.cmov(o,h,p);for(let e=s;e>Gt;e--){let r=e-Zt;r=Zt<<r-Gt;let s=t.pow(h,r);const o=t.eql(s,t.ONE);a=t.mul(i,n),n=t.mul(n,n),s=t.mul(h,n),i=t.cmov(a,i,o),h=t.cmov(s,h,o)}return{isValid:p,value:i}};if(t.ORDER%zt===$t){const r=(t.ORDER-$t)/zt,n=t.sqrt(t.neg(e));h=(e,s)=>{let a=t.sqr(s);const i=t.mul(e,s);a=t.mul(a,i);let o=t.pow(a,r);o=t.mul(o,i);const u=t.mul(o,n),c=t.mul(t.sqr(o),s),d=t.eql(c,e);return{isValid:d,value:t.cmov(u,o,d)}}}return h}(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return n=>{let s,a,i,o,u,c,d,f;s=t.sqr(n),s=t.mul(s,e.Z),a=t.sqr(s),a=t.add(a,s),i=t.add(a,t.ONE),i=t.mul(i,e.B),o=t.cmov(e.Z,t.neg(a),!t.eql(a,t.ZERO)),o=t.mul(o,e.A),a=t.sqr(i),c=t.sqr(o),u=t.mul(c,e.A),a=t.add(a,u),a=t.mul(a,i),c=t.mul(c,o),u=t.mul(c,e.B),a=t.add(a,u),d=t.mul(s,i);const{isValid:l,value:h}=r(a,c);f=t.mul(s,n),f=t.mul(f,h),d=t.cmov(d,i,l),f=t.cmov(f,h,l);const p=t.isOdd(n)===t.isOdd(f);return f=t.cmov(t.neg(f),f,p),d=t.div(d,o),{x:d,y:f}}}const te=nt;function ee(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function re(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function ne(t){if(!H(t))throw new Error("Uint8Array expected")}function se(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ae(t,e,r){bt(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:n,k:s,m:a,hash:i,expand:o,DST:u}=r;ne(t),se(e);const c=function(t){if(H(t))return t;if("string"==typeof t)return ct(t);throw new Error("DST must be Uint8Array or string")}(u),d=n.toString(2).length,f=Math.ceil((d+s)/8),l=e*a*f;let h;if("xmd"===o)h=function(t,e,r,n){ne(t),ne(e),se(r),e.length>255&&(e=n(ut(ct("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:a}=n,i=Math.ceil(r/s);if(i>255)throw new Error("Invalid xmd length");const o=ut(e,ee(e.length,1)),u=ee(0,a),c=ee(r,2),d=new Array(i),f=n(ut(u,t,c,ee(0,1),o));d[0]=n(ut(f,ee(1,1),o));for(let t=1;t<=i;t++){const e=[re(f,d[t-1]),ee(t+1,1),o];d[t]=n(ut(...e))}return ut(...d).slice(0,r)}(t,c,l,i);else if("xof"===o)h=function(t,e,r,n,s){if(ne(t),ne(e),se(r),e.length>255){const t=Math.ceil(2*n/8);e=s.create({dkLen:t}).update(ct("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:r}).update(t).update(ee(r,2)).update(e).update(ee(e.length,1)).digest()}(t,c,l,s,i);else{if("_internal_pass"!==o)throw new Error('expand must be "xmd" or "xof"');h=t}const p=new Array(e);for(let t=0;t<e;t++){const e=new Array(a);for(let r=0;r<a;r++){const s=f*(r+t*a),i=h.subarray(s,s+f);e[r]=St(te(i),n)}p[t]=e}return p}function ie(t,e){const r=e.map((t=>Array.from(t).reverse()));return(e,n)=>{const[s,a,i,o]=r.map((r=>r.reduce(((r,n)=>t.add(t.mul(r,e),n)))));return e=t.div(s,a),n=t.mul(n,t.div(i,o)),{x:e,y:n}}}function oe(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(n,s){const a=ae(n,2,{...r,DST:r.DST,...s}),i=t.fromAffine(e(a[0])),o=t.fromAffine(e(a[1])),u=i.add(o).clearCofactor();return u.assertValidity(),u},encodeToCurve(n,s){const a=ae(n,1,{...r,DST:r.encodeDST,...s}),i=t.fromAffine(e(a[0])).clearCofactor();return i.assertValidity(),i}}}class ue extends O{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");b(t.outputLen),b(t.blockLen)}(t);const r=v(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return w(this),this.iHash.update(t),this}digestInto(t){w(this),y(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:s,blockLen:a,outputLen:i}=this;return t.finished=n,t.destroyed=s,t.blockLen=a,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ce=(t,e,r)=>new ue(t,e).update(r).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function de(t){return{hash:t,hmac:(e,...r)=>ce(t,e,n(...r)),randomBytes:s}}ce.create=(t,e)=>new ue(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const fe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),le=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),he=BigInt(1),pe=BigInt(2),me=(t,e)=>(t+e/pe)/e;const ge=Vt(fe,void 0,void 0,{sqrt:function(t){const e=fe,r=BigInt(3),n=BigInt(6),s=BigInt(11),a=BigInt(22),i=BigInt(23),o=BigInt(44),u=BigInt(88),c=t*t*t%e,d=c*c*t%e,f=Et(d,r,e)*d%e,l=Et(f,r,e)*d%e,h=Et(l,pe,e)*c%e,p=Et(h,s,e)*h%e,m=Et(p,a,e)*p%e,g=Et(m,o,e)*m%e,b=Et(g,u,e)*g%e,y=Et(b,o,e)*m%e,w=Et(y,r,e)*d%e,x=Et(w,i,e)*p%e,I=Et(x,n,e)*c%e,B=Et(I,pe,e);if(!ge.eql(ge.sqr(B),t))throw new Error("Cannot find square root");return B}}),be=function(t,e){const r=e=>Jt({...t,...de(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:ge,n:le,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=le,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-he*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,i=BigInt("0x100000000000000000000000000000000"),o=me(a*t,e),u=me(-n*t,e);let c=St(t-o*r-u*s,e),d=St(-o*n-u*a,e);const f=c>i,l=d>i;if(f&&(c=e-c),l&&(d=e-d),c>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:f,k1:c,k2neg:l,k2:d}}}},o);BigInt(0),be.ProjectivePoint,Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));
/*! micro-eth-signer - MIT License (c) 2021 Paul Miller (paulmillr.com) */
const ye=t=>be.getPublicKey(t,!1),we=t=>be.ProjectivePoint.fromHex(t).toRawBytes(!1);function xe(t){return/^0x/i.test(t)?t:`0x${t}`}function Ie(t){return t.replace(/^0x/i,"")}function Be(t){return a(Ie(t))}const Te={fromPrivateKey:t=>("string"==typeof t&&(t=Be(t)),Te.fromPublicKey(ye(t))),fromPublicKey(t){const e=we(t),r=i(F(e.subarray(1,65))).slice(24);return Te.checksum(r)},checksum(t){const e=Ie(t.toLowerCase());if(40!==e.length)throw new Error("Invalid address, must have 40 chars");const r=Ie(i(F(e)));let n="";for(let t=0;t<e.length;t++){const s=Number.parseInt(r[t],16);let a=e[t];s>7&&(a=a.toUpperCase()),n+=a}return xe(n)},verifyChecksum(t){const e=Ie(t);if(40!==e.length)throw new Error("Invalid address, must have 40 chars");if(e===e.toLowerCase()||e===e.toUpperCase())return!0;const r=i(F(e.toLowerCase()));for(let t=0;t<40;t++){const n=e[t],s=Number.parseInt(r[t],16);if(s>7&&n.toUpperCase()!==n)return!1;if(s<=7&&n.toLowerCase()!==n)return!1}return!0}};function ve(t){return BigInt(Ae(t))}function Oe(t){return Number.parseInt(i(t),16)}function Se(t){return 1===Oe(t)}function Ae(t){return xe(i(t))}function Ee(t){return 1&(t=Ie(t)).length&&(t="0"+t),a(t)}function ke(t,e){const r=e-t.length;if(r<=0)return t;const n=new Uint8Array(e);return n.set(t,r),n}const Re=t=>{let e=0;for(let r=0;r<t.length;r++){let n=t[r];for(;0!==n;)e+=1&n,n>>=1}return e};class De{}const Pe="AVM",_e="EVM",Ce="PVM",Ne=[Pe,_e,Ce];var Ve,Ue;!function(t){t.Codec="codec",t.BaseTx="avax.BaseTx",t.TransferableOutput="avax.TransferableOutput",t.TransferableInput="avax.TransferableInput",t.TransferableOp="avax.TransferableOp",t.UTXOID="avax.UTXOID",t.UTXO="avax.Utxo",t.Id="common.Id",t.Address="common.Address",t.NodeId="common.NodeId",t.BlsSignature="common.BlsSignature",t.BlsPublicKey="common.BlsPublicKey",t.Int="primitives.Int",t.BigIntPr="primitives.BigInt",t.StringPr="primitives.String",t.Byte="primitives.Byte",t.Bytes="primitives.Bytes",t.Short="primitives.Short",t.Bool="primitives.Bool",t.Input="secp256k1fx.Input",t.TransferInput="secp256k1fx.TransferInput",t.TransferOutput="secp256k1fx.TransferOutput",t.OutputOwners="secp256k1fx.OutputOwners",t.OutputOwnersList="secp256k1fx.OutputOwnersList",t.Credential="secp256k1fx.Credential",t.Signature="secp256k1fx.Signature",t.SecpMintOperation="secp256k1fx.MintOperation",t.SecpMintOutput="secp256k1fx.MintOutput",t.NftFxMintOperation="nftfx.MintOperation",t.NftFxMintOutput="nftfx.MintOutput",t.NftFxTransferOperation="nftfx.TransferOperation",t.NftFxTransferOutput="nftfx.TransferOutput",t.NftFxCredential="nftfx.Credential",t.AvmBaseTx="avm.BaseTx",t.AvmExportTx="avm.ExportTx",t.AvmImportTx="avm.ImportTx",t.CreateAssetTx="avm.CreateAssetTx",t.OperationTx="avm.OperationTx",t.InitialState="avm.InitialState",t.AvmSignedTx="avm.SignedTx",t.PvmBaseTx="pvm.BaseTx",t.StakeableLockIn="pvm.StakeableLockIn",t.StakeableLockOut="pvm.StakeableLockOut",t.AddDelegatorTx="pvm.AddDelegatorTx",t.AddValidatorTx="pvm.AddValidatorTx",t.AddPermissionlessDelegatorTx="pvm.AddPermissionlessDelegator",t.AddPermissionlessValidatorTx="pvm.AddPermissionlessValidator",t.Validator="pvm.Validator",t.SubnetValidator="pvm.SubnetValidator",t.Signer="pvm.signer",t.SignerEmpty="pvm.signerEmpty",t.ProofOfPossession="pvm.proofOfPossession",t.AddSubnetValidatorTx="pvm.AddSubnetValidator",t.AdvanceTimeTx="pvm.AdvanceTimeTx",t.CreateChainTx="pvm.CreateChainTx",t.CreateSubnetTx="pvm.CreateSubnetTx",t.PvmExportTx="pvm.ExportTx",t.PvmImportTx="pvm.ImportTx",t.RewardValidatorTx="pvm.RewardValidatorTx",t.RemoveSubnetValidatorTx="pvm.RemoveSubnetValidator",t.TransformSubnetTx="pvm.TransformSubnetTx",t.TransferSubnetOwnershipTx="pvm.TransferSubnetOwnershipTx",t.L1Validator="pvm.L1Validator",t.ConvertSubnetToL1Tx="pvm.ConvertSubnetToL1Tx",t.RegisterL1ValidatorTx="pvm.RegisterL1ValidatorTx",t.SetL1ValidatorWeightTx="pvm.SetL1ValidatorWeightTx",t.IncreaseL1ValidatorBalanceTx="pvm.IncreaseL1ValidatorBalanceTx",t.DisableL1ValidatorTx="pvm.DisableL1ValidatorTx",t.PChainOwner="pvm.PChainOwner",t.EvmExportTx="evm.ExportTx",t.EvmInput="evm.Input",t.EvmOutput="evm.Output",t.EvmImportTx="evm.ImportTx",t.WarpMessage="warp.Message",t.WarpUnsignedMessage="warp.UnsignedMessage",t.WarpSignature="warp.Signature",t.AddressedCall="warp.AddressedCall",t.RegisterL1ValidatorMessage="warp.RegisterL1ValidatorMessage",t.L1ValidatorWeightMessage="warp.L1ValidatorWeightMessage",t.SubnetToL1ConversionMessage="warp.SubnetToL1ConversionMessage",t.L1ValidatorRegistrationMessage="warp.L1ValidatorRegistrationMessage",t.ValidatorData="warp.ValidatorData",t.ConversionData="warp.ConversionData"}(Ve||(Ve={}));let Le=Ue=class extends De{address;_type=Ve.Address;constructor(t){super(),this.address=t}static fromBytes(t){return[new Ue(t.slice(0,20)),t.slice(20)]}[l](t,e){return e.stylize(this.toJSON(),"string")}toJSON(t="avax"){return this.toString(t)}static fromString(t){return new Ue(p(t))}static fromHex(t){return new Ue(Ee(t))}toHex(){return Ae(this.address)}toBytes(){return ke(this.address,20)}toString(t="avax"){return g(t,this.address)}value(){return this.toString()}};Le=Ue=d([t=>{},f("design:paramtypes",[Uint8Array])],Le);const Me=BigInt(2),Fe=BigInt(3);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qe=BigInt(0),Xe=BigInt(1),je=BigInt(2),He=BigInt(3),Ke=BigInt(4),We=BigInt(8),Ge=BigInt(16),Ze=BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),$e=Vt(Ze),ze=Vt(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")),Ye=({c0:t,c1:e},{c0:r,c1:n})=>({c0:$e.add(t,r),c1:$e.add(e,n)}),Je=({c0:t,c1:e},{c0:r,c1:n})=>({c0:$e.sub(t,r),c1:$e.sub(e,n)}),Qe=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:$e.mul(t,r),c1:$e.mul(e,r)};const{c0:n,c1:s}=r;let a=$e.mul(t,n),i=$e.mul(e,s);return{c0:$e.sub(a,i),c1:$e.sub($e.mul($e.add(t,e),$e.add(n,s)),$e.add(a,i))}},tr=({c0:t,c1:e})=>{const r=$e.add(t,e),n=$e.sub(t,e),s=$e.add(t,t);return{c0:$e.mul(r,n),c1:$e.mul(s,e)}},er=Ze*Ze,rr={ORDER:er,BITS:dt(er),BYTES:Math.ceil(dt(er)/8),MASK:lt(dt(er)),ZERO:{c0:$e.ZERO,c1:$e.ZERO},ONE:{c0:$e.ONE,c1:$e.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>"bigint"==typeof t&&"bigint"==typeof e,is0:({c0:t,c1:e})=>$e.is0(t)&&$e.is0(e),eql:({c0:t,c1:e},{c0:r,c1:n})=>$e.eql(t,r)&&$e.eql(e,n),neg:({c0:t,c1:e})=>({c0:$e.neg(t),c1:$e.neg(e)}),pow:(t,e)=>_t(rr,t,e),invertBatch:t=>Ct(rr,t),add:Ye,sub:Je,mul:Qe,sqr:tr,addN:Ye,subN:Je,mulN:Qe,sqrN:tr,div:(t,e)=>rr.mul(t,"bigint"==typeof e?$e.inv($e.create(e)):rr.inv(e)),inv:({c0:t,c1:e})=>{const r=$e.inv($e.create(t*t+e*e));return{c0:$e.mul(r,$e.create(t)),c1:$e.mul(r,$e.create(-e))}},sqrt:t=>{if(rr.eql(t,rr.ZERO))return rr.ZERO;const e=rr.pow(t,(rr.ORDER+We)/Ge),r=rr.div(rr.sqr(e),t),n=ar,s=[n[0],n[2],n[4],n[6]].find((t=>rr.eql(t,r)));if(!s)throw new Error("No root");const a=n.indexOf(s),i=n[a/2];if(!i)throw new Error("Invalid root");const o=rr.div(e,i),u=rr.neg(o),{re:c,im:d}=rr.reim(o),{re:f,im:l}=rr.reim(u);return d>l||d===l&&c>f?o:u},isOdd:t=>{const{re:e,im:r}=rr.reim(t);return BigInt(e%je||e===qe&&r%je)==Xe},fromBytes(t){if(t.length!==rr.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:$e.fromBytes(t.subarray(0,$e.BYTES)),c1:$e.fromBytes(t.subarray($e.BYTES))}},toBytes:({c0:t,c1:e})=>ut($e.toBytes(t),$e.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:n},s)=>({c0:$e.cmov(t,r,s),c1:$e.cmov(e,n,s)}),reim:({c0:t,c1:e})=>({re:t,im:e}),mulByNonresidue:({c0:t,c1:e})=>({c0:$e.sub(t,e),c1:$e.add(t,e)}),multiplyByB:({c0:t,c1:e})=>{let r=$e.mul(t,Ke),n=$e.mul(e,Ke);return{c0:$e.sub(r,n),c1:$e.add(r,n)}},fromBigTuple:t=>{if(2!==t.length)throw new Error("Invalid tuple");const e=t.map((t=>$e.create(t)));return{c0:e[0],c1:e[1]}},frobeniusMap:({c0:t,c1:e},r)=>({c0:t,c1:$e.mul(e,nr[r%2])})},nr=[BigInt("0x1"),BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")].map((t=>$e.create(t))),sr=BigInt("0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),ar=[[Xe,qe],[sr,-sr],[qe,Xe],[sr,sr],[-Xe,qe],[-sr,sr],[qe,-Xe],[-sr,-sr]].map((t=>rr.fromBigTuple(t))),ir=({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>({c0:rr.add(t,n),c1:rr.add(e,s),c2:rr.add(r,a)}),or=({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>({c0:rr.sub(t,n),c1:rr.sub(e,s),c2:rr.sub(r,a)}),ur=({c0:t,c1:e,c2:r},n)=>{if("bigint"==typeof n)return{c0:rr.mul(t,n),c1:rr.mul(e,n),c2:rr.mul(r,n)};const{c0:s,c1:a,c2:i}=n,o=rr.mul(t,s),u=rr.mul(e,a),c=rr.mul(r,i);return{c0:rr.add(o,rr.mulByNonresidue(rr.sub(rr.mul(rr.add(e,r),rr.add(a,i)),rr.add(u,c)))),c1:rr.add(rr.sub(rr.mul(rr.add(t,e),rr.add(s,a)),rr.add(o,u)),rr.mulByNonresidue(c)),c2:rr.sub(rr.add(u,rr.mul(rr.add(t,r),rr.add(s,i))),rr.add(o,c))}},cr=({c0:t,c1:e,c2:r})=>{let n=rr.sqr(t),s=rr.mul(rr.mul(t,e),je),a=rr.mul(rr.mul(e,r),je),i=rr.sqr(r);return{c0:rr.add(rr.mulByNonresidue(a),n),c1:rr.add(rr.mulByNonresidue(i),s),c2:rr.sub(rr.sub(rr.add(rr.add(s,rr.sqr(rr.add(rr.sub(t,e),r))),a),n),i)}},dr={ORDER:rr.ORDER,BITS:3*rr.BITS,BYTES:3*rr.BYTES,MASK:lt(3*rr.BITS),ZERO:{c0:rr.ZERO,c1:rr.ZERO,c2:rr.ZERO},ONE:{c0:rr.ONE,c1:rr.ZERO,c2:rr.ZERO},create:t=>t,isValid:({c0:t,c1:e,c2:r})=>rr.isValid(t)&&rr.isValid(e)&&rr.isValid(r),is0:({c0:t,c1:e,c2:r})=>rr.is0(t)&&rr.is0(e)&&rr.is0(r),neg:({c0:t,c1:e,c2:r})=>({c0:rr.neg(t),c1:rr.neg(e),c2:rr.neg(r)}),eql:({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>rr.eql(t,n)&&rr.eql(e,s)&&rr.eql(r,a),sqrt:()=>{throw new Error("Not implemented")},div:(t,e)=>dr.mul(t,"bigint"==typeof e?$e.inv($e.create(e)):dr.inv(e)),pow:(t,e)=>_t(dr,t,e),invertBatch:t=>Ct(dr,t),add:ir,sub:or,mul:ur,sqr:cr,addN:ir,subN:or,mulN:ur,sqrN:cr,inv:({c0:t,c1:e,c2:r})=>{let n=rr.sub(rr.sqr(t),rr.mulByNonresidue(rr.mul(r,e))),s=rr.sub(rr.mulByNonresidue(rr.sqr(r)),rr.mul(t,e)),a=rr.sub(rr.sqr(e),rr.mul(t,r)),i=rr.inv(rr.add(rr.mulByNonresidue(rr.add(rr.mul(r,s),rr.mul(e,a))),rr.mul(t,n)));return{c0:rr.mul(i,n),c1:rr.mul(i,s),c2:rr.mul(i,a)}},fromBytes:t=>{if(t.length!==dr.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:rr.fromBytes(t.subarray(0,rr.BYTES)),c1:rr.fromBytes(t.subarray(rr.BYTES,2*rr.BYTES)),c2:rr.fromBytes(t.subarray(2*rr.BYTES))}},toBytes:({c0:t,c1:e,c2:r})=>ut(rr.toBytes(t),rr.toBytes(e),rr.toBytes(r)),cmov:({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a},i)=>({c0:rr.cmov(t,n,i),c1:rr.cmov(e,s,i),c2:rr.cmov(r,a,i)}),fromBigSix:t=>{if(!Array.isArray(t)||6!==t.length)throw new Error("Invalid Fp6 usage");return{c0:rr.fromBigTuple(t.slice(0,2)),c1:rr.fromBigTuple(t.slice(2,4)),c2:rr.fromBigTuple(t.slice(4,6))}},frobeniusMap:({c0:t,c1:e,c2:r},n)=>({c0:rr.frobeniusMap(t,n),c1:rr.mul(rr.frobeniusMap(e,n),fr[n%6]),c2:rr.mul(rr.frobeniusMap(r,n),lr[n%6])}),mulByNonresidue:({c0:t,c1:e,c2:r})=>({c0:rr.mulByNonresidue(r),c1:t,c2:e}),multiplyBy1:({c0:t,c1:e,c2:r},n)=>({c0:rr.mulByNonresidue(rr.mul(r,n)),c1:rr.mul(t,n),c2:rr.mul(e,n)}),multiplyBy01({c0:t,c1:e,c2:r},n,s){let a=rr.mul(t,n),i=rr.mul(e,s);return{c0:rr.add(rr.mulByNonresidue(rr.sub(rr.mul(rr.add(e,r),s),i)),a),c1:rr.sub(rr.sub(rr.mul(rr.add(n,s),rr.add(t,e)),a),i),c2:rr.add(rr.sub(rr.mul(rr.add(t,r),n),a),i)}},multiplyByFp2:({c0:t,c1:e,c2:r},n)=>({c0:rr.mul(t,n),c1:rr.mul(e,n),c2:rr.mul(r,n)})},fr=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe")]].map((t=>rr.fromBigTuple(t))),lr=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")]].map((t=>rr.fromBigTuple(t))),hr=BigInt("0xd201000000010000"),pr=dt(hr),mr=({c0:t,c1:e},{c0:r,c1:n})=>({c0:dr.add(t,r),c1:dr.add(e,n)}),gr=({c0:t,c1:e},{c0:r,c1:n})=>({c0:dr.sub(t,r),c1:dr.sub(e,n)}),br=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:dr.mul(t,r),c1:dr.mul(e,r)};let{c0:n,c1:s}=r,a=dr.mul(t,n),i=dr.mul(e,s);return{c0:dr.add(a,dr.mulByNonresidue(i)),c1:dr.sub(dr.mul(dr.add(t,e),dr.add(n,s)),dr.add(a,i))}},yr=({c0:t,c1:e})=>{let r=dr.mul(t,e);return{c0:dr.sub(dr.sub(dr.mul(dr.add(dr.mulByNonresidue(e),t),dr.add(t,e)),r),dr.mulByNonresidue(r)),c1:dr.add(r,r)}};function wr(t,e){const r=rr.sqr(t),n=rr.sqr(e);return{first:rr.add(rr.mulByNonresidue(n),r),second:rr.sub(rr.sub(rr.sqr(rr.add(t,e)),r),n)}}const xr={ORDER:rr.ORDER,BITS:2*rr.BITS,BYTES:2*rr.BYTES,MASK:lt(2*rr.BITS),ZERO:{c0:dr.ZERO,c1:dr.ZERO},ONE:{c0:dr.ONE,c1:dr.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>dr.isValid(t)&&dr.isValid(e),is0:({c0:t,c1:e})=>dr.is0(t)&&dr.is0(e),neg:({c0:t,c1:e})=>({c0:dr.neg(t),c1:dr.neg(e)}),eql:({c0:t,c1:e},{c0:r,c1:n})=>dr.eql(t,r)&&dr.eql(e,n),sqrt:()=>{throw new Error("Not implemented")},inv:({c0:t,c1:e})=>{let r=dr.inv(dr.sub(dr.sqr(t),dr.mulByNonresidue(dr.sqr(e))));return{c0:dr.mul(t,r),c1:dr.neg(dr.mul(e,r))}},div:(t,e)=>xr.mul(t,"bigint"==typeof e?$e.inv($e.create(e)):xr.inv(e)),pow:(t,e)=>_t(xr,t,e),invertBatch:t=>Ct(xr,t),add:mr,sub:gr,mul:br,sqr:yr,addN:mr,subN:gr,mulN:br,sqrN:yr,fromBytes:t=>{if(t.length!==xr.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:dr.fromBytes(t.subarray(0,dr.BYTES)),c1:dr.fromBytes(t.subarray(dr.BYTES))}},toBytes:({c0:t,c1:e})=>ut(dr.toBytes(t),dr.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:n},s)=>({c0:dr.cmov(t,r,s),c1:dr.cmov(e,n,s)}),fromBigTwelve:t=>({c0:dr.fromBigSix(t.slice(0,6)),c1:dr.fromBigSix(t.slice(6,12))}),frobeniusMap(t,e){const r=dr.frobeniusMap(t.c0,e),{c0:n,c1:s,c2:a}=dr.frobeniusMap(t.c1,e),i=Ir[e%12];return{c0:r,c1:dr.create({c0:rr.mul(n,i),c1:rr.mul(s,i),c2:rr.mul(a,i)})}},multiplyBy014:({c0:t,c1:e},r,n,s)=>{let a=dr.multiplyBy01(t,r,n),i=dr.multiplyBy1(e,s);return{c0:dr.add(dr.mulByNonresidue(i),a),c1:dr.sub(dr.sub(dr.multiplyBy01(dr.add(e,t),r,rr.add(n,s)),a),i)}},multiplyByFp2:({c0:t,c1:e},r)=>({c0:dr.multiplyByFp2(t,r),c1:dr.multiplyByFp2(e,r)}),conjugate:({c0:t,c1:e})=>({c0:t,c1:dr.neg(e)}),_cyclotomicSquare:({c0:t,c1:e})=>{const{c0:r,c1:n,c2:s}=t,{c0:a,c1:i,c2:o}=e,{first:u,second:c}=wr(r,i),{first:d,second:f}=wr(a,s),{first:l,second:h}=wr(n,o);let p=rr.mulByNonresidue(h);return{c0:dr.create({c0:rr.add(rr.mul(rr.sub(u,r),je),u),c1:rr.add(rr.mul(rr.sub(d,n),je),d),c2:rr.add(rr.mul(rr.sub(l,s),je),l)}),c1:dr.create({c0:rr.add(rr.mul(rr.add(p,a),je),p),c1:rr.add(rr.mul(rr.add(c,i),je),c),c2:rr.add(rr.mul(rr.add(f,o),je),f)})}},_cyclotomicExp(t,e){let r=xr.ONE;for(let n=pr-1;n>=0;n--)r=xr._cyclotomicSquare(r),ft(e,n)&&(r=xr.mul(r,t));return r},finalExponentiate:t=>{const e=hr,r=xr.div(xr.frobeniusMap(t,6),t),n=xr.mul(xr.frobeniusMap(r,2),r),s=xr.conjugate(xr._cyclotomicExp(n,e)),a=xr.mul(xr.conjugate(xr._cyclotomicSquare(n)),s),i=xr.conjugate(xr._cyclotomicExp(a,e)),o=xr.conjugate(xr._cyclotomicExp(i,e)),u=xr.mul(xr.conjugate(xr._cyclotomicExp(o,e)),xr._cyclotomicSquare(s)),c=xr.conjugate(xr._cyclotomicExp(u,e)),d=xr.frobeniusMap(xr.mul(s,o),2),f=xr.frobeniusMap(xr.mul(i,n),3),l=xr.frobeniusMap(xr.mul(u,xr.conjugate(n)),1),h=xr.mul(xr.mul(c,xr.conjugate(a)),n);return xr.mul(xr.mul(xr.mul(d,f),l),h)}},Ir=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8"),BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")],[BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2"),BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995"),BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3"),BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116"),BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995")]].map((t=>rr.fromBigTuple(t))),Br=ie(rr,[[["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"],["0x0","0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"],["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1","0x0"]],[["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"],["0xc","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"],["0x1","0x0"]],[["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706","0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"],["0x0","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"],["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10","0x0"]],[["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"],["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"],["0x12","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"],["0x1","0x0"]]].map((t=>t.map((t=>rr.fromBigTuple(t.map(BigInt))))))),Tr=ie($e,[["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7","0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb","0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0","0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861","0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9","0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983","0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84","0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e","0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317","0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e","0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b","0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"],["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c","0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff","0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19","0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8","0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e","0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5","0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a","0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e","0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641","0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"],["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33","0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696","0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6","0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb","0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb","0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0","0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2","0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29","0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587","0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30","0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132","0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e","0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8","0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133","0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b","0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"],["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1","0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d","0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2","0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416","0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d","0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac","0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c","0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9","0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a","0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55","0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8","0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092","0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc","0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7","0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))),vr=Qt(rr,{A:rr.create({c0:$e.create(qe),c1:$e.create(BigInt(240))}),B:rr.create({c0:$e.create(BigInt(1012)),c1:$e.create(BigInt(1012))}),Z:rr.create({c0:$e.create(BigInt(-2)),c1:$e.create(BigInt(-1))})}),Or=Qt($e,{A:$e.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),B:$e.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),Z:$e.create(BigInt(11))}),Sr=dr.create({c0:rr.ZERO,c1:rr.ONE,c2:rr.ZERO}),Ar=xr.create({c0:Sr,c1:dr.ZERO}),Er=xr.create({c0:dr.ZERO,c1:Sr}),[kr,Rr]=xr.invertBatch([Ar,Er]);function Dr(t,e){const r=e.toAffine(),n=(s=r.x,a=r.y,[xr.mul(xr.frobeniusMap(xr.multiplyByFp2(kr,s),1),Ar).c0.c0,xr.mul(xr.frobeniusMap(xr.multiplyByFp2(Rr,a),1),Er).c0.c0]);var s,a;return new t(n[0],n[1],rr.ONE)}const Pr=BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac");function _r(t,e){const r=e.toAffine(),n=(s=r.x,a=r.y,[rr.mul(s,Pr),rr.neg(a)]);var s,a;return new t(n[0],n[1],rr.ONE)}const Cr=Object.freeze({DST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",encodeDST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",p:$e.ORDER,m:2,k:128,expand:"xmd",hash:o}),Nr=Ur($e.toBytes(qe),{infinity:!0,compressed:!0});function Vr(t){const e=224&(t=t.slice())[0],r=!!(e>>7&1),n=!!(e>>6&1),s=!!(e>>5&1);return t[0]&=31,{compressed:r,infinity:n,sort:s,value:t}}function Ur(t,e){if(224&t[0])throw new Error("setMask: non-empty mask");return e.compressed&&(t[0]|=128),e.infinity&&(t[0]|=64),e.sort&&(t[0]|=32),t}function Lr(t){t.assertValidity();const e=t.equals(Fr.G1.ProjectivePoint.ZERO),{x:r,y:n}=t.toAffine();if(e)return Nr.slice();const s=$e.ORDER,a=Boolean(n*je/s);return Ur(at(r,$e.BYTES),{compressed:!0,sort:a})}function Mr(t){t.assertValidity();const e=$e.BYTES;if(t.equals(Fr.G2.ProjectivePoint.ZERO))return ut(Nr,at(qe,e));const{x:r,y:n}=t.toAffine(),{re:s,im:a}=rr.reim(r),{re:i,im:o}=rr.reim(n),u=Boolean((o>qe?o*je:i*je)/$e.ORDER&Xe),c=s;return ut(Ur(at(a,e),{sort:u,compressed:!0}),at(c,e))}const Fr=function(t){const{Fp:e,Fr:r,Fp2:n,Fp6:s,Fp12:a}=t.fields,i=dt(t.params.x);function o(e){const{x:r,y:s}=e,a=r,o=s;let u=a,c=o,d=n.ONE,f=[];for(let e=i-2;e>=0;e--){let r=n.sqr(c),s=n.sqr(d),i=n.multiplyByB(n.mul(s,Fe)),l=n.mul(i,Fe),h=n.sub(n.sub(n.sqr(n.add(c,d)),s),r);if(f.push([n.sub(i,r),n.mul(n.sqr(u),Fe),n.neg(h)]),u=n.div(n.mul(n.mul(n.sub(r,l),u),c),Me),c=n.sub(n.sqr(n.div(n.add(r,l),Me)),n.mul(n.sqr(i),Fe)),d=n.mul(r,h),ft(t.params.x,e)){let t=n.sub(c,n.mul(o,d)),e=n.sub(u,n.mul(a,d));f.push([n.sub(n.mul(t,a),n.mul(e,o)),n.neg(t),e]);let r=n.sqr(e),s=n.mul(r,e),i=n.mul(r,u),l=n.add(n.sub(s,n.mul(i,Me)),n.mul(n.sqr(t),d));u=n.mul(e,l),c=n.sub(n.mul(n.sub(i,l),t),n.mul(s,c)),d=n.mul(d,s)}}return f}function u(e,r){const{x:s}=t.params,o=r[0],u=r[1];let c=a.ONE;for(let t=0,r=i-2;r>=0;r--,t++){const i=e[t];if(c=a.multiplyBy014(c,i[0],n.mul(i[1],o),n.mul(i[2],u)),ft(s,r)){t+=1;const r=e[t];c=a.multiplyBy014(c,r[0],n.mul(r[1],o),n.mul(r[2],u))}0!==r&&(c=a.sqr(c))}return a.conjugate(c)}const c={randomPrivateKey:()=>{const e=Lt(r.ORDER);return Mt(t.randomBytes(e),r.ORDER)},calcPairingPrecomputes:o},d=Yt({n:r.ORDER,...t.G1}),f=Object.assign(d,oe(d.ProjectivePoint,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),l=Yt({n:r.ORDER,...t.G2}),h=Object.assign(l,oe(l.ProjectivePoint,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults})),{ShortSignature:p}=t.G1,{Signature:m}=t.G2;function g(t,e,r=!0){if(t.equals(f.ProjectivePoint.ZERO)||e.equals(h.ProjectivePoint.ZERO))throw new Error("pairing is not available for ZERO point");t.assertValidity(),e.assertValidity();const n=t.toAffine(),s=u(function(t){const e=t;return e._PPRECOMPUTES||(e._PPRECOMPUTES=o(t.toAffine())),e._PPRECOMPUTES}(e),[n.x,n.y]);return r?a.finalExponentiate(s):s}function b(t){return t instanceof f.ProjectivePoint?t:f.ProjectivePoint.fromHex(t)}function y(t,e){return t instanceof f.ProjectivePoint?t:f.hashToCurve(ot("point",t),e)}function w(t){return t instanceof h.ProjectivePoint?t:m.fromHex(t)}function x(t,e){return t instanceof h.ProjectivePoint?t:h.hashToCurve(ot("point",t),e)}return f.ProjectivePoint.BASE._setWindowSize(4),{getPublicKey:function(t){return f.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},getPublicKeyForShortSignatures:function(t){return h.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},sign:function(t,e,r){const n=x(t,r);n.assertValidity();const s=n.multiply(f.normPrivateKeyToScalar(e));return t instanceof h.ProjectivePoint?s:m.toRawBytes(s)},signShortSignature:function(t,e,r){const n=y(t,r);n.assertValidity();const s=n.multiply(f.normPrivateKeyToScalar(e));return t instanceof f.ProjectivePoint?s:p.toRawBytes(s)},verify:function(t,e,r,n){const s=b(r),i=x(e,n),o=f.ProjectivePoint.BASE,u=w(t),c=g(s.negate(),i,!1),d=g(o,u,!1),l=a.finalExponentiate(a.mul(d,c));return a.eql(l,a.ONE)},verifyBatch:function(t,e,r,n){if(!e.length)throw new Error("Expected non-empty messages array");if(r.length!==e.length)throw new Error("Pubkey count should equal msg count");const s=w(t),i=e.map((t=>x(t,n))),o=r.map(b);try{const t=[];for(const e of new Set(i)){const r=i.reduce(((t,r,n)=>r===e?t.add(o[n]):t),f.ProjectivePoint.ZERO);t.push(g(r,e,!1))}t.push(g(f.ProjectivePoint.BASE.negate(),s,!1));const e=t.reduce(((t,e)=>a.mul(t,e)),a.ONE),r=a.finalExponentiate(e);return a.eql(r,a.ONE)}catch{return!1}},verifyShortSignature:function(t,e,r,n){const s=w(r),i=y(e,n),o=h.ProjectivePoint.BASE,u=b(t),c=g(i,s,!1),d=g(u,o.negate(),!1),f=a.finalExponentiate(a.mul(d,c));return a.eql(f,a.ONE)},aggregatePublicKeys:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(b).reduce(((t,e)=>t.add(e)),f.ProjectivePoint.ZERO);return t[0]instanceof f.ProjectivePoint?(e.assertValidity(),e):e.toRawBytes(!0)},aggregateSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(w).reduce(((t,e)=>t.add(e)),h.ProjectivePoint.ZERO);return t[0]instanceof h.ProjectivePoint?(e.assertValidity(),e):m.toRawBytes(e)},aggregateShortSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(b).reduce(((t,e)=>t.add(e)),f.ProjectivePoint.ZERO);return t[0]instanceof f.ProjectivePoint?(e.assertValidity(),e):p.toRawBytes(e)},millerLoop:u,pairing:g,G1:f,G2:h,Signature:m,ShortSignature:p,fields:{Fr:r,Fp:e,Fp2:n,Fp6:s,Fp12:a},params:{x:t.params.x,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:c}}({fields:{Fp:$e,Fp2:rr,Fp6:dr,Fp12:xr,Fr:ze},G1:{Fp:$e,h:BigInt("0x396c8c005555e1568c00aaab0000aaab"),Gx:BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),Gy:BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),a:$e.ZERO,b:Ke,htfDefaults:{...Cr,m:1,DST:"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>{const r=BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),n=new t($e.mul(e.px,r),e.py,e.pz);return e.multiplyUnsafe(Fr.params.x).negate().multiplyUnsafe(Fr.params.x).equals(n)},clearCofactor:(t,e)=>e.multiplyUnsafe(Fr.params.x).add(e),mapToCurve:t=>{const{x:e,y:r}=Or($e.create(t[0]));return Tr(e,r)},fromBytes:t=>{const{compressed:e,infinity:r,sort:n,value:s}=Vr(t);if(48===s.length&&e){const t=$e.ORDER,e=nt(s),a=$e.create(e&$e.MASK);if(r){if(a!==qe)throw new Error("G1: non-empty compressed point at infinity");return{x:qe,y:qe}}const i=$e.add($e.pow(a,He),$e.create(Fr.params.G1b));let o=$e.sqrt(i);if(!o)throw new Error("Invalid compressed G1 point");return o*je/t!==BigInt(n)&&(o=$e.neg(o)),{x:$e.create(a),y:$e.create(o)}}if(96!==s.length||e)throw new Error("Invalid point G1, expected 48/96 bytes");{const t=nt(s.subarray(0,$e.BYTES)),e=nt(s.subarray($e.BYTES));if(r){if(t!==qe||e!==qe)throw new Error("G1: non-empty point at infinity");return Fr.G1.ProjectivePoint.ZERO.toAffine()}return{x:$e.create(t),y:$e.create(e)}}},toBytes:(t,e,r)=>{const n=e.equals(t.ZERO),{x:s,y:a}=e.toAffine();if(r){if(n)return Nr.slice();const t=$e.ORDER,e=Boolean(a*je/t);return Ur(at(s,$e.BYTES),{compressed:!0,sort:e})}if(n){return ut(new Uint8Array([64]),new Uint8Array(2*$e.BYTES-1))}return ut(at(s,$e.BYTES),at(a,$e.BYTES))},ShortSignature:{fromHex(t){const{infinity:e,sort:r,value:n}=Vr(ot("signatureHex",t,48)),s=$e.ORDER,a=nt(n);if(e)return Fr.G1.ProjectivePoint.ZERO;const i=$e.create(a&$e.MASK),o=$e.add($e.pow(i,He),$e.create(Fr.params.G1b));let u=$e.sqrt(o);if(!u)throw new Error("Invalid compressed G1 point");const c=BigInt(r);u*je/s!==c&&(u=$e.neg(u));const d=Fr.G1.ProjectivePoint.fromAffine({x:i,y:u});return d.assertValidity(),d},toRawBytes:t=>Lr(t),toHex:t=>W(Lr(t))}},G2:{Fp:rr,h:BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),Gx:rr.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]),Gy:rr.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")]),a:rr.ZERO,b:rr.fromBigTuple([Ke,Ke]),hEff:BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),htfDefaults:{...Cr},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:t=>{const{x:e,y:r}=vr(rr.fromBigTuple(t));return Br(e,r)},isTorsionFree:(t,e)=>e.multiplyUnsafe(Fr.params.x).negate().equals(Dr(t,e)),clearCofactor:(t,e)=>{const r=Fr.params.x;let n=e.multiplyUnsafe(r).negate(),s=Dr(t,e),a=e.double();a=_r(t,a),a=a.subtract(s),s=n.add(s),s=s.multiplyUnsafe(r).negate(),a=a.add(s),a=a.subtract(n);return a.subtract(e)},fromBytes:t=>{const{compressed:e,infinity:r,sort:n,value:s}=Vr(t);if(!e&&!r&&n||!e&&r&&n||n&&r&&e)throw new Error("Invalid encoding flag: "+(224&t[0]));const a=$e.BYTES,i=(t,e,r)=>nt(t.slice(e,r));if(96===s.length&&e){const t=Fr.params.G2b,e=$e.ORDER;if(r){if(s.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid compressed G2 point");return{x:rr.ZERO,y:rr.ZERO}}const o=i(s,0,a),u=i(s,a,2*a),c=rr.create({c0:$e.create(u),c1:$e.create(o)}),d=rr.add(rr.pow(c,He),t);let f=rr.sqrt(d);const l=f.c1===qe?f.c0*je/e:f.c1*je/e?Xe:qe;return f=n&&l>0?f:rr.neg(f),{x:c,y:f}}if(192!==s.length||e)throw new Error("Invalid point G2, expected 96/192 bytes");{if(r){if(s.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid uncompressed G2 point");return{x:rr.ZERO,y:rr.ZERO}}const t=i(s,0,a),e=i(s,a,2*a),n=i(s,2*a,3*a),o=i(s,3*a,4*a);return{x:rr.fromBigTuple([e,t]),y:rr.fromBigTuple([o,n])}}},toBytes:(t,e,r)=>{const{BYTES:n,ORDER:s}=$e,a=e.equals(t.ZERO),{x:i,y:o}=e.toAffine();if(r){if(a)return ut(Nr,at(qe,n));const t=Boolean(o.c1===qe?o.c0*je/s:o.c1*je/s);return ut(Ur(at(i.c1,n),{compressed:!0,sort:t}),at(i.c0,n))}{if(a)return ut(new Uint8Array([64]),new Uint8Array(4*n-1));const{re:t,im:e}=rr.reim(i),{re:r,im:s}=rr.reim(o);return ut(at(e,n),at(t,n),at(s,n),at(r,n))}},Signature:{fromHex(t){const{infinity:e,sort:r,value:n}=Vr(ot("signatureHex",t)),s=$e.ORDER,a=t.length/2;if(48!==a&&96!==a)throw new Error("Invalid compressed signature length, must be 96 or 192");const i=nt(n.slice(0,a)),o=nt(n.slice(a));if(e)return Fr.G2.ProjectivePoint.ZERO;const u=$e.create(i&$e.MASK),c=$e.create(o),d=rr.create({c0:c,c1:u}),f=rr.add(rr.pow(d,He),Fr.params.G2b);let l=rr.sqrt(f);if(!l)throw new Error("Failed to find a square root");const{re:h,im:p}=rr.reim(l),m=BigInt(r);(p>qe&&p*je/s!==m||p===qe&&h*je/s!==m)&&(l=rr.neg(l));const g=Fr.G2.ProjectivePoint.fromAffine({x:d,y:l});return g.assertValidity(),g},toRawBytes:t=>Mr(t),toHex:t=>W(Mr(t))}},params:{x:hr,r:ze.ORDER},htfDefaults:Cr,hash:o,randomBytes:s}),qr=48,Xr=96,jr="BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",Hr="BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";function Kr(t){return Fr.G1.ProjectivePoint.fromHex(t)}function Wr(t){return t.toRawBytes()}function Gr(t){return Fr.Signature.fromHex(t)}function Zr(t){return t.toRawBytes()}function $r(t,e,r){return Fr.verify(e,r,t,{DST:Hr})}var zr,Yr=Object.freeze({__proto__:null,PUBLIC_KEY_LENGTH:qr,SIGNATURE_LENGTH:Xr,publicKeyFromBytes:Kr,publicKeyToBytes:Wr,secretKeyFromBytes:function(t){return Fr.G1.normPrivateKeyToScalar(t)},secretKeyToBytes:function(t){return Ee(t.toString(16))},sign:function(t,e){return Fr.sign(t,e,{DST:jr})},signProofOfPossession:function(t,e){return Fr.sign(t,e,{DST:Hr})},signatureFromBytes:Gr,signatureToBytes:Zr,verify:function(t,e,r){return Fr.verify(e,r,t,{DST:jr})},verifyProofOfPossession:$r});let Jr=zr=class extends De{signature;_type=Ve.BlsSignature;constructor(t){super(),this.signature=t}static fromSignatureBytes(t){return new zr(Gr(t))}static fromBytes(t){const e=Gr(t.slice(0,Xr)),r=t.slice(Xr);return[new zr(e),r]}static fromHex(t){return new zr(Gr(Ee(t)))}toBytes(){return Zr(this.signature)}toString(){return this.signature.toHex()}toJSON(){return this.toString()}};var Qr;Jr=zr=d([t=>{},f("design:paramtypes",[Object])],Jr);let tn=Qr=class extends De{publicKey;_type=Ve.BlsPublicKey;constructor(t){super(),this.publicKey=t}static fromPublicKeyBytes(t){return new Qr(Kr(t))}static fromBytes(t){const e=Kr(t.slice(0,qr)),r=t.slice(qr);return[new Qr(e),r]}static fromHex(t){return new Qr(Kr(Ee(t)))}toBytes(){return Wr(this.publicKey)}toString(){return this.publicKey.toHex()}toJSON(){return this.toString()}};tn=Qr=d([t=>{},f("design:paramtypes",[Object])],tn);const en={encode:t=>e.encode(n(t,o(t).subarray(-4))),decode:t=>e.decode(t).subarray(0,-4)},rn=(t,e)=>{let r;for(r=0;r<t.length&&r<e.length;r++){const n=t[r],s=e[r];if(n!==s)return n-s}return r===t.length&&r===e.length?0:r===t.length?-1:1};var nn;const sn=32;let an=nn=class extends De{idVal;_type=Ve.Id;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new nn(t.slice(0,sn)),t.slice(sn)]}static compare(t,e){return rn(t.toBytes(),e.toBytes())}[l](t,e){return e.stylize(this.toString(),"string")}toBytes(){return ke(this.idVal,sn)}toJSON(){return this.toString()}toString(){return en.encode(this.toBytes())}static fromString(t){return nn.fromBytes(en.decode(t))[0]}static fromHex(t){return new nn(Ee(t))}value(){return this.toString()}};var on;an=nn=d([t=>{},f("design:paramtypes",[Uint8Array])],an);const un="NodeID-",cn=20;let dn=on=class extends De{idVal;_type=Ve.NodeId;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new on(t.slice(0,cn)),t.slice(cn)]}[l](t,e){return e.stylize(this.toString(),"string")}toBytes(){return ke(this.idVal,cn)}toJSON(){return this.toString()}toString(){return un+en.encode(this.toBytes())}static fromString(t){if(!t.includes(un))throw new Error("ID is missing prefix");return this.fromBytes(en.decode(t.replace(un,"")))[0]}static fromHex(t){return new on(Ee(t))}value(){return this.toString()}};dn=on=d([t=>{},f("design:paramtypes",[Uint8Array])],dn);const fn=new an(new Uint8Array(32)),ln=new an(new Uint8Array(32)),hn=1,pn=2,mn=3,gn=4,bn=5,yn=10,wn=12345,xn="avax",In="cascade",Bn="denali",Tn="everest",vn="fuji",On="testing",Sn="local",An="custom",En={[hn]:xn,[pn]:In,[mn]:Bn,[gn]:Tn,[bn]:vn,[yn]:On,[wn]:Sn},kn=t=>En[t]??An;var Rn,Dn=Object.freeze({__proto__:null,CascadeHRP:In,CascadeID:2,CascadeName:"cascade",DenaliHRP:Bn,DenaliID:3,DenaliName:"denali",EverestHRP:Tn,EverestID:4,EverestName:"everest",FallbackHRP:An,FujiHRP:vn,FujiID:5,FujiName:"fuji",LocalHRP:Sn,LocalID:12345,LocalName:"local",MainnetHRP:xn,MainnetID:1,MainnetName:"mainnet",NetworkIDToHRP:En,PlatformChainID:ln,PrimaryNetworkID:fn,TestnetID:5,TestnetName:"testnet",UnitTestHRP:On,UnitTestID:10,UnitTestName:"testing",getHRP:kn});class Pn{getVM(){return this.vm}}class _n extends Pn{getInputs(){return this.baseTx?.inputs??[]}getBlockchainId(){return this.baseTx?.BlockchainId.toString()??""}getSigIndices(){return this.getInputs().map((t=>t.sigIndicies())).filter((t=>void 0!==t))}}let Cn=Rn=class extends De{int;_type=Ve.Int;constructor(t){super(),this.int=t}static fromBytes(t){return[new Rn(Oe(t.slice(0,4))),t.slice(4)]}[l](){return this.value()}toJSON(){return this.int}toBytes(){return ke(Ee(this.int.toString(16)),4)}value(){return this.int}};Cn=Rn=d([t=>{},f("design:paramtypes",[Number])],Cn);const Nn=t=>new Cn(t).toBytes(),Vn=(t,e,r)=>Un(t,e.fromBytes,r),Un=(t,e,r)=>{let n;[n,t]=Cn.fromBytes(t);const s=[];for(let a=0;a<n.value();a++){if(0===t.length)throw new Error("not enough bytes");let n;[n,t]=e(t,r),s.push(n)}return[s,t]},Ln=t=>({fromBytes:(e,r)=>Vn(e,t,r)}),Mn={fromBytes:(t,e)=>{if(!e)throw new Error("codec required when using unpackCodecList");return Un(t,e.UnpackPrefix,e)}},Fn=(t,e)=>n(Nn(t.length),...t.map((t=>t.toBytes(e))));function qn(t,e,r){return[...e.map((e=>{let n;if(!t.length)throw new Error("not enough bytes");return[n,t]=e.fromBytes(t,r),n})),t]}function Xn(t,e){return n(...t.map((t=>Array.isArray(t)?Fn(t,e):t.toBytes(e))))}function jn(t,...e){return Xn(e,t)}var Hn;let Kn=Hn=class extends De{bigint;_type=Ve.BigIntPr;constructor(t){super(),this.bigint=t}[l](){return this.bigint}static fromBytes(t){return[new Hn(ve(t.slice(0,8))),t.slice(8)]}toJSON(){return this.bigint.toString()}toBytes(){return ke(Ee(this.bigint.toString(16)),8)}value(){return this.bigint}};var Wn;Kn=Hn=d([t=>{},f("design:paramtypes",[BigInt])],Kn);let Gn=Wn=class extends De{bool;_type=Ve.Bool;constructor(t){super(),this.bool=t}static fromBytes(t){return[new Wn(Se(t.slice(0,1))),t.slice(1)]}toJSON(){return this.bool.toString()}toBytes(){return ke(Ee(this.bool?"1":"0"),1)}value(){return this.bool}};var Zn;Gn=Wn=d([t=>{},f("design:paramtypes",[Boolean])],Gn);let $n=Zn=class extends De{byte;_type=Ve.Byte;constructor(t){super(),this.byte=t}static fromBytes(t){return[new Zn(t.slice(0,1)),t.slice(1)]}toJSON(){return Ae(this.byte)}toBytes(){return this.byte}};var zn;$n=Zn=d([t=>{},f("design:paramtypes",[Uint8Array])],$n);let Yn=zn=class extends De{bytes;_type=Ve.Bytes;constructor(t){super(),this.bytes=t}toString(t="utf8"){return r(t,this.bytes)}toJSON(){return Ae(this.bytes)}static fromBytes(t){const[e,r]=Cn.fromBytes(t);return[new zn(r.slice(0,e.value())),r.slice(e.value())]}toBytes(){return n(Nn(this.bytes.length),this.bytes)}get length(){return this.bytes.length}};var Jn;Yn=zn=d([t=>{},f("design:paramtypes",[Uint8Array])],Yn);let Qn=Jn=class extends De{short;_type=Ve.Short;constructor(t){super(),this.short=t}static fromBytes(t){return[new Jn(Oe(t.slice(0,2))),t.slice(2)]}toJSON(){return this.short.toString()}toBytes(){return ke(Ee(this.short.toString(16)),2)}value(){return this.short}};var ts;Qn=Jn=d([t=>{},f("design:paramtypes",[Number])],Qn);let es=ts=class extends De{string;_type=Ve.StringPr;constructor(t){super(),this.string=t}static fromBytes(t){const[e,r]=Qn.fromBytes(t);return[new ts((new TextDecoder).decode(r.slice(0,e.value()))),r.slice(e.value())]}toJSON(){return this.string}toBytes(){return n(ke(Ee(this.string.length.toString(16)),2),(new TextEncoder).encode(this.string))}value(){return this.string}};function rs(t){return t._type===Ve.TransferOutput}function ns(t){return t._type===Ve.StakeableLockOut}function ss(t){return t._type===Ve.OutputOwners}function as(t){return t._type===Ve.StakeableLockIn}function is(t){return t._type===Ve.TransferInput}var os;es=ts=d([t=>{},f("design:paramtypes",[String])],es);let us=os=class{sig;_type=Ve.Signature;constructor(t){if(this.sig=t,65!==t.length)throw new Error("incorrect number of bytes for signature")}toJSON(){return i(this.sig)}static fromJSON(t){return new os(Be(t))}static fromBytes(t){return[new os(t.slice(0,65)),t.slice(65)]}[l](t,e){return e.stylize(this.toString(),"string")}toString(){return Ae(this.sig)}toBytes(){return ke(this.sig,65)}};var cs;us=os=d([t=>{},f("design:paramtypes",[Uint8Array])],us);let ds=cs=class{signatures;_type=Ve.Credential;constructor(t){this.signatures=t}static fromBytes(t,e){const[r,n]=Vn(t,us,e);return[new cs(r),n]}toJSON(){return this.signatures}static fromJSON(t){return new cs(t.map((t=>us.fromJSON(t))))}setSignature(t,e){if(t>=this.signatures.length)throw new Error(`index ${t} is out of bounds for credential`);this.signatures[t]=new us(e)}getSignatures(){return this.signatures.map((t=>t.toString()))}toBytes(t){return Fn(this.signatures,t)}};var fs;ds=cs=d([t=>{},f("design:paramtypes",[Array])],ds);let ls=fs=class{sigIndices;_type=Ve.Input;constructor(t){this.sigIndices=t}static fromNative(t){return new fs(t.map((t=>new Cn(t))))}static fromBytes(t){const[e,r]=qn(t,[Ln(Cn)]);return[new fs(e),r]}values(){return this.sigIndices.map((t=>t.value()))}toBytes(t){return Fn(this.sigIndices,t)}};function hs(t){return t.toSorted(rn).map((t=>new Le(t)))}var ps;ls=fs=d([t=>{},f("design:paramtypes",[Array])],ls);let ms=ps=class{locktime;threshold;addrs;_type=Ve.OutputOwners;constructor(t,e,r){this.locktime=t,this.threshold=e,this.addrs=r}static fromNative(t,e=0n,r=1){return new ps(new Kn(e),new Cn(r),hs(t))}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Kn,Cn,Ln(Le)],e);return[new ps(r,n,s),a]}toBytes(t){return n(Xn([this.locktime,this.threshold],t),Fn(this.addrs,t))}equals(t){return this.locktime.value()===t.locktime.value()&&this.threshold.value()===t.threshold.value()&&this.addrs.length===t.addrs.length&&this.addrs.every(((e,r)=>e.value()===t.addrs[r].value()))}};var gs;ms=ps=d([t=>{},f("design:paramtypes",[Kn,Cn,Array])],ms);let bs=gs=class{outputOwners;_type=Ve.SecpMintOutput;constructor(t){this.outputOwners=t}static fromBytes(t,e){let r;return[r,t]=ms.fromBytes(t,e),[new gs(r),t]}toBytes(t){return this.outputOwners.toBytes(t)}};var ys;bs=gs=d([t=>{},f("design:paramtypes",[ms])],bs);let ws=ys=class{amt;outputOwners;_type=Ve.TransferOutput;constructor(t,e){this.amt=t,this.outputOwners=e}amount(){return this.amt.value()}getLocktime(){return this.outputOwners.locktime.value()}getOwners(){return this.outputOwners.addrs.map((t=>t.toBytes()))}getThreshold(){return this.outputOwners.threshold.value()}static fromBytes(t){const[e,r,n]=qn(t,[Kn,ms]);return[new ys(e,r),n]}toBytes(t){return Xn([this.amt,this.outputOwners],t)}};var xs;ws=ys=d([t=>{},f("design:paramtypes",[Kn,ms])],ws);let Is=xs=class{input;mintOutput;transferOutput;_type=Ve.SecpMintOperation;constructor(t,e,r){this.input=t,this.mintOutput=e,this.transferOutput=r}static fromBytes(t){const[e,r,n,s]=qn(t,[ls,bs,ws]);return[new xs(e,r,n),s]}toBytes(t){return n(this.input.toBytes(t),this.mintOutput.toBytes(t),this.transferOutput.toBytes(t))}};var Bs;Is=xs=d([t=>{},f("design:paramtypes",[ls,bs,ws])],Is);let Ts=Bs=class{outputOwners;_type=Ve.OutputOwnersList;constructor(t){this.outputOwners=t}static fromBytes(t,e){const[r,n]=Vn(t,ms,e);return[new Bs(r),n]}toBytes(t){return Fn(this.outputOwners,t)}};var vs;Ts=Bs=d([t=>{},f("design:paramtypes",[Array])],Ts);let Os=vs=class{amt;input;_type=Ve.TransferInput;constructor(t,e){this.amt=t,this.input=e}static fromBytes(t){const[e,r,n]=qn(t,[Kn,ls]);return[new vs(e,r),n]}static fromNative(t,e){return new vs(new Kn(t),ls.fromNative(e))}sigIndicies(){return this.input.values()}amount(){return this.amt.value()}toBytes(t){return Xn([this.amt,this.input],t)}};Os=vs=d([t=>{},f("design:paramtypes",[Kn,ls])],Os);const Ss=Object.freeze([Os,bs,ws,Is,ds]);var As;let Es=As=class{txID;outputIdx;_type=Ve.UTXOID;constructor(t,e){this.txID=t,this.outputIdx=e}static fromBytes(t,e){const[r,n,s]=qn(t,[an,Cn],e);return[new As(r,n),s]}static fromNative(t,e){return new As(an.fromString(t),new Cn(e))}static compare(t,e){const r=an.compare(t.txID,e.txID);return 0!==r?r:t.outputIdx.value()-e.outputIdx.value()}toBytes(t){return Xn([this.txID,this.outputIdx],t)}ID(){return en.encode(o(n(new Kn(BigInt(this.outputIdx.value())).toBytes(),this.txID.toBytes())))}};var ks;Es=As=d([t=>{},f("design:paramtypes",[an,Cn])],Es);let Rs=ks=class{utxoID;assetId;input;_type=Ve.TransferableInput;constructor(t,e,r){this.utxoID=t,this.assetId=e,this.input=r}static fromBytes(t,e){const[r,n,s]=qn(t,[Es,an]),[a,i]=e.UnpackPrefix(s);return[new ks(r,n,a),i]}static fromNative(t,e,r,n,s){return new ks(Es.fromNative(t,e),an.fromString(r),new Os(new Kn(n),new ls(s.map((t=>new Cn(t))))))}static fromUtxoAndSigindicies(t,e){const r=t.output;if(!rs(r))throw new Error("utxo.output must be Transferout");return new ks(t.utxoId,t.assetId,Os.fromNative(r.amount(),e))}sigIndicies(){const t=this.input;if(is(t))return t.sigIndicies();if(as(t)){const e=t.transferableInput;if(is(e))return e.sigIndicies()}throw new Error("Input must be TransferInput or StakeableLockIn")}static compare(t,e){return Es.compare(t.utxoID,e.utxoID)}amount(){return this.input.amount()}getAssetId(){return this.assetId.toString()}toBytes(t){return n(Xn([this.utxoID,this.assetId],t),t.PackPrefix(this.input))}};var Ds;Rs=ks=d([t=>{},f("design:paramtypes",[Es,an,Object])],Rs);let Ps=Ds=class{assetId;output;_type=Ve.TransferableOutput;constructor(t,e){this.assetId=t,this.output=e}static fromNative(t,e,r,n,s){return new Ds(an.fromString(t),new ws(new Kn(e),ms.fromNative(r,n,s)))}static fromBytes(t,e){const[r,n]=qn(t,[an],e),[s,a]=e.UnpackPrefix(n);return[new Ds(r,s),a]}getAssetId(){return this.assetId.toString()}amount(){return this.output.amount()}toBytes(t){return n(Xn([this.assetId],t),t.PackPrefix(this.output))}};var _s;Ps=Ds=d([t=>{},f("design:paramtypes",[an,Object])],Ps);let Cs=_s=class{NetworkId;BlockchainId;outputs;inputs;memo;_type=Ve.BaseTx;constructor(t,e,r,n,s){this.NetworkId=t,this.BlockchainId=e,this.outputs=r,this.inputs=n,this.memo=s}static fromBytes(t,e){const[r,n,s,a,i,o]=qn(t,[Cn,an,Ln(Ps),Ln(Rs),Yn],e);return[new _s(r,n,s,a,i),o]}static fromNative(t,e,r,n,s){return new _s(new Cn(t),an.fromString(e),r,n,new Yn(s))}toBytes(t){return n(Xn([this.NetworkId,this.BlockchainId],t),Fn(this.outputs,t),Fn(this.inputs,t),this.memo.toBytes())}};Cs=_s=d([t=>{},f("design:paramtypes",[Cn,an,Array,Array,Yn])],Cs);class Ns extends _n{vm=Pe}var Vs;let Us=Vs=class extends Ns{baseTx;_type=Ve.AvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,n]=qn(t,[Cs],e);return[new Vs(r),n]}toBytes(t){return this.baseTx.toBytes(t)}};Us=Vs=d([t=>{},f("design:paramtypes",[Cs])],Us);let Ls=class{typeIdToType;_type=Ve.Codec;typeToTypeID;constructor(t){this.typeIdToType=t,this.typeToTypeID=t.reduce(((t,e,r)=>e?t.set((new e)._type,r):t),new Map)}PackPrefix=t=>{const e=this.typeToTypeID.get(t._type);if(void 0===e)throw new Error(`can't marshal unregistered type: ${t._type.toString()}`);return n(Nn(e),t.toBytes(this))};UnpackPrefix=t=>{let e;[e,t]=qn(t,[Cn]);const r=this.typeIdToType[e.value()];if(void 0===r)throw new Error(`couldn't unmarshal interface: unknown type ID ${e.value()}`);const[n,s]=r.fromBytes(t,this);return[n,s]};static fromBytes(t,e){if(!e)throw new Error("codec required");return e.UnpackPrefix(t)}toBytes(){throw new Error("not implemented")}PackPrefixList(t){return n(Nn(t.length),...t.map((t=>this.PackPrefix(t))))}};Ls=d([t=>{},f("design:paramtypes",[Array])],Ls);class Ms{codecs={};RegisterCodec(t,e){if(t in this.codecs)throw new Error("duplicated codec version");this.codecs[t]=e}unpack=(t,e)=>{const[r,n]=this.getCodecFromBuffer(t);return e.fromBytes(n,r)[0]};unpackTransaction=t=>{const[e,r]=this.getCodecFromBuffer(t);return e.UnpackPrefix(r)[0]};getCodecFromBuffer(t){const[e,r]=qn(t,[Qn]);return[this.getCodecForVersion(e),r]}getCodecForVersion(t){if(!this.codecs[t.value()])throw new Error(`codec id(${t.value()}) not found`);return this.codecs[t.value()]}getDefaultCodec(){return this.getCodecForVersion(new Qn(0))}getDefaultCodecId(){return new Qn(0)}packCodec(t,e=0){const r=new Qn(e),s=this.getCodecForVersion(r);return n(r.toBytes(),s.PackPrefix(t))}}var Fs;let qs=Fs=class{input;groupId;payload;outputOwnerList;_type=Ve.NftFxMintOperation;constructor(t,e,r,n){this.input=t,this.groupId=e,this.payload=r,this.outputOwnerList=n}static fromBytes(t){const[e,r,n,s,a]=qn(t,[ls,Cn,Yn,Ts]);return[new Fs(e,r,n,s),a]}toBytes(t){return Xn([this.input,this.groupId,this.payload,this.outputOwnerList],t)}};var Xs;qs=Fs=d([t=>{},f("design:paramtypes",[ls,Cn,Yn,Ts])],qs);let js=Xs=class{groupId;outputOwners;_type=Ve.NftFxMintOutput;constructor(t,e){this.groupId=t,this.outputOwners=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Cn,ms],e);return[new Xs(r,n),s]}toBytes(t){return Xn([this.groupId,this.outputOwners],t)}};var Hs;js=Xs=d([t=>{},f("design:paramtypes",[Cn,ms])],js);let Ks=Hs=class{groupId;payload;outputOwners;_type=Ve.NftFxTransferOutput;constructor(t,e,r){this.groupId=t,this.payload=e,this.outputOwners=r}static fromBytes(t){const[e,r,n,s]=qn(t,[Cn,Yn,ms]);return[new Hs(e,r,n),s]}toBytes(t){return Xn([this.groupId,this.payload,this.outputOwners],t)}};var Ws;Ks=Hs=d([t=>{},f("design:paramtypes",[Cn,Yn,ms])],Ks);let Gs=Ws=class{input;output;_type=Ve.NftFxTransferOperation;constructor(t,e){this.input=t,this.output=e}static fromBytes(t){const[e,r,n]=qn(t,[ls,Ks]);return[new Ws(e,r),n]}toBytes(t){return Xn([this.input,this.output],t)}};Gs=Ws=d([t=>{},f("design:paramtypes",[ls,Ks])],Gs);const Zs=Object.freeze([js,Ks,qs,Gs,class extends ds{_type=Ve.NftFxCredential}]);var $s;let zs=$s=class{fxId;outputs;_type=Ve.InitialState;constructor(t,e){this.fxId=t,this.outputs=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Cn,Mn],e);return[new $s(r,n),s]}toBytes(t){return n(this.fxId.toBytes(),t.PackPrefixList(this.outputs))}};var Ys;zs=$s=d([t=>{},f("design:paramtypes",[Cn,Array])],zs);let Js=Ys=class{baseTx;name;symbol;denomination;initialStates;_type=Ve.CreateAssetTx;constructor(t,e,r,n,s){this.baseTx=t,this.name=e,this.symbol=r,this.denomination=n,this.initialStates=s}static fromBytes(t,e){const[r,n,s,a,i,o]=qn(t,[Cs,es,es,$n,Ln(zs)],e);return[new Ys(r,n,s,a,i),o]}toBytes(t){return n(Xn([this.baseTx,this.name,this.symbol,this.denomination],t),Fn(this.initialStates,t))}};var Qs;Js=Ys=d([t=>{},f("design:paramtypes",[Cs,es,es,$n,Array])],Js);let ta=Qs=class extends Ns{baseTx;destination;outs;_type=Ve.AvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Ln(Ps)],e);return[new Qs(r,n,s),a]}toBytes(t){return n(Xn([this.baseTx,this.destination],t),Fn(this.outs,t))}};var ea;ta=Qs=d([t=>{},f("design:paramtypes",[Cs,an,Array])],ta);let ra=ea=class extends Ns{baseTx;sourceChain;ins;_type=Ve.AvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies())).concat(super.getSigIndices())}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Ln(Rs)],e);return[new ea(r,n,s),a]}toBytes(t){return n(Xn([this.baseTx,this.sourceChain],t),Fn(this.ins,t))}};var na;ra=ea=d([t=>{},f("design:paramtypes",[Cs,an,Array])],ra);let sa=na=class{assetId;UTXOId;transferOp;_type=Ve.TransferableOp;constructor(t,e,r){this.assetId=t,this.UTXOId=e,this.transferOp=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[an,Ln(Es),Ls],e);return[new na(r,n,s),a]}toBytes(t){return n(Xn([this.assetId],t),Fn(this.UTXOId,t),t.PackPrefix(this.transferOp))}};var aa;sa=na=d([t=>{},f("design:paramtypes",[an,Array,Object])],sa);let ia,oa=aa=class{baseTx;ops;_type=Ve.OperationTx;constructor(t,e){this.baseTx=t,this.ops=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Cs,Ln(sa)],e);return[new aa(r,n),s]}toBytes(t){return n(this.baseTx.toBytes(t),Fn(this.ops,t))}};oa=aa=d([t=>{},f("design:paramtypes",[Cs,Array])],oa);const ua=()=>ia||(ia=new Ms,ia.RegisterCodec(0,new Ls([Us,Js,oa,ra,ta,...Ss,...Zs])),ia);class ca extends Pn{vm=_e;getBlockchainId=()=>this.blockchainId.toString()}var da;let fa=class{static{da=this}address;amount;assetId;nonce;_type=Ve.EvmInput;constructor(t,e,r,n){this.address=t,this.amount=e,this.assetId=r,this.nonce=n}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Le,Kn,an,Kn],e);return[new da(r,n,s,a),i]}static compare=(t,e)=>t.address.value()!==e.address.value()?t.address.value().localeCompare(e.address.value()):t.assetId.value().localeCompare(e.assetId.value());toBytes(t){return jn(t,this.address,this.amount,this.assetId,this.nonce)}};var la;fa=da=d([t=>{},f("design:paramtypes",[Le,Kn,an,Kn])],fa);let ha=la=class extends ca{networkId;blockchainId;destinationChain;ins;exportedOutputs;_type=Ve.EvmExportTx;constructor(t,e,r,n,s){super(),this.networkId=t,this.blockchainId=e,this.destinationChain=r,this.ins=n,this.exportedOutputs=s}getSigIndices(){return[[0]]}static fromBytes(t,e){const[r,n,s,a,i,o]=qn(t,[Cn,an,an,Ln(fa),Ln(Ps)],e);return[new la(r,n,s,a,i),o]}toBytes(t){return jn(t,this.networkId,this.blockchainId,this.destinationChain,this.ins,this.exportedOutputs)}};var pa;ha=la=d([t=>{},f("design:paramtypes",[Cn,an,an,Array,Array])],ha);let ma=pa=class{address;amount;assetId;_type=Ve.EvmOutput;constructor(t,e,r){this.address=t,this.amount=e,this.assetId=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Le,Kn,an],e);return[new pa(r,n,s),a]}toBytes(t){return jn(t,this.address,this.amount,this.assetId)}};var ga;ma=pa=d([t=>{},f("design:paramtypes",[Le,Kn,an])],ma);let ba,ya=ga=class extends ca{networkId;blockchainId;sourceChain;importedInputs;Outs;_type=Ve.EvmImportTx;constructor(t,e,r,n,s){super(),this.networkId=t,this.blockchainId=e,this.sourceChain=r,this.importedInputs=n,this.Outs=s}getSigIndices(){return this.importedInputs.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,n,s,a,i,o]=qn(t,[Cn,an,an,Ln(Rs),Ln(ma)],e);return[new ga(r,n,s,a,i),o]}toBytes(t){return jn(t,this.networkId,this.blockchainId,this.sourceChain,this.importedInputs,this.Outs)}};ya=ga=d([t=>{},f("design:paramtypes",[Cn,an,an,Array,Array])],ya);const wa=new Ls([ya,ha,...Array(3).fill(void 0),...Ss,ls,ms]),xa=()=>ba||(ba=new Ms,ba.RegisterCodec(0,wa),ba);class Ia extends _n{vm=Ce}var Ba;let Ta=Ba=class{nodeId;startTime;endTime;weight;_type=Ve.Validator;constructor(t,e,r,n){this.nodeId=t,this.startTime=e,this.endTime=r,this.weight=n}static fromNative(t,e,r,n){return new Ba(dn.fromString(t),new Kn(e),new Kn(r),new Kn(n))}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[dn,Kn,Kn,Kn],e);return[new Ba(r,n,s,a),i]}toBytes(t){return Xn([this.nodeId,this.startTime,this.endTime,this.weight],t)}};var va;Ta=Ba=d([t=>{},f("design:paramtypes",[dn,Kn,Kn,Kn])],Ta);let Oa=va=class extends Ia{baseTx;validator;stake;rewardsOwner;_type=Ve.AddDelegatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=n}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Cs,Ta,Ln(Ps),Ls],e);return[new va(r,n,s,a),i]}toBytes(t){return n(Xn([this.baseTx,this.validator,this.stake],t),t.PackPrefix(this.rewardsOwner))}};Oa=va=d([t=>{},f("design:paramtypes",[Cs,Ta,Array,Object])],Oa);class Sa extends Ia{getSubnetAuth(){return this.subnetAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getSubnetAuth().values()].filter((t=>void 0!==t))}}var Aa;let Ea=Aa=class{validator;subnetId;_type=Ve.SubnetValidator;constructor(t,e){this.validator=t,this.subnetId=e}static fromNative(t,e,r,n,s){return new Aa(Ta.fromNative(t,e,r,n),s)}static fromBytes(t,e){const[r,n,s]=qn(t,[Ta,an],e);return[new Aa(r,n),s]}toBytes(t){return Xn([this.validator,this.subnetId],t)}};var ka;Ea=Aa=d([t=>{},f("design:paramtypes",[Ta,an])],Ea);let Ra=ka=class extends Sa{baseTx;subnetValidator;subnetAuth;_type=Ve.AddSubnetValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.subnetValidator=e,this.subnetAuth=r}getSubnetID(){return this.subnetValidator.subnetId}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,Ea,Ls],e);return[new ka(r,n,s),a]}toBytes(t){return n(Xn([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.subnetAuth))}};var Da;Ra=ka=d([t=>{},f("design:paramtypes",[Cs,Ea,Object])],Ra);let Pa=Da=class extends Ia{baseTx;validator;stake;rewardsOwner;shares;_type=Ve.AddValidatorTx;constructor(t,e,r,n,s){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=n,this.shares=s}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,n,s,a,i,o]=qn(t,[Cs,Ta,Ln(Ps),Ls,Cn],e);return[new Da(r,n,s,a,i),o]}toBytes(t){return n(Xn([this.baseTx,this.validator],t),Fn(this.stake,t),t.PackPrefix(this.rewardsOwner),this.shares.toBytes())}};var _a;Pa=Da=d([t=>{},f("design:paramtypes",[Cs,Ta,Array,Object,Cn])],Pa);let Ca=_a=class extends Ia{time;_type=Ve.AdvanceTimeTx;constructor(t){super(),this.time=t}baseTx=void 0;static fromBytes(t,e){const[r,n]=qn(t,[Kn],e);return[new _a(r),n]}toBytes(t){return jn(t,this.time)}};var Na;Ca=_a=d([t=>{},f("design:paramtypes",[Kn])],Ca);let Va=Na=class extends Sa{baseTx;subnetID;chainName;vmID;fxIds;genesisData;subnetAuth;_type=Ve.CreateChainTx;constructor(t,e,r,n,s,a,i){super(),this.baseTx=t,this.subnetID=e,this.chainName=r,this.vmID=n,this.fxIds=s,this.genesisData=a,this.subnetAuth=i}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,n,s,a,i,o,u,c]=qn(t,[Cs,an,es,an,Ln(an),Yn,Ls],e);return[new Na(r,n,s,a,i,o,u),c]}toBytes(t){return n(Xn([this.baseTx,this.subnetID,this.chainName,this.vmID],t),Fn(this.fxIds,t),this.genesisData.toBytes(),t.PackPrefix(this.subnetAuth))}};var Ua;Va=Na=d([t=>{},f("design:paramtypes",[Cs,an,es,an,Array,Yn,Object])],Va);let La=Ua=class extends Ia{baseTx;subnetOwners;_type=Ve.CreateSubnetTx;constructor(t,e){super(),this.baseTx=t,this.subnetOwners=e}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,n,s]=qn(t,[Cs,Ls],e);return[new Ua(r,n),s]}toBytes(t){return n(Xn([this.baseTx],t),t.PackPrefix(this.subnetOwners))}};var Ma;La=Ua=d([t=>{},f("design:paramtypes",[Cs,Object])],La);let Fa=Ma=class extends Ia{baseTx;destination;outs;_type=Ve.PvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Ln(Ps)],e);return[new Ma(r,n,s),a]}toBytes(t){return jn(t,this.baseTx,this.destination,this.outs)}};var qa;Fa=Ma=d([t=>{},f("design:paramtypes",[Cs,an,Array])],Fa);let Xa=qa=class extends Ia{baseTx;sourceChain;ins;_type=Ve.PvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Ln(Rs)],e);return[new qa(r,n,s),a]}toBytes(t){return Xn([this.baseTx,this.sourceChain,this.ins],t)}};var ja;Xa=qa=d([t=>{},f("design:paramtypes",[Cs,an,Array])],Xa);let Ha=ja=class extends Ia{txId;_type=Ve.RewardValidatorTx;constructor(t){super(),this.txId=t}baseTx=void 0;static fromBytes(t,e){const[r,n]=qn(t,[an],e);return[new ja(r),n]}toBytes(t){return jn(t,this.txId)}};var Ka;Ha=ja=d([t=>{},f("design:paramtypes",[an])],Ha);let Wa=Ka=class{lockTime;transferableInput;_type=Ve.StakeableLockIn;constructor(t,e){this.lockTime=t,this.transferableInput=e}static fromBytes(t,e){const[r,n]=qn(t,[Kn],e),[s,a]=e.UnpackPrefix(n);return[new Ka(r,s),a]}amount(){return this.transferableInput.amount()}toBytes(t){return n(jn(t,this.lockTime),t.PackPrefix(this.transferableInput))}};var Ga;Wa=Ka=d([t=>{},f("design:paramtypes",[Kn,Object])],Wa);let Za=Ga=class{lockTime;transferOut;_type=Ve.StakeableLockOut;constructor(t,e){this.lockTime=t,this.transferOut=e}amount(){return this.transferOut.amount()}getStakeableLocktime(){return this.lockTime.value()}getLocktime(){return this.lockTime.value()}static fromBytes(t,e){const[r,n,s]=qn(t,[Kn,Ls],e);return[new Ga(r,n),s]}getOwners(){if(rs(this.transferOut))return this.transferOut.getOwners();throw new Error("Unable to get owners.")}getOutputOwners(){if(rs(this.transferOut))return this.transferOut.outputOwners;throw new Error("Unable to get output owners.")}toBytes(t){return n(jn(t,this.lockTime),t.PackPrefix(this.transferOut))}};var $a;Za=Ga=d([t=>{},f("design:paramtypes",[Kn,Object])],Za);let za=$a=class extends Ia{baseTx;subnetValidator;signer;stake;validatorRewardsOwner;delegatorRewardsOwner;shares;_type=Ve.AddPermissionlessValidatorTx;constructor(t,e,r,n,s,a,i){super(),this.baseTx=t,this.subnetValidator=e,this.signer=r,this.stake=n,this.validatorRewardsOwner=s,this.delegatorRewardsOwner=a,this.shares=i}getValidatorRewardsOwner(){return this.validatorRewardsOwner}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,n,s,a,i,o,u,c]=qn(t,[Cs,Ea,Ls,Ln(Ps),Ls,Ls,Cn],e);return[new $a(r,n,s,a,i,o,u),c]}toBytes(t){return n(Xn([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.signer),Fn(this.stake,t),t.PackPrefix(this.validatorRewardsOwner),t.PackPrefix(this.delegatorRewardsOwner),this.shares.toBytes())}};var Ya;za=$a=d([t=>{},f("design:paramtypes",[Cs,Ea,Function,Array,Object,Object,Cn])],za);let Ja=Ya=class extends Ia{baseTx;subnetValidator;stake;delegatorRewardsOwner;_type=Ve.AddPermissionlessDelegatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.subnetValidator=e,this.stake=r,this.delegatorRewardsOwner=n}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Cs,Ea,Ln(Ps),Ls],e);return[new Ya(r,n,s,a),i]}toBytes(t){return n(Xn([this.baseTx,this.subnetValidator],t),Fn(this.stake,t),t.PackPrefix(this.delegatorRewardsOwner))}};Ja=Ya=d([t=>{},f("design:paramtypes",[Cs,Ea,Array,Object])],Ja);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const Qa=2n**256n,ti=Qa-0x1000003d1n,ei=Qa-0x14551231950b75fc4402da1732fc9bebfn,ri=0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,ni=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,si={p:ti,n:ei,a:0n,b:7n,Gx:ri,Gy:ni},ai=32,ii=t=>mi(mi(t*t)*t+si.b),oi=(t="")=>{throw new Error(t)},ui=t=>"bigint"==typeof t,ci=t=>"string"==typeof t,di=t=>ui(t)&&0n<t&&t<ti,fi=t=>ui(t)&&0n<t&&t<ei,li=(t,e)=>!(t instanceof Uint8Array)||"number"==typeof e&&e>0&&t.length!==e?oi("Uint8Array expected"):t,hi=t=>new Uint8Array(t),pi=(t,e)=>li(ci(t)?Ti(t):hi(t),e),mi=(t,e=ti)=>{let r=t%e;return r>=0n?r:e+r},gi=t=>t instanceof yi?t:oi("Point expected");let bi;class yi{constructor(t,e,r){this.px=t,this.py=e,this.pz=r}static fromAffine(t){return new yi(t.x,t.y,1n)}static fromHex(t){let e;const r=(t=pi(t))[0],n=t.subarray(1),s=Oi(n,0,ai),a=t.length;if(33===a&&[2,3].includes(r)){di(s)||oi("Point hex invalid: x not FE");let t=Ri(ii(s));!(1&~r)!==(1n===(1n&t))&&(t=mi(-t)),e=new yi(s,t,1n)}return 65===a&&4===r&&(e=new yi(s,Oi(n,ai,64),1n)),e?e.ok():oi("Point is not on curve")}static fromPrivateKey(t){return wi.mul(Di(t))}get x(){return this.aff().x}get y(){return this.aff().y}equals(t){const{px:e,py:r,pz:n}=this,{px:s,py:a,pz:i}=gi(t),o=mi(e*i),u=mi(s*n),c=mi(r*i),d=mi(a*n);return o===u&&c===d}negate(){return new yi(this.px,mi(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:e,py:r,pz:n}=this,{px:s,py:a,pz:i}=gi(t),{a:o,b:u}=si;let c=0n,d=0n,f=0n;const l=mi(3n*u);let h=mi(e*s),p=mi(r*a),m=mi(n*i),g=mi(e+r),b=mi(s+a);g=mi(g*b),b=mi(h+p),g=mi(g-b),b=mi(e+n);let y=mi(s+i);return b=mi(b*y),y=mi(h+m),b=mi(b-y),y=mi(r+n),c=mi(a+i),y=mi(y*c),c=mi(p+m),y=mi(y-c),f=mi(o*b),c=mi(l*m),f=mi(c+f),c=mi(p-f),f=mi(p+f),d=mi(c*f),p=mi(h+h),p=mi(p+h),m=mi(o*m),b=mi(l*b),p=mi(p+m),m=mi(h-m),m=mi(o*m),b=mi(b+m),h=mi(p*b),d=mi(d+h),h=mi(y*b),c=mi(g*c),c=mi(c-h),h=mi(g*p),f=mi(y*f),f=mi(f+h),new yi(c,d,f)}mul(t,e=!0){if(!e&&0n===t)return xi;if(fi(t)||oi("invalid scalar"),this.equals(wi))return Ki(t).p;let r=xi,n=wi;for(let s=this;t>0n;s=s.double(),t>>=1n)1n&t?r=r.add(s):e&&(n=n.add(s));return r}mulAddQUns(t,e,r){return this.mul(e,!1).add(t.mul(r,!1)).ok()}toAffine(){const{px:t,py:e,pz:r}=this;if(this.equals(xi))return{x:0n,y:0n};if(1n===r)return{x:t,y:e};const n=ki(r);return 1n!==mi(r*n)&&oi("invalid inverse"),{x:mi(t*n),y:mi(e*n)}}assertValidity(){const{x:t,y:e}=this.aff();return di(t)&&di(e)||oi("Point invalid: x or y"),mi(e*e)===ii(t)?this:oi("Point invalid: not on curve")}multiply(t){return this.mul(t)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(t=!0){const{x:e,y:r}=this.aff();return(t?0n===(1n&r)?"02":"03":"04")+Ai(e)+(t?"":Ai(r))}toRawBytes(t=!0){return Ti(this.toHex(t))}}yi.BASE=new yi(ri,ni,1n),yi.ZERO=new yi(0n,1n,0n);const{BASE:wi,ZERO:xi}=yi,Ii=(t,e)=>t.toString(16).padStart(e,"0"),Bi=t=>Array.from(t).map((t=>Ii(t,2))).join(""),Ti=t=>{const e=t.length;(!ci(t)||e%2)&&oi("hex invalid 1");const r=hi(e/2);for(let e=0;e<r.length;e++){const n=2*e,s=t.slice(n,n+2),a=Number.parseInt(s,16);(Number.isNaN(a)||a<0)&&oi("hex invalid 2"),r[e]=a}return r},vi=t=>BigInt("0x"+(Bi(t)||"0")),Oi=(t,e,r)=>vi(t.slice(e,r)),Si=t=>ui(t)&&t>=0n&&t<Qa?Ti(Ii(t,64)):oi("bigint expected"),Ai=t=>Bi(Si(t)),Ei=(...t)=>{const e=hi(t.reduce(((t,e)=>t+li(e).length),0));let r=0;return t.forEach((t=>{e.set(t,r),r+=t.length})),e},ki=(t,e=ti)=>{(0n===t||e<=0n)&&oi("no inverse n="+t+" mod="+e);let r=mi(t,e),n=e,s=0n,a=1n;for(;0n!==r;){const t=n%r,e=s-a*(n/r);n=r,r=t,s=a,a=e}return 1n===n?mi(s,e):oi("no inverse")},Ri=t=>{let e=1n;for(let r=t,n=(ti+1n)/4n;n>0n;n>>=1n)1n&n&&(e=e*r%ti),r=r*r%ti;return mi(e*e)===t?e:oi("sqrt invalid")},Di=t=>(ui(t)||(t=vi(pi(t,ai))),fi(t)?t:oi("private key out of range")),Pi=t=>t>ei>>1n;class _i{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){return t=pi(t,64),new _i(Oi(t,0,ai),Oi(t,ai,64))}assertValidity(){return fi(this.r)&&fi(this.s)?this:oi()}addRecoveryBit(t){return new _i(this.r,this.s,t)}hasHighS(){return Pi(this.s)}recoverPublicKey(t){const{r:e,s:r,recovery:n}=this;[0,1,2,3].includes(n)||oi("recovery id invalid");const s=Ni(pi(t,32)),a=2===n||3===n?e+ei:e;a>=ti&&oi("q.x invalid");const i=1&n?"03":"02",o=yi.fromHex(i+Ai(a)),u=ki(a,ei),c=mi(-s*u,ei),d=mi(r*u,ei);return wi.mulAddQUns(o,c,d)}toCompactRawBytes(){return Ti(this.toCompactHex())}toCompactHex(){return Ai(this.r)+Ai(this.s)}}const Ci=t=>{const e=8*t.length-256,r=vi(t);return e>0?r>>BigInt(e):r},Ni=t=>mi(Ci(t),ei),Vi=t=>Si(t),Ui=()=>"object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;let Li;const Mi={lowS:!0},Fi={lowS:!0};async function qi(t,e,r=Mi){const{seed:n,k2sig:s}=function(t,e,r=Mi){["der","recovered","canonical"].some((t=>t in r))&&oi("sign() legacy options not supported");let{lowS:n}=r;null==n&&(n=!0);const s=Ni(pi(t)),a=Vi(s),i=Di(e),o=[Vi(i),a];let u=r.extraEntropy;if(u){!0===u&&(u=ji.randomBytes(ai));const t=pi(u);t.length!==ai&&oi(),o.push(t)}const c=s;return{seed:Ei(...o),k2sig:t=>{const e=Ci(t);if(!fi(e))return;const r=ki(e,ei),s=wi.mul(e).aff(),a=mi(s.x,ei);if(0n===a)return;const o=mi(r*mi(c+mi(i*a,ei),ei),ei);if(0n===o)return;let u=o,d=(s.x===a?0:2)|Number(1n&s.y);return n&&Pi(o)&&(u=mi(-o,ei),d^=1),new _i(a,u,d)}}}(t,e,r);return function(t){let e=hi(ai),r=hi(ai),n=0;const s=()=>{e.fill(1),r.fill(0),n=0},a="drbg: tried 1000 values";if(t){const t=(...t)=>ji.hmacSha256Async(r,e,...t),i=async(n=hi())=>{r=await t(hi([0]),n),e=await t(),0!==n.length&&(r=await t(hi([1]),n),e=await t())},o=async()=>(n++>=1e3&&oi(a),e=await t(),e);return async(t,e)=>{let r;for(s(),await i(t);!(r=e(await o()));)await i();return s(),r}}{const t=(...t)=>{const n=Li;return n||oi("etc.hmacSha256Sync not set"),n(r,e,...t)},i=(n=hi())=>{r=t(hi([0]),n),e=t(),0!==n.length&&(r=t(hi([1]),n),e=t())},o=()=>(n++>=1e3&&oi(a),e=t(),e);return(t,e)=>{let r;for(s(),i(t);!(r=e(o()));)i();return s(),r}}}(!0)(n,s)}function Xi(t){((t=pi(t)).length<40||t.length>1024)&&oi("expected proper params");const e=mi(vi(t),ei-1n)+1n;return Si(e)}const ji={hexToBytes:Ti,bytesToHex:Bi,concatBytes:Ei,bytesToNumberBE:vi,numberToBytesBE:Si,mod:mi,invert:ki,hmacSha256Async:async(t,...e)=>{const r=Ui();if(!r)return oi("etc.hmacSha256Async not set");const n=r.subtle,s=await n.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return hi(await n.sign("HMAC",s,Ei(...e)))},hmacSha256Sync:Li,hashToPrivateKey:Xi,randomBytes:t=>{const e=Ui();return e||oi("crypto.getRandomValues must be defined"),e.getRandomValues(hi(t))}},Hi={normPrivateKeyToScalar:Di,isValidPrivateKey:t=>{try{return!!Di(t)}catch(t){return!1}},randomPrivateKey:()=>Xi(ji.randomBytes(40)),precompute:(t=8,e=wi)=>(e.multiply(3n),e)};Object.defineProperties(ji,{hmacSha256Sync:{configurable:!1,get:()=>Li,set(t){Li||(Li=t)}}});const Ki=t=>{const e=bi||(bi=(()=>{const t=[];let e=wi,r=e;for(let n=0;n<33;n++){r=e,t.push(r);for(let n=1;n<128;n++)r=r.add(e),t.push(r);e=r.double()}return t})()),r=(t,e)=>{let r=e.negate();return t?r:e};let n=xi,s=wi;const a=BigInt(255),i=BigInt(8);for(let o=0;o<33;o++){const u=128*o;let c=Number(t&a);t>>=i,c>128&&(c-=256,t+=1n);const d=u,f=u+Math.abs(c)-1,l=o%2!=0,h=c<0;0===c?s=s.add(r(l,e[d])):n=n.add(r(h,e[f]))}return{p:n,f:s}};function Wi(t,e){return Gi(o(t),e)}async function Gi(t,e){const r=await qi(t,e);if(void 0!==r.recovery)return n(r.toCompactRawBytes(),new Uint8Array([r.recovery]));throw new Error("Recovery bit is missing.")}function Zi(t,e){const r=e.slice(-1);return _i.fromCompact(e.slice(0,-1)).addRecoveryBit(r[0]).recoverPublicKey(t).toRawBytes(!0)}function $i(t){return function(t,e=!0){return yi.fromPrivateKey(t).toRawBytes(e)}(t,!0)}function zi(t){return u(o(t))}function Yi(t){return Ee(Te.fromPublicKey(t))}var Ji,Qi=Object.freeze({__proto__:null,SIGNATURE_LENGTH:65,getPublicKey:$i,publicKeyBytesToAddress:zi,publicKeyToEthAddress:Yi,randomPrivateKey:function(){return Hi.randomPrivateKey()},recoverPublicKey:Zi,sign:Wi,signHash:Gi,verify:function(t,e,r){return function(t,e,r,n=Fi){let s,a,i,{lowS:o}=n;null==o&&(o=!0),"strict"in n&&oi("verify() legacy options not supported");const u=t&&"object"==typeof t&&"r"in t;u||64===pi(t).length||oi("signature must be 64 bytes");try{s=u?new _i(t.r,t.s).assertValidity():_i.fromCompact(t),a=Ni(pi(e,ai)),i=r instanceof yi?r.ok():yi.fromHex(r)}catch(t){return!1}if(!s)return!1;const{r:c,s:d}=s;if(o&&Pi(d))return!1;let f;try{const t=ki(d,ei),e=mi(a*t,ei),r=mi(c*t,ei);f=wi.mulAddQUns(i,e,r).aff()}catch(t){return!1}return!!f&&mi(f.x,ei)===c}(t.slice(0,-1),e,r)}});let to=Ji=class{publicKey;signature;_type=Ve.ProofOfPossession;constructor(t,e){this.publicKey=t,this.signature=e;const r=Kr(t),n=Gr(e);if(r.assertValidity(),n.assertValidity(),!$r(r,n,Wr(r)))throw new Error("Invalid proof of possession")}static fromBytes(t){const e=t.slice(0,qr),r=t.slice(qr,144),n=t.slice(144);return[new Ji(e,r),n]}toString(){return Ae(this.toBytes())}toBytes(){return n(this.publicKey,this.signature)}};var eo,ro;to=Ji=d([t=>{},f("design:paramtypes",[Uint8Array,Uint8Array])],to);let no=eo=class{proof;_type=Ve.Signer;constructor(t){this.proof=t}static fromBytes(t,e){const[r,n]=qn(t,[to],e);return[new eo(r),n]}toBytes(t){return Xn([this.proof],t)}};no=eo=d([t=>{},f("design:paramtypes",[to])],no);let so=ro=class{_type=Ve.SignerEmpty;static fromBytes(t,e){const[r]=qn(t,[],e);return[new ro,r]}toBytes(t){return Xn([],t)}};var ao;so=ro=d([t=>{}],so);let io=ao=class extends Sa{baseTx;nodeId;subnetId;subnetAuth;_type=Ve.RemoveSubnetValidatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.nodeId=e,this.subnetId=r,this.subnetAuth=n}getSubnetID(){return this.subnetId}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Cs,dn,an,Ls],e);return[new ao(r,n,s,a),i]}toBytes(t){return n(Xn([this.baseTx,this.nodeId,this.subnetId],t),t.PackPrefix(this.subnetAuth))}};var oo;io=ao=d([t=>{},f("design:paramtypes",[Cs,dn,an,Object])],io);let uo=oo=class extends Sa{baseTx;subnetID;subnetAuth;subnetOwners;_type=Ve.TransferSubnetOwnershipTx;constructor(t,e,r,n){super(),this.baseTx=t,this.subnetID=e,this.subnetAuth=r,this.subnetOwners=n}getSubnetID(){return this.subnetID}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Cs,an,Ls,Ls],e);return[new oo(r,n,s,a),i]}toBytes(t){return n(Xn([this.baseTx,this.subnetID],t),t.PackPrefix(this.subnetAuth),t.PackPrefix(this.subnetOwners))}};var co;uo=oo=d([t=>{},f("design:paramtypes",[Cs,an,Object,Object])],uo);let fo=co=class extends Sa{baseTx;subnetID;assetId;initialSupply;maximumSupply;minConsumptionRate;maxConsumptionRate;minValidatorStake;maxValidatorStake;minStakeDuration;maxStakeDuration;minDelegationFee;minDelegatorStake;maxValidatorWeightFactor;uptimeRequirement;subnetAuth;_type=Ve.TransformSubnetTx;constructor(t,e,r,n,s,a,i,o,u,c,d,f,l,h,p,m){super(),this.baseTx=t,this.subnetID=e,this.assetId=r,this.initialSupply=n,this.maximumSupply=s,this.minConsumptionRate=a,this.maxConsumptionRate=i,this.minValidatorStake=o,this.maxValidatorStake=u,this.minStakeDuration=c,this.maxStakeDuration=d,this.minDelegationFee=f,this.minDelegatorStake=l,this.maxValidatorWeightFactor=h,this.uptimeRequirement=p,this.subnetAuth=m}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,n,s,a,i,o,u,c,d,f,l,h,p,m,g,b,y]=qn(t,[Cs,an,an,Kn,Kn,Kn,Kn,Kn,Kn,Cn,Cn,Cn,Kn,$n,Cn,Ls],e);return[new co(r,n,s,a,i,o,u,c,d,f,l,h,p,m,g,b),y]}toBytes(t){return n(Xn([this.baseTx,this.subnetID,this.assetId,this.initialSupply,this.maximumSupply,this.minConsumptionRate,this.maxConsumptionRate,this.minValidatorStake,this.maxValidatorStake,this.minStakeDuration,this.maxStakeDuration,this.minDelegationFee,this.minDelegatorStake,this.maxValidatorWeightFactor,this.uptimeRequirement],t),t.PackPrefix(this.subnetAuth))}};var lo;fo=co=d([t=>{},f("design:paramtypes",[Cs,an,an,Kn,Kn,Kn,Kn,Kn,Kn,Cn,Cn,Cn,Kn,$n,Cn,Object])],fo);let ho=lo=class extends Ia{baseTx;_type=Ve.PvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,n]=qn(t,[Cs],e);return[new lo(r),n]}toBytes(t){return this.baseTx.toBytes(t)}};var po;ho=lo=d([t=>{},f("design:paramtypes",[Cs])],ho);let mo=po=class{threshold;addresses;_type=Ve.PChainOwner;constructor(t,e){this.threshold=t,this.addresses=e}getAddresses(){return this.addresses}static fromBytes(t,e){const[r,n,s]=qn(t,[Cn,Ln(Le)],e);return[new po(r,n),s]}toBytes(t){return n(Xn([this.threshold,this.addresses],t))}static fromNative(t,e=1){return new po(new Cn(e),t.map((t=>new Le(t))))}};var go;mo=po=d([t=>{},f("design:paramtypes",[Cn,Array])],mo);let bo=go=class{nodeId;weight;balance;signer;remainingBalanceOwner;deactivationOwner;_type=Ve.L1Validator;constructor(t,e,r,n,s,a){this.nodeId=t,this.weight=e,this.balance=r,this.signer=n,this.remainingBalanceOwner=s,this.deactivationOwner=a}getBalance(){return this.balance}getNodeId(){return this.nodeId}getWeight(){return this.weight.value()}getRemainingBalanceOwner(){return this.remainingBalanceOwner}getDeactivationOwner(){return this.deactivationOwner}static fromNative(t,e,r,n,s,a){return new go(new Yn(dn.fromString(t).toBytes()),new Kn(e),new Kn(r),n,s,a)}static fromBytes(t,e){const[r,n,s,a,i,o,u]=qn(t,[Yn,Kn,Kn,to,mo,mo],e);return[new go(r,n,s,a,i,o),u]}toBytes(t){return Xn([this.nodeId,this.weight,this.balance,this.signer,this.remainingBalanceOwner,this.deactivationOwner],t)}};var yo;bo=go=d([t=>{},f("design:paramtypes",[Yn,Kn,Kn,to,mo,mo])],bo);let wo=yo=class extends Sa{baseTx;subnetID;chainID;address;validators;subnetAuth;_type=Ve.ConvertSubnetToL1Tx;constructor(t,e,r,n,s,a){super(),this.baseTx=t,this.subnetID=e,this.chainID=r,this.address=n,this.validators=s,this.subnetAuth=a}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,n,s,a,i,o,u]=qn(t,[Cs,an,an,Yn,Ln(bo),Ls],e);return[new yo(r,n,s,a,i,o),u]}toBytes(t){return n(Xn([this.baseTx,this.subnetID,this.chainID,this.address],t),Fn(this.validators,t),t.PackPrefix(this.subnetAuth))}};var xo;wo=yo=d([t=>{},f("design:paramtypes",[Cs,an,an,Yn,Array,Object])],wo);let Io=xo=class extends Ia{baseTx;validationId;balance;_type=Ve.IncreaseL1ValidatorBalanceTx;constructor(t,e,r){super(),this.baseTx=t,this.validationId=e,this.balance=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Kn],e);return[new xo(r,n,s),a]}toBytes(t){return Xn([this.baseTx,this.validationId,this.balance],t)}};var Bo;Io=xo=d([t=>{},f("design:paramtypes",[Cs,an,Kn])],Io);let To=Bo=class extends Ia{baseTx;validationId;disableAuth;_type=Ve.DisableL1ValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.validationId=e,this.disableAuth=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cs,an,Ls],e);return[new Bo(r,n,s),a]}toBytes(t){return n(Xn([this.baseTx,this.validationId],t),t.PackPrefix(this.disableAuth))}getDisableAuth(){return this.disableAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getDisableAuth().values()].filter((t=>void 0!==t))}};var vo;To=Bo=d([t=>{},f("design:paramtypes",[Cs,an,Object])],To);let Oo=vo=class extends Ia{baseTx;message;_type=Ve.SetL1ValidatorWeightTx;constructor(t,e){super(),this.baseTx=t,this.message=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Cs,Yn],e);return[new vo(r,n),s]}toBytes(t){return Xn([this.baseTx,this.message],t)}};var So;Oo=vo=d([t=>{},f("design:paramtypes",[Cs,Yn])],Oo);let Ao=So=class extends Ia{baseTx;balance;blsSignature;message;_type=Ve.RegisterL1ValidatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.balance=e,this.blsSignature=r,this.message=n}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[Cs,Kn,Jr,Yn],e);return[new So(r,n,s,a),i]}toBytes(t){return Xn([this.baseTx,this.balance,this.blsSignature,this.message],t)}};Ao=So=d([t=>{},f("design:paramtypes",[Cs,Kn,Jr,Yn])],Ao);const Eo=new Ls([...new Array(5),...Ss,ls,ms,Pa,Ra,Oa,Va,La,Xa,Fa,Ca,Ha,Wa,Za,io,fo,za,Ja,so,no,...new Array(4),uo,ho,wo,Ao,Oo,Io,To]);let ko;const Ro=()=>ko||(ko=new Ms,ko.RegisterCodec(0,Eo),ko);function Do(t){switch(t){case"AVM":return ua();case"EVM":return xa();case"PVM":return Ro();default:throw new Error("unknown VM")}}function Po(t){return Do(t.vm).packCodec(t)}var _o;let Co=_o=class{unsignedTx;credentials;_type=Ve.AvmSignedTx;constructor(t,e){this.unsignedTx=t,this.credentials=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Ls,Ln(Ls)],e);return[new _o(r,n),s]}getCredentials(){return this.credentials}getAllSignatures(){return this.getCredentials().flatMap((t=>t.getSignatures()))}toBytes(){const t=Do(this.unsignedTx.vm).getCodecForVersion(new Qn(0));return n(new Qn(0).toBytes(),t.PackPrefix(this.unsignedTx),t.PackPrefixList(this.credentials))}};function No(t){return t._type===Ve.TransferableOutput}function Vo(t){return t._type===Ve.TransferableInput}Co=_o=d([t=>{},f("design:paramtypes",[Function,Array])],Co);var Uo=Object.freeze({__proto__:null,AvaxTx:_n,get BaseTx(){return Cs},get SignedTx(){return Co},get TransferableInput(){return Rs},get TransferableOutput(){return Ps},get UTXOID(){return Es},isBaseTx:function(t){return t._type===Ve.BaseTx},isTransferableInput:Vo,isTransferableOutput:No});function Lo(t){return t._type===Ve.AvmBaseTx}function Mo(t){return t._type===Ve.AvmExportTx}function Fo(t){return t._type===Ve.AvmImportTx}var qo=Object.freeze({__proto__:null,get BaseTx(){return Us},get CreateAssetTx(){return Js},get ExportTx(){return ta},get ImportTx(){return ra},get InitialState(){return zs},get OperationTx(){return oa},getAVMManager:ua,isAvmBaseTx:Lo,isCreateAssetTx:function(t){return t._type===Ve.CreateAssetTx},isExportTx:Mo,isImportTx:Fo,isOperationTx:function(t){return t._type===Ve.OperationTx}});function Xo(t){return t._type==Ve.EvmExportTx}function jo(t){return t._type==Ve.EvmImportTx}function Ho(t){return jo(t)||Xo(t)}function Ko(t){return!(!Xo(t)&&!jo(t))}var Wo,Go=Object.freeze({__proto__:null,EVMTx:ca,get ExportTx(){return ha},get ImportTx(){return ya},get Input(){return fa},get Output(){return ma},isEvmTx:Ho,isExportTx:Xo,isImportExportTx:Ko,isImportTx:jo});let Zo=Wo=class{signers;signature;_type=Ve.WarpSignature;constructor(t,e){this.signers=t,this.signature=e}static fromBytes(t,e){const[r,n,s]=qn(t,[Yn,Jr],e);return[new Wo(r,n),s]}toBytes(t){return Xn([this.signers,this.signature],t)}numOfSigners(){return Re(this.signers.bytes)}};Zo=Wo=d([t=>{},f("design:paramtypes",[Yn,Jr])],Zo);const $o=new Ls([Zo]);let zo;const Yo=()=>zo||(zo=new Ms,zo.RegisterCodec(0,$o),zo);var Jo;let Qo=Jo=class{networkId;sourceChainId;payload;_type=Ve.WarpUnsignedMessage;constructor(t,e,r){this.networkId=t,this.sourceChainId=e,this.payload=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Cn,an,Yn],e);return[new Jo(r,n,s),a]}toBytes(t){return Xn([this.networkId,this.sourceChainId,this.payload],t)}};var tu;Qo=Jo=d([t=>{},f("design:paramtypes",[Cn,an,Yn])],Qo);let eu=tu=class{unsignedMessage;signature;_type=Ve.WarpMessage;constructor(t,e){this.unsignedMessage=t,this.signature=e}static fromBytes(t,e){const[r,n]=qn(t,[Qo],e),[s,a]=e.UnpackPrefix(n);return[new tu(r,s),a]}toBytes(t){return n(this.unsignedMessage.toBytes(t),t.PackPrefix(this.signature))}};var ru;eu=tu=d([t=>{},f("design:paramtypes",[Qo,Function])],eu);let nu=ru=class{sourceAddress;payload;_type=Ve.AddressedCall;codecId=new Qn(0);typeId=new Cn(1);constructor(t,e){this.sourceAddress=t,this.payload=e}static fromBytes(t,e){const[r,n]=qn(t,[Cn],e);if(1!==r.value())throw new Error(`Invalid type id for AddressedCall. Required typeId: 1. Got typeId: ${r.value()}`);const[s,a,i]=qn(n,[Yn,Yn],e),o=new Le(s.bytes);return[new ru(o,a),i]}toBytes(t){const e=new Yn(this.sourceAddress.toBytes());return Xn([this.typeId,e,this.payload],t)}getSourceAddress(t="hex",e="avax"){return"bech32"===t?this.sourceAddress.toString(e):this.sourceAddress.toHex()}getPayload(){return this.payload.toString("hex")}};var su;nu=ru=d([t=>{},f("design:paramtypes",[Le,Yn])],nu);let au=su=class{subnetId;nodeId;blsPublicKey;expiry;remainingBalanceOwner;disableOwner;weight;_type=Ve.RegisterL1ValidatorMessage;codecId=new Qn(0);typeId=new Cn(1);constructor(t,e,r,n,s,a,i){this.subnetId=t,this.nodeId=e,this.blsPublicKey=r,this.expiry=n,this.remainingBalanceOwner=s,this.disableOwner=a,this.weight=i}static fromBytes(t,e){const[r,n]=qn(t,[Cn],e);if(1!==r.value())throw new Error(`Invalid type id for RegisterL1ValidatorMessage. Required typeId: 1. Got typeId: ${r.value()}`);const[s,a,i,o,u,c,d,f]=qn(n,[an,Yn,tn,Kn,mo,mo,Kn],e),l=new dn(a.bytes);return[new su(s,l,i,o,u,c,d),f]}toBytes(t){const e=new Yn(this.nodeId.toBytes());return Xn([this.typeId,this.subnetId,e,this.blsPublicKey,this.expiry,this.remainingBalanceOwner,this.disableOwner,this.weight],t)}getSubnetId(){return this.subnetId.value()}getNodeId(){return this.nodeId.value()}getBlsPublicKey(){return this.blsPublicKey}getExpiry(){return this.expiry.value()}getRemainingBalanceOwner(){return this.remainingBalanceOwner}getDisableOwner(){return this.disableOwner}getWeight(){return this.weight.value()}};var iu;au=su=d([t=>{},f("design:paramtypes",[an,dn,tn,Kn,mo,mo,Kn])],au);let ou=iu=class{validationId;nonce;weight;_type=Ve.L1ValidatorWeightMessage;codecId=new Qn(0);typeId=new Cn(3);constructor(t,e,r){this.validationId=t,this.nonce=e,this.weight=r}static fromBytes(t,e){const[r,n]=qn(t,[Cn],e);if(3!==r.value())throw new Error(`Invalid type id for L1ValidatorWeightMessage. Required typeId: 3. Got typeId: ${r.value()}`);const[s,a,i,o]=qn(n,[an,Kn,Kn],e);return[new iu(s,a,i),o]}toBytes(t){return Xn([this.typeId,this.validationId,this.nonce,this.weight],t)}getWeight(){return this.weight.value()}getNonce(){return this.nonce.value()}getValidationId(){return this.validationId.value()}};var uu;ou=iu=d([t=>{},f("design:paramtypes",[an,Kn,Kn])],ou);let cu=uu=class{validationId;registered;_type=Ve.L1ValidatorRegistrationMessage;codecId=new Qn(0);typeId=new Cn(2);constructor(t,e){this.validationId=t,this.registered=e}static fromBytes(t,e){const[r,n]=qn(t,[Cn],e);if(2!==r.value())throw new Error(`Invalid type id for L1ValidatorRegistrationMessage. Required typeId: 2. Got typeId: ${r.value()}`);const[s,a,i]=qn(n,[an,Gn],e);return[new uu(s,a),i]}toBytes(t){return Xn([this.typeId,this.validationId,this.registered],t)}getValidationId(){return this.validationId.value()}getRegistered(){return this.registered.value()}};var du;cu=uu=d([t=>{},f("design:paramtypes",[an,Gn])],cu);let fu=du=class{conversionId;_type=Ve.SubnetToL1ConversionMessage;codecId=new Qn(0);typeId=new Cn(0);constructor(t){this.conversionId=t}static fromBytes(t,e){const[r,n]=qn(t,[Cn],e);if(0!==r.value())throw new Error(`Invalid type id for SubnetToL1ConversionMessage. Required typeId: 0. Got typeId: ${r.value()}`);const[s,a]=qn(n,[an],e);return[new du(s),a]}toBytes(t){return Xn([this.typeId,this.conversionId],t)}getConversionId(){return this.conversionId.value()}};var lu;fu=du=d([t=>{},f("design:paramtypes",[an])],fu);let hu=lu=class{nodeId;blsPublicKey;weight;_type=Ve.ValidatorData;constructor(t,e,r){this.nodeId=t,this.blsPublicKey=e,this.weight=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Yn,tn,Kn],e),i=new dn(r.bytes);return[new lu(i,n,s),a]}toBytes(t){return Xn([new Yn(this.nodeId.toBytes()),this.blsPublicKey,this.weight],t)}};var pu;hu=lu=d([t=>{},f("design:paramtypes",[dn,tn,Kn])],hu);let mu=pu=class{subnetId;managerChainId;managerAddress;validators;_type=Ve.ConversionData;constructor(t,e,r,n){this.subnetId=t,this.managerChainId=e,this.managerAddress=r,this.validators=n}static fromBytes(t,e){const[r,n,s,a,i]=qn(t,[an,an,Yn,Yn],e),o=new Le(s.bytes),[u]=Vn(a.bytes,hu,e);return[new pu(r,n,o,u),i]}toBytes(t){const e=new Yn(this.managerAddress.toBytes()),r=new Yn(Fn(this.validators,t));return Xn([this.subnetId,this.managerChainId,e,r],t)}};mu=pu=d([t=>{},f("design:paramtypes",[an,an,Le,Array])],mu);var gu=Object.freeze({__proto__:null,get AddressedCall(){return nu},get ConversionData(){return mu},get L1ValidatorRegistrationMessage(){return cu},get L1ValidatorWeightMessage(){return ou},get RegisterL1ValidatorMessage(){return au},get SubnetToL1ConversionMessage(){return fu},get ValidatorData(){return hu}}),bu=Object.freeze({__proto__:null,AddressedCallPayloads:gu,get WarpMessage(){return eu},get WarpSignature(){return Zo},get WarpUnsignedMessage(){return Qo},codec:$o,getWarpManager:Yo});function yu(t){return t._type===Ve.PvmBaseTx}function wu(t){return t._type===Ve.AddDelegatorTx}function xu(t){return t._type===Ve.AddPermissionlessDelegatorTx}function Iu(t){return t._type===Ve.AddPermissionlessValidatorTx}function Bu(t){return t._type===Ve.AddSubnetValidatorTx}function Tu(t){return t._type===Ve.AddValidatorTx}function vu(t){return t._type===Ve.CreateChainTx}function Ou(t){return t._type===Ve.CreateSubnetTx}function Su(t){return t._type===Ve.RemoveSubnetValidatorTx}function Au(t){return t._type===Ve.TransferSubnetOwnershipTx}function Eu(t){return t._type===Ve.PvmExportTx}function ku(t){return t._type===Ve.PvmImportTx}function Ru(t){return t._type===Ve.ConvertSubnetToL1Tx}function Du(t){return t._type===Ve.RegisterL1ValidatorTx}function Pu(t){return t._type===Ve.SetL1ValidatorWeightTx}function _u(t){return t._type===Ve.IncreaseL1ValidatorBalanceTx}function Cu(t){return t._type===Ve.DisableL1ValidatorTx}var Nu=Object.freeze({__proto__:null,AbstractSubnetTx:Sa,get AddDelegatorTx(){return Oa},get AddPermissionlessDelegatorTx(){return Ja},get AddPermissionlessValidatorTx(){return za},get AddSubnetValidatorTx(){return Ra},get AddValidatorTx(){return Pa},get AdvanceTimeTx(){return Ca},get BaseTx(){return ho},get ConvertSubnetToL1Tx(){return wo},get CreateChainTx(){return Va},get CreateSubnetTx(){return La},get DisableL1ValidatorTx(){return To},get ExportTx(){return Fa},get ImportTx(){return Xa},get IncreaseL1ValidatorBalanceTx(){return Io},get ProofOfPossession(){return to},get RegisterL1ValidatorTx(){return Ao},get RemoveSubnetValidatorTx(){return io},get SetL1ValidatorWeightTx(){return Oo},get Signer(){return no},get SignerEmpty(){return so},get StakeableLockIn(){return Wa},get StakeableLockOut(){return Za},get SubnetValidator(){return Ea},get TransferSubnetOwnershipTx(){return uo},get TransformSubnetTx(){return fo},get Validator(){return Ta},isAddDelegatorTx:wu,isAddPermissionlessDelegatorTx:xu,isAddPermissionlessValidatorTx:Iu,isAddSubnetValidatorTx:Bu,isAddValidatorTx:Tu,isAdvanceTimeTx:function(t){return t._type===Ve.AdvanceTimeTx},isConvertSubnetToL1Tx:Ru,isCreateChainTx:vu,isCreateSubnetTx:Ou,isDisableL1ValidatorTx:Cu,isEmptySigner:function(t){return t._type===Ve.SignerEmpty},isExportTx:Eu,isImportTx:ku,isIncreaseL1ValidatorBalanceTx:_u,isPvmBaseTx:yu,isRegisterL1ValidatorTx:Du,isRemoveSubnetValidatorTx:Su,isRewardValidatorTx:function(t){return t._type===Ve.RewardValidatorTx},isSetL1ValidatorWeightTx:Pu,isSigner:function(t){return t._type===Ve.Signer},isTransferSubnetOwnershipTx:Au,isTransformSubnetTx:function(t){return t._type===Ve.TransformSubnetTx},warp:bu});function Vu(t){return Uu(t.toBytes().length)+1000n*BigInt(t.getSigIndices().flatMap((t=>t)).length)+10000n}function Uu(t){return 1n*BigInt(t)}class Lu{utxos;constructor(t){this.utxos=t,this.utxos=function(t){const e=t.map((t=>t.ID()));return t.filter(((t,r)=>e.indexOf(t.ID())==r))}(t)}getUTXOs(){return[...this.utxos]}getAssetDict(){const t={};this.utxos.forEach((e=>{const r=e.assetId.toString(),n=t[r]||[];t[r]=[...n,e]}));const e={};for(const r in t)e[r]=new Lu(t[r]);return e}getAssetIDs(){const t=this.utxos.map((t=>t.assetId.toString()));return t.filter(((e,r)=>t.indexOf(e)===r))}push(t){return new Lu([...this.getUTXOs(),t])}getUTXOIDs(){return this.utxos.map((t=>t.ID()))}merge(t){const e=[...this.getUTXOs(),...t.getUTXOs()];return new Lu(e)}getTransferOuts(){const t=this.utxos.filter((t=>rs(t.output)));return new Lu(t)}}function Mu(t){return n(t,o(t).subarray(-4))}const Fu=(t,e,r,n)=>{if(t.locktime.value()>r)return;const s=new Set(e.map((t=>t.toString()))),a=t.addrs.reduce(((e,r,a)=>e.size()<t.threshold.value()&&s.has(r.value())?n?.length&&!n.includes(a)?e:e.set(r,a):e),new qu);return a.size()<t.threshold.value()?void 0:{sigIndicies:Array.from(a.values()),addressMap:a}};class qu{constructor(t=[]){t.forEach((([t,e])=>{this.set(t,e)}))}storage=new Map;set(t,e){return this.storage.set(t.toHex(),e),this}toJSON(){return Array.from(this.storage.entries())}static fromJSON(t){return new qu(t.map((([t,e])=>[Le.fromHex(t),e])))}get(t){return this.storage.get(t.toHex())}has(t){return this.storage.has(t.toHex())}size(){return this.storage.size}forEach(t){return this.storage.forEach(((e,r)=>t(e,Le.fromHex(r))))}forEachHex(t,e=!1){return e?qu.fromJSON([...this.storage.entries()].sort(((t,e)=>t[1]-e[1])).map((([t],e)=>[t,e]))).storage.forEach(t):this.storage.forEach(t)}values(){return this.storage.values()}}class Xu{constructor(t=[]){t.length&&this.push(...t)}storage=[];index={};orderedIndex={};push(...t){t.forEach((t=>{t.forEachHex(((t,e)=>{this.index[e]=this.index[e]??[],this.index[e].push([this.storage.length,t])})),t.forEachHex(((t,e)=>{this.orderedIndex[e]=this.orderedIndex[e]??[],this.orderedIndex[e].push([this.storage.length,t])}),!0),this.storage.push(t)}))}static fromTransferableInputs(t,e,r,n){const s=e.reduce(((t,e)=>t.set(e.utxoId.ID(),e)),new Map),a=t.map(((t,e)=>{const a=s.get(t.utxoID.ID());if(!a)throw new Error("input utxo not found");if(n){const s=hs(n),i=Fu(a.getOutputOwners(),s,r,t.sigIndicies());if(!i)throw new Error(`input ${e} has no valid owners`);return i.addressMap}const i=t.sigIndicies().map((t=>[a.getOutputOwners().addrs[t],t]));return new qu(i)}));return new Xu(a)}toJSON(){return this.storage}static fromJSON(t){return new Xu(t.map((t=>qu.fromJSON(t))))}getAddresses(){return Object.keys(this.index).map((t=>Ee(t)))}forEach(t,e=!1){Object.entries(e?this.orderedIndex:this.index).forEach((([e,r])=>{t(r,e)}))}has(t){return t.toHex()in this.index}toArray(){return this.storage}merge(t){t.toArray().forEach((t=>this.push(t)))}getSigIndicesForAddress(t,e=!1){return e?this.orderedIndex[t.toHex()]:this.index[t.toHex()]}}const ju=t=>Ko(t)?Xo(t)?[]:t.importedInputs:[],Hu=t=>Ho(t)?ju(t):Fo(t)||ku(t)?[...t.baseTx.inputs??[],...t.ins??[]]:t.getInputs(),Ku=t=>Ko(t)&&Xo(t)?t.exportedOutputs:[],Wu=t=>{if(Ho(t))return Ku(t);if(Mo(t)||Eu(t))return[...t.baseTx?.outputs??[],...t.outs??[]];if(Tu(t)||wu(t)||Iu(t)||xu(t)){const e=[...t.baseTx?.outputs??[],...t.stake??[]];return Tu(t)?e.push(t.getRewardsOwner(),t.getRewardsOwner()):wu(t)?e.push(t.getRewardsOwner()):Iu(t)?e.push(t.getValidatorRewardsOwner(),t.getDelegatorRewardsOwner()):e.push(t.getDelegatorRewardsOwner()),e}return Ou(t)?[...t.baseTx.outputs,t.getSubnetOwners()]:t?.baseTx?.outputs??[]},Gu=t=>{const{output:e}=t,r=t.getOutputOwners();return{amount:rs(e)||ns(e)?e.amount():0n,assetId:t.getAssetId(),locktime:r.locktime.value(),stakeableLocktime:ns(e)?e.getStakeableLocktime():0n,threshold:r.threshold.value(),utxoId:t.ID()}},Zu=(t,e)=>{const r=t.get(e.assetId.toString())??0n,n=Vo(e)||No(e)?e.amount():e.amount.value();return t.set(e.assetId.toString(),r+n),t},$u=t=>{if(Xo(t))return t.ins.reduce(Zu,new Map);return Hu(t).reduce(Zu,new Map)},zu=t=>{if(jo(t))return t.Outs.reduce(Zu,new Map);return Wu(t).reduce(((t,e)=>No(e)?Zu(t,e):t),new Map)},Yu=(t,e)=>{const r=$u(t),n=zu(t),s=new Map,a=(t=>Ru(t)?t.validators.reduce(((t,e)=>t+e.balance.value()),0n):Du(t)||_u(t)?t.balance.value():0n)(t);for(const[t,e]of r.entries()){const r=n.get(t)??0n;s.set(t,e-r)}if(a){const t=s.get(e.avaxAssetID);t&&s.set(e.avaxAssetID,t-a)}return s},Ju=(t,e)=>({isValid:t===e,txFee:e});var Qu;!function(t){t[t.Bandwidth=0]="Bandwidth",t[t.DBRead=1]="DBRead",t[t.DBWrite=2]="DBWrite",t[t.Compute=3]="Compute"}(Qu||(Qu={}));const tc=()=>({[Qu.Bandwidth]:0,[Qu.DBRead]:0,[Qu.DBWrite]:0,[Qu.Compute]:0}),ec=({bandwidth:t,dbRead:e,dbWrite:r,compute:n})=>({[Qu.Bandwidth]:t,[Qu.DBRead]:e,[Qu.DBWrite]:r,[Qu.Compute]:n}),rc=(...t)=>{const e=tc();for(const r of t)e[Qu.Bandwidth]+=r[Qu.Bandwidth],e[Qu.DBRead]+=r[Qu.DBRead],e[Qu.DBWrite]+=r[Qu.DBWrite],e[Qu.Compute]+=r[Qu.Compute];return e},nc=(t,e)=>BigInt(t[Qu.Bandwidth]*e[Qu.Bandwidth]+t[Qu.DBRead]*e[Qu.DBRead]+t[Qu.DBWrite]*e[Qu.DBWrite]+t[Qu.Compute]*e[Qu.Compute]),sc={[Qu.Bandwidth]:58,[Qu.DBRead]:0,[Qu.DBWrite]:0,[Qu.Compute]:0},ac={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+2+sn+4+4+4+4,[Qu.DBRead]:3,[Qu.DBWrite]:1,[Qu.Compute]:0},ic={[Qu.Bandwidth]:sc[Qu.Bandwidth]+4,[Qu.DBRead]:0,[Qu.DBWrite]:1,[Qu.Compute]:0},oc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+44+sn+4+4+4+4+4,[Qu.DBRead]:1,[Qu.DBWrite]:3,[Qu.Compute]:0},uc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+44+sn+4+4,[Qu.DBRead]:1,[Qu.DBWrite]:2,[Qu.Compute]:0},cc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+76+4+4,[Qu.DBRead]:3,[Qu.DBWrite]:3,[Qu.Compute]:0},dc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+4,[Qu.DBRead]:0,[Qu.DBWrite]:0,[Qu.Compute]:0},fc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+4,[Qu.DBRead]:0,[Qu.DBWrite]:0,[Qu.Compute]:0},lc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+cn+sn+4+4,[Qu.DBRead]:1,[Qu.DBWrite]:3,[Qu.Compute]:0},hc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+4+4+4,[Qu.DBRead]:1,[Qu.DBWrite]:1,[Qu.Compute]:0},pc={[Qu.Bandwidth]:36,[Qu.DBRead]:0,[Qu.DBWrite]:4,[Qu.Compute]:0},mc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+sn+4+4+4+4,[Qu.DBRead]:3,[Qu.DBWrite]:2,[Qu.Compute]:0},gc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+8+Xr+4,[Qu.DBRead]:5,[Qu.DBWrite]:6,[Qu.Compute]:1050},bc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+4,[Qu.DBRead]:3,[Qu.DBWrite]:5,[Qu.Compute]:0},yc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+8,[Qu.DBRead]:1,[Qu.DBWrite]:5,[Qu.Compute]:0},wc={[Qu.Bandwidth]:sc[Qu.Bandwidth]+sn+4+4,[Qu.DBRead]:1,[Qu.DBWrite]:6,[Qu.Compute]:0},xc=Yo(),Ic=t=>{let e=tc();for(const r of t){const t={[Qu.Bandwidth]:60,[Qu.DBRead]:0,[Qu.DBWrite]:1,[Qu.Compute]:0};let n=0;ns(r.output)?(t[Qu.Bandwidth]+=12,n=r.output.getOutputOwners().addrs.length):rs(r.output)&&(n=r.output.outputOwners.addrs.length);const s=n*cn;t[Qu.Bandwidth]+=s,e=rc(e,t)}return e},Bc=t=>{let e=tc();for(const r of t){const t={[Qu.Bandwidth]:92,[Qu.DBRead]:1,[Qu.DBWrite]:1,[Qu.Compute]:0};as(r.input)&&(t[Qu.Bandwidth]+=12);const n=r.sigIndicies().length,s=69*n;t[Qu.Bandwidth]+=s,t[Qu.Compute]+=200*n,e=rc(e,t)}return e},Tc=t=>t instanceof so?tc():ec({bandwidth:144,dbRead:0,dbWrite:0,compute:1050}),vc=t=>{const e=t.addrs.length;return ec({bandwidth:e*cn+16,dbRead:0,dbWrite:0,compute:0})},Oc=t=>{if(!(t instanceof ls))throw new Error("Unable to calculate auth complexity of transaction. Expected Input as subnet auth.");const e=t.values().length;return ec({bandwidth:69*e+8,dbRead:0,dbWrite:0,compute:200*e})},Sc=(...t)=>{const e=tc();return t.forEach((t=>{e[Qu.Bandwidth]+=t.length})),e},Ac=t=>{const e=5*xc.unpack(t.bytes,eu).signature.numOfSigners()+1e3;return ec({bandwidth:t.length,dbRead:23,dbWrite:0,compute:e})},Ec=t=>{let e=tc();for(const r of t)e=rc(e,kc(r));return e},kc=t=>{const e=Sc(t.nodeId),r=Tc(t.signer),n=ec({bandwidth:(t.getRemainingBalanceOwner().getAddresses().length+t.getDeactivationOwner().getAddresses().length)*cn,dbRead:0,dbWrite:0,compute:0});return rc(pc,e,r,n)},Rc=t=>{const e=Ic(t.outputs),r=Bc(t.inputs),n=rc(e,r);return n[Qu.Bandwidth]+=t.memo.length,n},Dc=t=>{if(Iu(t))return(t=>rc(oc,Rc(t.baseTx),Tc(t.signer),Ic(t.stake),vc(t.getValidatorRewardsOwner()),vc(t.getDelegatorRewardsOwner())))(t);if(xu(t))return(t=>rc(uc,Rc(t.baseTx),vc(t.getDelegatorRewardsOwner()),Ic(t.stake)))(t);if(Bu(t))return(t=>rc(cc,Rc(t.baseTx),Oc(t.subnetAuth)))(t);if(vu(t))return(t=>{let e=t.fxIds.length*sn;e+=t.chainName.value().length,e+=t.genesisData.length;const r=ec({bandwidth:e,dbRead:0,dbWrite:0,compute:0});return rc(ac,r,Rc(t.baseTx),Oc(t.subnetAuth))})(t);if(Ou(t))return(t=>rc(ic,Rc(t.baseTx),vc(t.getSubnetOwners())))(t);if(Eu(t))return(t=>rc(dc,Rc(t.baseTx),Ic(t.outs)))(t);if(ku(t))return(t=>rc(fc,Rc(t.baseTx),Bc(t.ins)))(t);if(Su(t))return(t=>rc(lc,Rc(t.baseTx),Oc(t.subnetAuth)))(t);if(Au(t))return(t=>rc(hc,Rc(t.baseTx),Oc(t.subnetAuth),vc(t.getSubnetOwners())))(t);if(yu(t))return(t=>rc(sc,Rc(t.baseTx)))(t);if(Ru(t))return(t=>rc(mc,Sc(t.address),Rc(t.baseTx),Oc(t.subnetAuth),Ec(t.validators)))(t);if(Du(t))return(t=>rc(gc,Rc(t.baseTx),Ac(t.message)))(t);if(Pu(t))return(t=>rc(bc,Rc(t.baseTx),Ac(t.message)))(t);if(_u(t))return(t=>rc(yc,Rc(t.baseTx)))(t);if(Cu(t))return(t=>rc(wc,Rc(t.baseTx),Oc(t.getDisableAuth())))(t);throw new Error("Unsupported transaction type.")},Pc=(t,e,r)=>{const n=Dc(t);return nc(n,e)*r};var _c,Cc=Object.freeze({__proto__:null,AddressMap:qu,AddressMaps:Xu,CCostPerSignature:1000n,CFixedFee:1e4,CTxBytesGas:1n,UtxoSet:Lu,add0x:xe,addChecksum:Mu,addressesFromBytes:hs,base58:e,base58check:en,bech32ToBytes:p,bufferToBigInt:ve,bufferToBool:Se,bufferToHex:Ae,bufferToNumber:Oe,bytesCompare:rn,bytesEqual:(t,e)=>t.length===e.length&&0===rn(t,e),calcBytesCost:Uu,concatBytes:n,costCorethTx:Vu,format:function(t,e,r){return`${t}-${g(e,r)}`},formatBech32:g,getBurnedAmountByTx:Yu,getInputAmounts:$u,getManagerForVM:Do,getOutputAmounts:zu,getTransferableInputsByEvmTx:ju,getTransferableInputsByTx:Hu,getTransferableOutputsByEvmTx:Ku,getTransferableOutputsByTx:Wu,getUtxoInfo:Gu,hammingWeight:Re,hexToBuffer:Ee,isEtnaEnabled:t=>{const{etnaTime:e}=t;return new Date(e)<new Date},isRewardsOwner:ss,isStakeableLockIn:as,isStakeableLockOut:ns,isTransferInput:is,isTransferOut:rs,matchOwners:Fu,packTx:Po,padLeft:ke,parse:h,parseBech32:m,printDeep:t=>{console.log(c.inspect(t,{depth:null,colors:!0}))},printHex:(t,e="")=>{console.log(`name = ${e}`,Ae(t))},printJSON:t=>{console.log(JSON.stringify(t,null,2))},strip0x:Ie,unpackWithManager:function(t,e){return Do(t).unpackTransaction(e)},validateBurnedAmount:({unsignedTx:t,context:e,burnedAmount:r,baseFee:n,feeTolerance:s})=>{const a=t.getTx(),i=r??((t,e)=>Yu(t,e).get(e.avaxAssetID)??0n)(a,e);if(Ko(a)||(t=>yu(t)||Eu(t)||ku(t)||Iu(t)||xu(t)||Bu(t)||vu(t)||Ou(t)||Su(t)||Au(t)||Ru(t)||Du(t)||Pu(t)||_u(t)||Cu(t))(a)){return(({burnedAmount:t,feeAmount:e,feeTolerance:r})=>{const n=Math.floor(r);if(n<0)throw new Error("feeTolerance must be be non-negative.");const s=e*BigInt(n)/100n;return{isValid:t>=(s>e?0n:e-s)&&t<=e+s,txFee:t}})({burnedAmount:i,feeAmount:Ko(a)?n*Vu(t):Pc(a,e.platformFeeConfig.weights,n),feeTolerance:s})}return(({unsignedTx:t,context:e,burnedAmount:r})=>{const n=t.getTx();if(Lo(n)||Mo(n)||Fo(n))return Ju(r,e.baseTxFee);throw new Error("tx type is not supported")})({unsignedTx:t,context:e,burnedAmount:i})}});let Nc=_c=class{utxoId;assetId;output;_type=Ve.UTXO;constructor(t,e,r){this.utxoId=t,this.assetId=e,this.output=r}static fromBytes(t,e){const[r,n,s,a]=qn(t,[Es,an,Ls],e);return[new _c(r,n,s),a]}getOutputOwners(){if(rs(this.output))return this.output.outputOwners;if(ns(this.output))return this.output.getOutputOwners();if(ss(this.output))return this.output;throw new Error("unable to get output owner")}toBytes(t){return n(Xn([this.utxoId,this.assetId],t),t.PackPrefix(this.output))}getAssetId(){return this.assetId.toString()}ID(){return this.utxoId.ID()}};Nc=_c=d([t=>{},f("design:paramtypes",[Es,an,Object])],Nc);const Vc=async({unsignedTx:t,privateKeys:e})=>{const r=t.toBytes();await Promise.all(e.map((async e=>{const n=$i(e);if(t.hasPubkey(n)){const n=await Wi(r,e);t.addSignature(n)}})))},Uc="https://api.avax.network";class Lc{url;reqId=0;constructor(t){this.url=t}async callMethod(t,e,r){const n={jsonrpc:"2.0",id:this.reqId++,method:t,params:e},s=await fetch(this.url,{...r,method:"POST",body:JSON.stringify(n),headers:{"Content-Type":"application/json",...r?.headers}}).then((async t=>t.json())).then((t=>t));if(s.error)throw new Error(s.error.message);return s.result}}class Mc{path;base;fetchOptions;rpcProvider;constructor(t=Uc,e,r,n){this.path=e,this.base=r,this.fetchOptions=n,this.rpcProvider=new Lc(t+e)}setFetchOptions(t){this.fetchOptions=t}getMethodName=t=>this.base?`${this.base}.${t}`:t;callRpc=(t,e)=>this.rpcProvider.callMethod(this.getMethodName(t),e,this.fetchOptions)}class Fc extends Mc{path;base;manager;constructor(t=Uc,e,r,n){super(t,e,r),this.path=e,this.base=r,this.manager=n}async getUTXOs(t){const e=await this.callRpc("getUTXOs",{...t,encoding:"hex"}),r=e.utxos.map((t=>this.manager.unpack(Ee(t),Nc)));return{...e,utxos:r}}issueTx(t){return this.callRpc("issueTx",t)}issueSignedTx(t){return this.issueTx({tx:Ae(Mu(t.toBytes()))})}}class qc extends Fc{getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getTx=async t=>{const e=await this.callRpc("getTx",{...t,encoding:"hex"});return this.manager.unpack(Ee(e.tx),Co)};getTxJson=t=>this.callRpc("getTx",{...t,encoding:"json"});getTxStatus(t){return this.callRpc("getTxStatus",{includeReason:!0,...t})}getBalance(t){return this.callRpc("getBalance",t)}getAddressTxs(t){return this.callRpc("GetAddressTxs",t)}}class Xc extends qc{constructor(t){super(t,"/ext/bc/X","avm",ua())}buildGenesis=async t=>await this.callRpc("buildGenesis",t);getAllBalances(t){return this.callRpc("getAllBalances",t)}getTxFee=async()=>{const t=await this.callRpc("getTxFee");return{txFee:BigInt(t.txFee),createAssetTxFee:BigInt(t.createAssetTxFee)}}}const jc=(t,e)=>{const r=an.compare(t.assetId,e.assetId);if(0!==r)return r;const n=[ns],s=ua().getDefaultCodec(),a=Ro().getDefaultCodec(),i=n.some((e=>e(t.output)))?a:s,o=n.some((t=>t(e.output)))?a:s;return rn(t.toBytes(i),e.toBytes(o))},Hc=(t,e)=>t.address.value()===e.address.value()?rn(t.assetId.toBytes(),e.assetId.toBytes()):t.address.value().localeCompare(e.address.value()),Kc=t=>t.reduce(((t,e)=>(t[e.getAssetId()]=t[e.getAssetId()]??0n,t[e.getAssetId()]+=e.amount(),t)),{}),Wc=(t,e)=>({minIssuanceTime:BigInt(Math.floor((new Date).getTime()/1e3)),changeAddresses:t,threshold:1,memo:new Uint8Array,locktime:0n,...Object.fromEntries(Object.entries(e||{}).filter((([,t])=>void 0!==t)))});new ms(new Kn(0n),new Cn(0),[]),new an(new Uint8Array(32));const Gc=new us(new Uint8Array(Array(65).fill(0)));class Zc{tx;utxos;addressMaps;credentials;constructor(t,e,r,n){this.tx=t,this.utxos=e,this.addressMaps=r,this.credentials=n||this.tx.getSigIndices().map((t=>new ds(t.map((()=>Gc)))))}toJSON(){const t=Do(this.tx.vm).getDefaultCodec();return{codecId:Do(this.tx.vm).getDefaultCodecId(),vm:this.tx.vm,txBytes:Ae(this.toBytes()),utxos:this.utxos.map((e=>Ae(e.toBytes(t)))),addressMaps:this.addressMaps,credentials:this.credentials}}static fromJSON(t){const e=JSON.parse(t),r=["txBytes","utxos","addressMaps","vm","codecId","credentials"];r.forEach((t=>{if(!e[t])throw new Error(`invalid structure. must have ${r.join(", ")}, missing ${t}`)}));const n=e.vm;if(!Ne.includes(n))throw new Error("invalid VM");const s=Do(n),[a,i]=s.getCodecFromBuffer(Ee(e.txBytes)),o=a.UnpackPrefix(i)[0],u=e.utxos.map((t=>Nc.fromBytes(Ee(t),a)[0])),c=Xu.fromJSON(e.addressMaps),d=e.credentials.map((t=>ds.fromJSON(t)));return new Zc(o,u,c,d)}getSigIndices(){return this.tx.getSigIndices()}hasAddress(t){return this.addressMaps.has(t)}hasPubkey(t){return this.hasAddress(new Le(this.publicKeyBytesToAddress(t)))}getAddresses(){return this.addressMaps.getAddresses()}getSigIndicesForAddress(t){const e=this.getSigIndices().some(((t,e)=>{const r=this.credentials[e].toJSON().length;return Math.max(...t)>r-1}));return this.addressMaps.getSigIndicesForAddress(t,e)}getSigIndicesForPubKey(t){const e=this.publicKeyBytesToAddress(t),r=Yi(t),n=this.getSigIndicesForAddress(new Le(e)),s=this.getSigIndicesForAddress(new Le(r));return n||s}getInputUtxos(){return this.utxos}toBytes(){return Po(this.tx)}getBlockchainId(){return this.tx.getBlockchainId()}getTx(){return this.tx}getSignedTx(){return new Co(this.tx,this.credentials)}getCredentials(){return this.credentials}addSignatureAt(t,e,r){if(e>=this.getCredentials().length)throw new Error("index out of bounds");this.getCredentials()[e].setSignature(r,t)}addSignature(t){const e=Zi(o(this.toBytes()),t);this.addSignatureForPubKey(t,e)}addSignatureForPubKey(t,e){const r=this.getSigIndicesForPubKey(e);r&&r.forEach((([e,r])=>{this.addSignatureAt(t,e,r)}))}publicKeyBytesToAddress(t){return zi(t)}hasAllSignatures(){const t=this.credentials.map((t=>t.getSignatures())),e=Gc.toString(),r=o(this.toBytes());if(!t.every((t=>t.every((t=>t!==e)))))return!1;let n=!0;return this.addressMaps.forEach((e=>{e.forEach((([e,s])=>{const a=t[e]?.[s];if(!a)throw new Error("error: incorrect structure for credentials");const i=Ee(a),o=Zi(r,i);this.hasPubkey(o)||(n=!1)}))}),!0),n}getVM(){return this.tx.getVM()}}function $c(t=new Map,e=new Map,r,n,s,a){const i={amountsToBurn:t,utxos:r,amountsToStake:e,fromAddresses:n,options:s,inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new Xu},o=[...a,function({amountsToBurn:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Burn Amount): need ${t} more units of ${e} to burn`)})),{amountsToBurn:t,...e}},function({amountsToStake:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Stake Amount): need ${t} more units of ${e} to stake`)})),{amountsToStake:t,...e}},function({inputs:t,...e}){return t.sort(Rs.compare),{inputs:t,...e}},function({changeOutputs:t,...e}){return t.sort(jc),{changeOutputs:t,...e}},function({stakeOutputs:t,...e}){return t.sort(jc),{stakeOutputs:t,...e}},function({inputs:t,inputUTXOs:e,...r}){return{inputs:t,inputUTXOs:e,...r,addressMaps:Xu.fromTransferableInputs(t,e,s.minIssuanceTime,n.map((t=>t.toBytes())))}}].reduce(((t,e)=>e(function(t){return{...t,amountsToBurn:new Map([...t.amountsToBurn]),amountsToStake:new Map([...t.amountsToStake]),inputs:[...t.inputs],inputUTXOs:[...t.inputUTXOs],stakeOutputs:[...t.stakeOutputs],changeOutputs:[...t.changeOutputs]}}(t))),i);return{inputs:o.inputs,inputUTXOs:o.inputUTXOs,stakeOutputs:o.stakeOutputs,changeOutputs:o.changeOutputs,addressMaps:o.addressMaps}}const zc=(...t)=>t.reduce(((t,e)=>e<t?e:t)),Yc=new Error("No addresses match UTXO owners");function Jc(t,e,r,n){const s=t.reduce(((t,s)=>{const a=e(s),i=Fu(a.outputOwners,[...r],n);return i?[...t,{sigData:i,data:s}]:t}),[]);if(t.length&&!s.length)throw Yc;return s}const Qc=({amountsToBurn:t,utxos:e,options:r,changeOutputs:n,inputUTXOs:s,fromAddresses:a,inputs:i,...o})=>{const u=new ms(new Kn(0n),new Cn(r.threshold),hs(r.changeAddresses));return Jc(e.filter((e=>!!t.get(e.assetId.toString()))).filter((t=>!!rs(t.output))),(t=>t.output),a,r.minIssuanceTime).forEach((({sigData:e,data:r})=>{const a=r.output,o=t.get(r.assetId.toString())??0n,c=zc(o,a.amt.value());if(!c)return;t.set(r.assetId.toString(),o-c),i.push(Rs.fromUtxoAndSigindicies(r,e.sigIndicies)),s.push(r);const d=a.amt.value()-c;d>0&&n.push(new Ps(r.assetId,new ws(new Kn(d),u)))})),{utxos:e,fromAddresses:a,options:r,...o,amountsToBurn:t,inputs:i,changeOutputs:n,inputUTXOs:s}},td=(t,e,r,n)=>Cs.fromNative(t.networkID,t.xBlockchainID,e,r,n),ed=(t,e,r,n)=>Cs.fromNative(t.networkID,t.pBlockchainID,e,r,n);var rd=Object.freeze({__proto__:null,AvaxApi:qc,get FeeDimensions(){return Qu},Transaction:Pn,UnsignedTx:Zc,addDimensions:rc,baseTxUnsafeAvm:td,baseTxUnsafePvm:ed,createDimensions:ec,createEmptyDimensions:tc,dimensionsToGas:nc});const nd=(t,e,r,n,s,a,i,o)=>{e.sort(jc);const u=Kc([...e,...r]),c=Kc(n);if(!Object.entries(u).every((([t,e])=>c[t]&&c[t]>=e)))throw new Error("Not enough inputs to cover the outputs");return new Zc(new ta(td(t,r,n,a),an.fromString(s),e),i,o)};var sd=Object.freeze({__proto__:null,AVMApi:Xc,newBaseTx:function(t,e,r,n,s){const a=hs(e),i=Wc(e,s),o=new Map([[t.avaxAssetID,t.baseTxFee]]);n.forEach((t=>{const e=t.assetId.value();o.set(e,(o.get(e)||0n)+t.output.amount())}));const{inputs:u,inputUTXOs:c,changeOutputs:d,addressMaps:f}=$c(o,void 0,r,a,i,[Qc]),l=[...n,...d];return l.sort(jc),new Zc(new Us(td(t,l,u,i.memo)),c,f)},newExportTx:function(t,e,r,n,s,a){const i=hs(r),o=Wc(r,a),u=new Map([[t.avaxAssetID,t.baseTxFee]]);s.forEach((t=>{const e=t.assetId.value();u.set(e,(u.get(e)||0n)+t.output.amount())}));const{inputs:c,changeOutputs:d,inputUTXOs:f,addressMaps:l}=$c(u,void 0,n,i,o,[Qc]);return s.sort(jc),nd(t,s,d,c,e,o.memo,f,l)},newImportTx:function(t,e,r,n,s,a,i=1,o=0n){const u=hs(s),c=Wc(s,a),{importedAmounts:d,importedInputs:f,inputUTXOs:l}=((t,e,r)=>{const n=hs(e);return t.reduce(((t,e)=>{const{importedInputs:s,inputUTXOs:a,importedAmounts:i}=t,o=e.output;if(!rs(o))return t;const u=Fu(o.outputOwners,n,r);return u?(s.push(Rs.fromUtxoAndSigindicies(e,u.sigIndicies)),a.push(e),i[e.getAssetId()]=(i[e.getAssetId()]??0n)+o.amount(),t):t}),{importedInputs:[],inputUTXOs:[],importedAmounts:{}})})(r,s,c.minIssuanceTime);if(!f.length)throw new Error("no UTXOs available to import");f.sort(Rs.compare);const h=Xu.fromTransferableInputs(f,r,c.minIssuanceTime,s),p=d[t.avaxAssetID]??0n;let m={inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new Xu};const g=t.baseTxFee,b=t.avaxAssetID;if(p>g)d[b]-=g;else{if(p<g){const t=new Map([[b,g-p]]);m=$c(t,void 0,r,u,c,[Qc])}delete d[b]}return l.push(...m.inputUTXOs||[]),h.merge(m.addressMaps||new Xu),Object.entries(d).forEach((([t,e])=>{m.changeOutputs.push(Ps.fromNative(t,e,n,o,i))})),new Zc(new ra(Cs.fromNative(t.networkID,t.xBlockchainID,m.changeOutputs||[],m.inputs||[],c.memo),an.fromString(e),f),l,h)}});class ad extends Zc{hasPubkey(t){const e=new Le(this.publicKeyBytesToAddress(t)),r=new Le(Yi(t));return this.hasAddress(e)||this.hasAddress(r)}static fromJSON(t){const e=Zc.fromJSON(t);return new ad(e.tx,e.utxos,e.addressMaps,e.credentials)}}class id extends Mc{baseURL;constructor(t=Uc){super(t,"/ext/info","info"),this.baseURL=t}getNodeVersion(){return this.callRpc("getNodeVersion")}async getNodeId(){return this.callRpc("getNodeID")}getNodeIp(){return this.callRpc("getNodeIP")}getNetworkId(){return this.callRpc("getNetworkID")}getNetworkName(){return this.callRpc("getNetworkName")}getBlockchainId(t){return this.callRpc("getBlockchainID",{alias:t})}peers(t){return this.callRpc("peers",{nodeIDs:t})}isBootstrapped(t){return this.callRpc("peers",{chain:t})}uptime(){return this.callRpc("uptime")}getVMs(){return this.callRpc("getVMs")}getUpgradesInfo(){return this.callRpc("upgrades")}}var od=Object.freeze({__proto__:null,InfoApi:id});const ud=(t,e,r)=>{const n=e.calculateFee(),s=e.hasChangeOutput(r.avaxAssetID,t.changeOutputOwners);if(((t,e,r)=>{if(t<e)throw new Error(`Insufficient funds: provided UTXOs need ${e-t} more unlocked nAVAX (asset id: ${r.avaxAssetID}) to cover fee.`);return t!==e})(t.excessAVAX,n,r))if(s)e.addChangeOutput(new Ps(an.fromString(r.avaxAssetID),new ws(new Kn(t.excessAVAX-n),t.changeOutputOwners)));else{const n=e.calculateFee(new Ps(an.fromString(r.avaxAssetID),new ws(new Kn(0n),t.changeOutputOwners)));t.excessAVAX>n&&e.addChangeOutput(new Ps(an.fromString(r.avaxAssetID),new ws(new Kn(t.excessAVAX-n),t.changeOutputOwners)))}return t},cd=new Error("StakeableLockOut transferOut must be a TransferOutput."),dd=(t,e)=>{const r=t.utxos.filter((t=>e=>{if(!ns(e.output))return!1;if(t.minIssuanceTime>=e.output.getLocktime())return!1;if(!rs(e.output.transferOut))throw cd;return!!t.toStake.has(e.assetId.value())})(t)),n=Jc(r,(t=>t.output.transferOut),t.fromAddresses,t.minIssuanceTime);for(const{sigData:r,data:s}of n){const n=Gu(s);if(0n===(t.toStake.get(n.assetId)??0n))continue;e.addInput(s,new Rs(s.utxoId,s.assetId,new Wa(new Kn(n.stakeableLocktime),Os.fromNative(n.amount,r.sigIndicies))));const[a]=e.consumeLockedStakableAsset(n.assetId,n.amount);e.addStakedOutput(new Ps(s.assetId,new Za(new Kn(n.stakeableLocktime),new ws(new Kn(n.amount-a),s.getOutputOwners())))),a>0n&&e.addChangeOutput(new Ps(s.assetId,new Za(new Kn(n.stakeableLocktime),new ws(new Kn(a),s.getOutputOwners()))))}return t},fd=(t,e,r)=>{const n=Jc(t.utxos.filter((t=>e=>{if(!ns(e.output)&&!rs(e.output))return!1;if(ns(e.output)&&!rs(e.output.transferOut))throw cd;return e.output.getLocktime()<t.minIssuanceTime})(t)),(t=>rs(t.output)?t.output:t.output.transferOut),t.fromAddresses,t.minIssuanceTime),{otherVerifiedUsableUTXOs:s,avaxVerifiedUsableUTXOs:a}=n.reduce(((t,e)=>e.data.assetId.value()===r.avaxAssetID?{...t,avaxVerifiedUsableUTXOs:[...t.avaxVerifiedUsableUTXOs,e]}:{...t,otherVerifiedUsableUTXOs:[...t.otherVerifiedUsableUTXOs,e]}),{otherVerifiedUsableUTXOs:[],avaxVerifiedUsableUTXOs:[]});for(const{sigData:r,data:n}of s){const s=Gu(n),a=t.toBurn.get(s.assetId)??0n,i=t.toStake.get(s.assetId)??0n;if(0n===a&&0n===i)continue;e.addInput(n,new Rs(n.utxoId,n.assetId,Os.fromNative(s.amount,r.sigIndicies)));const[o,u]=e.consumeAsset(s.assetId,s.amount);u>0n&&e.addStakedOutput(new Ps(n.assetId,new ws(new Kn(u),t.changeOutputOwners))),o>0n&&e.addChangeOutput(new Ps(n.assetId,new ws(new Kn(o),t.changeOutputOwners)))}let i=t.excessAVAX;for(const{sigData:n,data:s}of a){const a=e.calculateFee();if(!e.shouldConsumeAsset(r.avaxAssetID)&&i>=a)break;const o=Gu(s);e.addInput(s,new Rs(s.utxoId,s.assetId,Os.fromNative(o.amount,n.sigIndicies)));const[u,c]=e.consumeAsset(r.avaxAssetID,o.amount);c>0n&&e.addStakedOutput(new Ps(s.assetId,new ws(new Kn(c),t.changeOutputOwners))),i+=u}return{...t,excessAVAX:i}},ld=(t,e)=>{const r=e.verifyAssetsConsumed();if(r)throw r;return t},hd=(t,e)=>{const r=e.verifyGasUsage();if(r)throw r;return t},pd=(t,e)=>t.getAssetId()===e.getAssetId()&&(ns(t.output)&&ns(e.output)&&t.output.getStakeableLocktime()===e.output.getStakeableLocktime()&&t.output.getOutputOwners().equals(e.output.getOutputOwners())||rs(t.output)&&rs(e.output)&&t.output.outputOwners.equals(e.output.outputOwners)),md=(t,e)=>{if(ns(t.output)&&ns(e.output))return new Ps(t.assetId,new Za(t.output.lockTime,new ws(new Kn(t.amount()+e.amount()),t.output.getOutputOwners())));if(rs(t.output)&&rs(e.output))return new Ps(t.assetId,new ws(new Kn(t.amount()+e.amount()),t.output.outputOwners));throw new Error("Calling combine on incompatible TransferableOutputs")},gd=t=>((t,e,r)=>{const n=[];for(const s of t){let t=!1;for(let a=0;a<n.length;a++){const i=n[a];if(e(i,s)){n[a]=r(i,s),t=!0;break}}t||n.push(s)}return n})(t,pd,md);class bd{feeState;initialComplexity;shouldConsolidateOutputs;toBurn;toStake;weights;changeOutputs;inputs;stakeOutputs;inputUTXOs=[];constructor({changeOutputs:t,feeState:e,initialComplexity:r,inputs:n,shouldConsolidateOutputs:s,stakeOutputs:a,toBurn:i,toStake:o,weights:u}){this.feeState=e,this.initialComplexity=r,this.shouldConsolidateOutputs=s,this.toBurn=i,this.toStake=o,this.weights=u,this.changeOutputs=t,this.inputs=n,this.stakeOutputs=a}addInput(t,e){return this.inputs=[...this.inputs,e],this.inputUTXOs=[...this.inputUTXOs,t],this}addChangeOutput(t){return this.changeOutputs=[...this.changeOutputs,t],this}addStakedOutput(t){return this.stakeOutputs=[...this.stakeOutputs,t],this}getComplexity(t=tc()){return rc(this.initialComplexity,Bc(this.inputs),Ic(this.changeOutputs),Ic(this.stakeOutputs),t)}consolidateOutputs(){this.shouldConsolidateOutputs&&(this.changeOutputs=gd(this.changeOutputs),this.stakeOutputs=gd(this.stakeOutputs))}shouldConsumeLockedStakeableAsset(t){return this.toStake.has(t)&&0n!==this.toStake.get(t)}shouldConsumeAsset(t){return this.toBurn.has(t)&&0n!==this.toBurn.get(t)||this.shouldConsumeLockedStakeableAsset(t)}consumeLockedStakableAsset(t,e){if(e<0n)throw new Error("Amount to consume must be greater than or equal to 0");const r=this.toStake.get(t)??0n,n=zc(r,e);return this.toStake.set(t,r-n),[e-n,n]}consumeAsset(t,e){if(e<0n)throw new Error("Amount to consume must be greater than or equal to 0");const r=this.toBurn.get(t)??0n,n=zc(r,e);return this.toBurn.set(t,r-n),this.consumeLockedStakableAsset(t,e-n)}calculateGas(t){this.consolidateOutputs();return nc(this.getComplexity(t?Ic([t]):void 0),this.weights)}calculateFee(t){return this.calculateGas(t)*this.feeState.price}hasChangeOutput(t,e){return this.changeOutputs.some((r=>r.assetId.value()===t&&rs(r.output)&&r.output.outputOwners.equals(e)))}verifyAssetsConsumed(){for(const[t,e]of this.toStake)if(0n!==e)return new Error(`Insufficient funds! Provided UTXOs need ${e} more units of asset ${t} to stake`);for(const[t,e]of this.toBurn)if(0n!==e)return new Error(`Insufficient funds! Provided UTXOs need ${e} more units of asset ${t}`);return null}verifyGasUsage(){const t=this.calculateGas();return this.feeState.capacity<t?new Error(`Gas usage of transaction (${t.toString()}) exceeds capacity (${this.feeState.capacity.toString()})`):null}getInputsOutputs(){const t=this.calculateFee(),e=[...this.inputs].sort(Rs.compare),r=[...this.changeOutputs].sort(jc),n=[...this.stakeOutputs].sort(jc);return{changeOutputs:r,fee:t,inputs:e,inputUTXOs:this.inputUTXOs,stakeOutputs:n}}}const yd=({changeOutputOwners:t,excessAVAX:e=0n,feeState:r,fromAddresses:n,initialComplexity:s,minIssuanceTime:a,shouldConsolidateOutputs:i=!1,toBurn:o=new Map,toStake:u=new Map,utxos:c},d,f)=>{try{const l=t||ms.fromNative(n.map((t=>t.toBytes()))),h=new bd({changeOutputs:[],feeState:r,initialComplexity:s,inputs:[],shouldConsolidateOutputs:i,stakeOutputs:[],toBurn:o,toStake:u,weights:f.platformFeeConfig.weights});return[...d,ld,ud,hd].reduce(((t,e)=>e(t,h,f)),{changeOutputOwners:l,excessAVAX:e,initialComplexity:s,fromAddresses:n,minIssuanceTime:a,toBurn:o,toStake:u,utxos:c}),h.getInputsOutputs()}catch(t){if(t instanceof Error)throw t;throw new Error("An unexpected error occurred during spend calculation")}},wd=({fromAddressesBytes:t,changeAddressesBytes:e})=>ms.fromNative(e??t,0n,1),xd=({inputs:t,inputUTXOs:e,minIssuanceTime:r,fromAddressesBytes:n})=>Xu.fromTransferableInputs(t,e,r,n),Id=()=>BigInt(Math.floor((new Date).getTime()/1e3)),Bd=({changeAddressesBytes:t,feeState:e,fromAddressesBytes:r,memo:n=new Uint8Array,minIssuanceTime:s=Id(),outputs:a,utxos:i},o)=>{const u=hs(r),c=new Map;a.forEach((t=>{const e=t.assetId.value(),r=(c.get(e)??0n)+t.amount();c.set(e,r)}));const d=Sc(n),f=Ic(a),l=rc(sc,d,f),h=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:r}),excessAVAX:0n,feeState:e,fromAddresses:u,initialComplexity:l,minIssuanceTime:s,shouldConsolidateOutputs:!0,toBurn:c,utxos:i},[fd],o),{changeOutputs:p,inputs:m,inputUTXOs:g}=h,b=xd({inputs:m,inputUTXOs:g,minIssuanceTime:s,fromAddressesBytes:r}),y=[...a,...p].sort(jc);return new Zc(new ho(ed(o,y,m,n)),g,b)},Td=({feeState:t,fromAddressesBytes:e,locktime:r,memo:n=new Uint8Array,minIssuanceTime:s=Id(),sourceChainId:a,threshold:i,toAddressesBytes:o,utxos:u},c)=>{const d=hs(e),f=u.filter((t=>rs(t.output)&&t.assetId.toString()===c.avaxAssetID)),{importedInputs:l,importedAmounts:h,inputUtxos:p}=f.reduce(((t,e)=>{const{sigIndicies:r}=Fu(e.getOutputOwners(),d,s)||{};if(void 0===r)return t;const n=e.getAssetId();return{importedInputs:[...t.importedInputs,new Rs(e.utxoId,e.assetId,new Os(e.output.amt,new ls(r.map((t=>new Cn(t))))))],importedAmounts:{...t.importedAmounts,[n]:(t.importedAmounts[n]??0n)+e.output.amount()},inputUtxos:[...t.inputUtxos,e]}}),{importedInputs:[],importedAmounts:{},inputUtxos:[]});if(0===l.length)throw new Error("no UTXOs available to import");const m=h[c.avaxAssetID],g=Xu.fromTransferableInputs(l,f,s,e),b=Object.entries(h).filter((([t])=>t!==c.avaxAssetID)).map((([t,e])=>Ps.fromNative(t,e,o))),y=Sc(n),w=Bc(l),x=Ic(b),I=rc(fc,y,w,x),B=yd({changeOutputOwners:ms.fromNative(o,r,i),excessAVAX:m,feeState:t,fromAddresses:d,initialComplexity:I,minIssuanceTime:s,utxos:f},[fd],c),{changeOutputs:T,inputs:v}=B;return new Zc(new Xa(new Cs(new Cn(c.networkID),ln,[...b,...T].sort(jc),v,new Yn(n)),an.fromString(a),l.sort(Rs.compare)),p,g)},vd=({changeAddressesBytes:t,destinationChainId:e,feeState:r,fromAddressesBytes:n,memo:s=new Uint8Array,minIssuanceTime:a=Id(),outputs:i,utxos:o},u)=>{const c=hs(n),d=new Map;i.forEach((t=>{const e=t.assetId.value();d.set(e,(d.get(e)??0n)+t.output.amount())}));const f=Sc(s),l=Ic(i),h=rc(dc,f,l),p=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:c,initialComplexity:h,minIssuanceTime:a,toBurn:d,utxos:o},[fd],u),{changeOutputs:m,inputs:g,inputUTXOs:b}=p,y=xd({inputs:g,inputUTXOs:b,minIssuanceTime:a,fromAddressesBytes:n});return new Zc(new Fa(new Cs(new Cn(u.networkID),ln,m,g,new Yn(s)),an.fromString(e),[...i].sort(jc)),b,y)},Od=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,locktime:n,memo:s=new Uint8Array,minIssuanceTime:a=Id(),subnetOwners:i,threshold:o,utxos:u},c)=>{const d=Sc(s),f=vc(ms.fromNative(i,n,o)),l=rc(ic,d,f),h=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:hs(e),initialComplexity:l,minIssuanceTime:a,utxos:u},[fd],c),{changeOutputs:p,inputs:m,inputUTXOs:g}=h,b=xd({inputs:m,inputUTXOs:g,minIssuanceTime:a,fromAddressesBytes:e}),y=new La(Cs.fromNative(c.networkID,c.pBlockchainID,p,m,s),ms.fromNative(i,n,o));return new Zc(y,g,b)},Sd=({changeAddressesBytes:t,chainName:e,feeState:r,fromAddressesBytes:n,fxIds:s,genesisData:a,memo:i=new Uint8Array,minIssuanceTime:o=Id(),subnetAuth:u,subnetId:c,utxos:d,vmId:f},l)=>{const h=new Yn((new TextEncoder).encode(JSON.stringify(a))),p=ls.fromNative(u),m=ec({bandwidth:s.length*sn+e.length+h.length+i.length,dbRead:0,dbWrite:0,compute:0}),g=Oc(p),b=rc(ac,m,g),y=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:hs(n),initialComplexity:b,minIssuanceTime:o,utxos:d},[fd],l),{changeOutputs:w,inputs:x,inputUTXOs:I}=y,B=xd({inputs:x,inputUTXOs:I,minIssuanceTime:o,fromAddressesBytes:n}),T=new Va(Cs.fromNative(l.networkID,l.pBlockchainID,w,x,i),an.fromString(c),new es(e),an.fromString(f),s.map(an.fromString.bind(an)),h,p);return new Zc(T,I,B)},Ad=({changeAddressesBytes:t,end:e,feeState:r,fromAddressesBytes:n,nodeId:s,memo:a=new Uint8Array,minIssuanceTime:i=Id(),start:o,subnetAuth:u,subnetId:c,utxos:d,weight:f},l)=>{const h=Sc(a),p=Oc(ls.fromNative(u)),m=rc(cc,h,p),g=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:hs(n),initialComplexity:m,minIssuanceTime:i,utxos:d},[fd],l),{changeOutputs:b,inputs:y,inputUTXOs:w}=g,x=xd({inputs:y,inputUTXOs:w,minIssuanceTime:i,fromAddressesBytes:n}),I=new Ra(Cs.fromNative(l.networkID,l.pBlockchainID,b,y,a),Ea.fromNative(s,o,e,f,an.fromString(c)),ls.fromNative(u));return new Zc(I,w,x)},Ed=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,nodeId:n,memo:s=new Uint8Array,minIssuanceTime:a=Id(),subnetAuth:i,subnetId:o,utxos:u},c)=>{const d=Sc(s),f=Oc(ls.fromNative(i)),l=rc(lc,d,f),h=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:hs(e),initialComplexity:l,minIssuanceTime:a,utxos:u},[fd],c),{changeOutputs:p,inputs:m,inputUTXOs:g}=h,b=xd({inputs:m,inputUTXOs:g,minIssuanceTime:a,fromAddressesBytes:e}),y=new io(Cs.fromNative(c.networkID,c.pBlockchainID,p,m,s),dn.fromString(n),an.fromString(o),ls.fromNative(i));return new Zc(y,g,b)},kd=({changeAddressesBytes:t,delegatorRewardsOwner:e,end:r,feeState:n,fromAddressesBytes:s,locktime:a=0n,nodeId:i,memo:o=new Uint8Array,minIssuanceTime:u=Id(),publicKey:c,rewardAddresses:d,shares:f,signature:l,stakingAssetId:h,start:p,subnetId:m,threshold:g=1,utxos:b,weight:y},w)=>{const x=m===fn.toString(),I=h??w.avaxAssetID;if(x&&I!==w.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const B=new Map([[I,y]]),T=function(t,e){return t&&e?new no(new to(new Uint8Array(t),new Uint8Array(e))):new so}(c,l),v=ms.fromNative(d,a,g),O=ms.fromNative(e,0n),S=Sc(o),A=Tc(T),E=vc(v),k=vc(O),R=rc(oc,S,A,E,k),D=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:n,fromAddresses:hs(s),initialComplexity:R,minIssuanceTime:u,shouldConsolidateOutputs:!0,toStake:B,utxos:b},[dd,fd],w),{changeOutputs:P,inputs:_,inputUTXOs:C,stakeOutputs:N}=D,V=xd({inputs:_,inputUTXOs:C,minIssuanceTime:u,fromAddressesBytes:s}),U=new za(Cs.fromNative(w.networkID,w.pBlockchainID,P,_,o),Ea.fromNative(i,p,r,y,an.fromString(m)),T,N,v,O,new Cn(f));return new Zc(U,C,V)},Rd=({changeAddressesBytes:t,end:e,feeState:r,fromAddressesBytes:n,locktime:s=0n,nodeId:a,memo:i=new Uint8Array,minIssuanceTime:o=Id(),rewardAddresses:u,stakingAssetId:c,start:d,subnetId:f,threshold:l=1,utxos:h,weight:p},m)=>{const g=f===fn.toString(),b=c??m.avaxAssetID;if(g&&b!==m.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const y=new Map([[b,p]]),w=ms.fromNative(u,s,l),x=Sc(i),I=vc(w),B=rc(uc,x,I),T=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:hs(n),initialComplexity:B,minIssuanceTime:o,shouldConsolidateOutputs:!0,toStake:y,utxos:h},[dd,fd],m),{changeOutputs:v,inputs:O,inputUTXOs:S,stakeOutputs:A}=T,E=xd({inputs:O,inputUTXOs:S,minIssuanceTime:o,fromAddressesBytes:n}),k=new Ja(Cs.fromNative(m.networkID,m.pBlockchainID,v,O,i),Ea.fromNative(a,d,e,p,an.fromString(f)),A,w);return new Zc(k,S,E)},Dd=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,locktime:n=0n,memo:s=new Uint8Array,minIssuanceTime:a=Id(),subnetAuth:i,subnetId:o,subnetOwners:u,threshold:c=1,utxos:d},f)=>{const l=Sc(s),h=Oc(ls.fromNative(i)),p=vc(ms.fromNative(u,n,c)),m=rc(hc,l,h,p),g=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:hs(e),initialComplexity:m,minIssuanceTime:a,utxos:d},[fd],f),{changeOutputs:b,inputs:y,inputUTXOs:w}=g,x=xd({inputs:y,inputUTXOs:w,minIssuanceTime:a,fromAddressesBytes:e});return new Zc(new uo(Cs.fromNative(f.networkID,f.pBlockchainID,b,y,s),an.fromString(o),ls.fromNative(i),ms.fromNative(u,n,c)),w,x)},Pd=({address:t,chainId:e,changeAddressesBytes:r,feeState:n,fromAddressesBytes:s,memo:a=new Uint8Array,minIssuanceTime:i=BigInt(Math.floor((new Date).getTime()/1e3)),subnetAuth:o,subnetId:u,utxos:c,validators:d},f)=>{if(d.find((t=>t.getWeight()<=0n)))throw new Error("Validator weight must be greater than 0");const l=Sc(a,t),h=Oc(ls.fromNative(o)),p=Ec(d),m=d.sort(((t,e)=>rn(t.nodeId.toBytes(),e.nodeId.toBytes()))),g=new Map;for(const t of m)g.set(f.avaxAssetID,(g.get(f.avaxAssetID)??0n)+t.getBalance().value());const b=rc(mc,l,p,h),y=yd({changeOutputOwners:wd({changeAddressesBytes:r,fromAddressesBytes:s}),excessAVAX:0n,feeState:n,fromAddresses:hs(s),initialComplexity:b,minIssuanceTime:i,toBurn:g,utxos:c},[fd],f),{changeOutputs:w,inputs:x,inputUTXOs:I}=y,B=xd({inputs:x,inputUTXOs:I,minIssuanceTime:i,fromAddressesBytes:s});return new Zc(new wo(Cs.fromNative(f.networkID,f.pBlockchainID,w,x,a),an.fromString(u),an.fromString(e),new Yn(t),m,ls.fromNative(o)),I,B)},_d=({balance:t,blsSignature:e,changeAddressesBytes:r,feeState:n,fromAddressesBytes:s,memo:a=new Uint8Array,message:i,minIssuanceTime:o=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:u},c)=>{const d=new Yn(i),f=new Map([[c.avaxAssetID,t]]),l=Sc(a),h=Ac(d),p=rc(gc,l,h),m=yd({changeOutputOwners:wd({changeAddressesBytes:r,fromAddressesBytes:s}),excessAVAX:0n,feeState:n,fromAddresses:hs(s),initialComplexity:p,minIssuanceTime:o,toBurn:f,utxos:u},[fd],c),{changeOutputs:g,inputs:b,inputUTXOs:y}=m,w=xd({inputs:b,inputUTXOs:y,minIssuanceTime:o,fromAddressesBytes:s});return new Zc(new Ao(Cs.fromNative(c.networkID,c.pBlockchainID,g,b,a),new Kn(t),Jr.fromSignatureBytes(e),d),y,w)},Cd=({changeAddressesBytes:t,feeState:e,fromAddressesBytes:r,memo:n=new Uint8Array,message:s,minIssuanceTime:a=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:i},o)=>{const u=new Yn(s),c=Sc(n),d=Ac(u),f=rc(bc,c,d),l=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:r}),excessAVAX:0n,feeState:e,fromAddresses:hs(r),initialComplexity:f,minIssuanceTime:a,utxos:i},[fd],o),{changeOutputs:h,inputs:p,inputUTXOs:m}=l,g=xd({inputs:p,inputUTXOs:m,minIssuanceTime:a,fromAddressesBytes:r});return new Zc(new Oo(Cs.fromNative(o.networkID,o.pBlockchainID,h,p,n),u),m,g)},Nd=({balance:t,changeAddressesBytes:e,feeState:r,fromAddressesBytes:n,memo:s=new Uint8Array,minIssuanceTime:a=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:i,validationId:o},u)=>{if(t<=0n)throw new Error("Balance must be greater than 0");const c=new Map([[u.avaxAssetID,t]]),d=Sc(s),f=rc(yc,d),l=yd({changeOutputOwners:wd({changeAddressesBytes:e,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:hs(n),initialComplexity:f,minIssuanceTime:a,toBurn:c,utxos:i},[fd],u),{changeOutputs:h,inputs:p,inputUTXOs:m}=l,g=xd({inputs:p,inputUTXOs:m,minIssuanceTime:a,fromAddressesBytes:n});return new Zc(new Io(Cs.fromNative(u.networkID,u.pBlockchainID,h,p,s),an.fromString(o),new Kn(t)),m,g)},Vd=({changeAddressesBytes:t,disableAuth:e,feeState:r,fromAddressesBytes:n,memo:s=new Uint8Array,minIssuanceTime:a=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:i,validationId:o},u)=>{const c=ls.fromNative(e),d=Sc(s),f=Oc(c),l=rc(wc,d,f),h=yd({changeOutputOwners:wd({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:r,fromAddresses:hs(n),initialComplexity:l,minIssuanceTime:a,utxos:i},[fd],u),{changeOutputs:p,inputs:m,inputUTXOs:g}=h,b=xd({inputs:m,inputUTXOs:g,minIssuanceTime:a,fromAddressesBytes:n});return new Zc(new To(Cs.fromNative(u.networkID,u.pBlockchainID,p,m,s),an.fromString(o),c),g,b)};var Ud=Object.freeze({__proto__:null,newAddPermissionlessDelegatorTx:Rd,newAddPermissionlessValidatorTx:kd,newAddSubnetValidatorTx:Ad,newBaseTx:Bd,newConvertSubnetToL1Tx:Pd,newCreateChainTx:Sd,newCreateSubnetTx:Od,newDisableL1ValidatorTx:Vd,newExportTx:vd,newImportTx:Td,newIncreaseL1ValidatorBalanceTx:Nd,newRegisterL1ValidatorTx:_d,newRemoveSubnetValidatorTx:Ed,newSetL1ValidatorWeightTx:Cd,newTransferSubnetOwnershipTx:Dd});class Ld extends qc{constructor(t){super(t,"/ext/bc/P","platform",Ro())}getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getCurrentValidators(t){return this.callRpc("getCurrentValidators",t)}getPendingValidators(t){return this.callRpc("getPendingValidators",t)}async getRewardUTXOs(t){const e=await this.callRpc("getRewardUTXOs",t);return{...e,utxos:e.utxos.map((t=>Ro().unpack(Ee(t),Nc)))}}async getStake(t){const e=await this.callRpc("getStake",t);return{...e,stakedOutputs:e.stakedOutputs.map((t=>Ro().unpack(Ee(t),Ps)))}}getValidatorsAt(t){return this.callRpc("getValidatorsAt",t)}getCurrentSupply(){return this.callRpc("getCurrentSupply")}getMaxStakeAmount(t){return this.callRpc("getMaxStakeAmount",t)}async getBalance(t){const e=await this.callRpc("getBalance",t);return{balance:BigInt(e.balance),unlocked:BigInt(e.unlocked),lockedStakeable:BigInt(e.lockedStakeable),lockedNotStakeable:BigInt(e.lockedNotStakeable),utxoIDs:e.utxoIDs}}getBlockchains(){return this.callRpc("getBlockchains")}getBlockchainStatus(t){return this.callRpc("getBlockchainStatus",{blockchainID:t})}getHeight(){return this.callRpc("getHeight")}getMinStake(){return this.callRpc("getMinStake")}getStakingAssetID(t){return this.callRpc("getStakingAssetID",t)}getSubnet(t){return this.callRpc("getSubnet",t)}getSubnets(t){return this.callRpc("getSubnets",t)}getTimestamp(){return this.callRpc("getTimestamp")}getTotalStake(t){return this.callRpc("getTotalStake",{subnetID:t})}getTxStatus(t){return this.callRpc("getTxStatus",t)}sampleValidators(t){return this.callRpc("sampleValidators",t)}validatedBy(t){return this.callRpc("validatedBy",t)}validates(t){return this.callRpc("validates",t)}async getFeeConfig(){const t=await this.callRpc("getFeeConfig"),{weights:e,maxCapacity:r,maxPerSecond:n,targetPerSecond:s,minPrice:a,excessConversionConstant:i}=t,[o,u,c,d]=e;return{weights:ec({bandwidth:o,dbRead:u,dbWrite:c,compute:d}),maxCapacity:BigInt(r),maxPerSecond:BigInt(n),targetPerSecond:BigInt(s),minPrice:BigInt(a),excessConversionConstant:BigInt(i)}}async getFeeState(){const t=await this.callRpc("getFeeState");return{capacity:BigInt(t.capacity),excess:BigInt(t.excess),price:BigInt(t.price),timestamp:t.timestamp}}async getL1Validator(t){const e=await this.callRpc("getL1Validator",{validationID:t}),r=mo.fromNative(e.deactivationOwner.addresses.map((t=>h(t)[2])),Number(e.deactivationOwner.threshold)),n=mo.fromNative(e.remainingBalanceOwner.addresses.map((t=>h(t)[2])),Number(e.remainingBalanceOwner.threshold));return{balance:BigInt(e.balance),nodeID:e.nodeID,publicKey:e.publicKey,subnetID:e.subnetID,weight:BigInt(e.weight),deactivationOwner:r,remainingBalanceOwner:n,startTime:BigInt(e.startTime),height:BigInt(e.height),minNonce:BigInt(e.minNonce)}}}var Md=Object.freeze({__proto__:null,INTRINSIC_ADD_PERMISSIONLESS_DELEGATOR_TX_COMPLEXITIES:uc,INTRINSIC_ADD_PERMISSIONLESS_VALIDATOR_TX_COMPLEXITIES:oc,INTRINSIC_ADD_SUBNET_VALIDATOR_TX_COMPLEXITIES:cc,INTRINSIC_BASE_TX_COMPLEXITIES:sc,INTRINSIC_CONVERT_SUBNET_TO_L1_TX_COMPLEXITIES:mc,INTRINSIC_CREATE_CHAIN_TX_COMPLEXITIES:ac,INTRINSIC_CREATE_SUBNET_TX_COMPLEXITIES:ic,INTRINSIC_DISABLE_L1_VALIDATOR_TX_COMPLEXITIES:wc,INTRINSIC_EXPORT_TX_COMPLEXITIES:dc,INTRINSIC_IMPORT_TX_COMPLEXITIES:fc,INTRINSIC_INCREASE_L1_VALIDATOR_BALANCE_TX_COMPLEXITIES:yc,INTRINSIC_REGISTER_L1_VALIDATOR_TX_COMPLEXITIES:gc,INTRINSIC_REMOVE_SUBNET_VALIDATOR_TX_COMPLEXITIES:lc,INTRINSIC_SET_L1_VALIDATOR_WEIGHT_TX_COMPLEXITIES:bc,INTRINSIC_TRANSFER_SUBNET_OWNERSHIP_TX_COMPLEXITIES:hc,PVMApi:Ld,calculateFee:Pc,e:Ud,getAuthComplexity:Oc,getBytesComplexity:Sc,getInputComplexity:Bc,getL1ValidatorsComplexity:Ec,getOutputComplexity:Ic,getOwnerComplexity:vc,getSignerComplexity:Tc,getTxComplexity:Dc,newAddPermissionlessDelegatorTx:Rd,newAddPermissionlessValidatorTx:kd,newAddSubnetValidatorTx:Ad,newBaseTx:Bd,newConvertSubnetToL1Tx:Pd,newCreateChainTx:Sd,newCreateSubnetTx:Od,newDisableL1ValidatorTx:Vd,newExportTx:vd,newImportTx:Td,newIncreaseL1ValidatorBalanceTx:Nd,newRegisterL1ValidatorTx:_d,newRemoveSubnetValidatorTx:Ed,newSetL1ValidatorWeightTx:Cd,newTransferSubnetOwnershipTx:Dd});var Fd=Object.freeze({__proto__:null,getContextFromURI:async(t,e="AVAX")=>{const r=new Ld(t),n=new Xc(t),{assetID:s}=await n.getAssetDescription(e),a=new id(t),{txFee:i,createAssetTxFee:o}=await n.getTxFee(),{blockchainID:u}=await a.getBlockchainId("X"),{blockchainID:c}=await a.getBlockchainId("P"),{blockchainID:d}=await a.getBlockchainId("C"),{networkID:f}=await a.getNetworkId(),l=Number(f),h=await r.getFeeConfig();return Object.freeze({xBlockchainID:u,pBlockchainID:c,cBlockchainID:d,avaxAssetID:s,baseTxFee:i,createAssetTxFee:o,networkID:l,hrp:kn(l),platformFeeConfig:h})}});class qd extends Mc{constructor(t){super(t,"/ext/bc/C/rpc")}async getBaseFee(){return BigInt(await this.callRpc("eth_baseFee"))}}function Xd(t,e,r,n,s,a,i,o,u){return e*Vu(jd(t,r,n,s,a,e,i,o,u))}function jd(t,e,r,n,s,a,i,o,u){o=o??t.avaxAssetID;const{threshold:c,locktime:d}=(t=>({locktime:0n,threshold:1,...t}))(u),f=[];t.avaxAssetID===o?f.push({assetId:t.avaxAssetID,amount:e+a}):(f.push({amount:a,assetId:t.avaxAssetID}),f.push({amount:e,assetId:o}));const l=f.map((({assetId:t,amount:e})=>new fa(new Le(n),new Kn(e),an.fromString(t),new Kn(i)))),h=[new Ps(an.fromString(o),new ws(new Kn(e),new ms(new Kn(d),new Cn(c),hs(s))))];return l.sort(fa.compare),new ad(new ha(new Cn(t.networkID),an.fromString(t.cBlockchainID),an.fromString(r),l,h),[],new Xu([new qu([[new Le(n),0]])]))}function Hd(t,e,r,n,s,a=0n,i=t.avaxAssetID){const o=hs(r),u=new Map;let c=[],d=[],f=0n;const l=[];n.forEach((t=>{const e=t.getAssetId(),r=t.output,n=r.amount();let s=n;i&&a&&f<a&&i===e&&(f+=s,f>a?(s=f-a,f=a):s=0n);const d=Fu(r.outputOwners,o,0n);if(!d)return;const h=new Rs(t.utxoId,t.assetId,Os.fromNative(n,d.sigIndicies));c.push(h),l.push(t);const p=u.get(e);p&&(s+=p),u.set(e,s)}));for(const[t,r]of u.entries())d.push(new ma(new Le(e),new Kn(r),an.fromString(t)));c=c.sort(Rs.compare);const h=Xu.fromTransferableInputs(c,n,0n,r);d=d.sort(Hc);const p=new ya(new Cn(t.networkID),an.fromString(t.cBlockchainID),an.fromString(s),c,d);return new ad(p,l,h)}var Kd=Object.freeze({__proto__:null,EVMApi:class extends Fc{ethAPI;constructor(t){super(t,"/ext/bc/C/avax","avax",xa()),this.ethAPI=new qd(t)}getAtomicTx=async t=>{const e=await this.callRpc("getAtomicTx",{...t,encoding:"hex"});return this.manager.unpack(Ee(e.tx),Co)};getBaseFee(){return this.ethAPI.getBaseFee()}getAtomicTxStatus(t){return this.callRpc("getAtomicTxStatus",{txID:t})}},estimateExportCost:Xd,newExportTx:jd,newExportTxFromBaseFee:function(t,e,r,n,s,a,i,o,u){return jd(t,r,n,s,a,Xd(t,e,r,n,s,a,i,o,u),i,o,u)},newImportTx:Hd,newImportTxFromBaseFee:function(t,e,r,n,s,a=0n,i){const o=function(t,e,r,n,s,a=0n,i){const o=Hd(t,e,r,n,s,a,i),u=Vu(o);return a*u}(t,e,r,n,s,a,i);return Hd(t,e,r,n,s,o,i)}});export{Pe as AVM,Le as Address,Kn as BigIntPr,tn as BlsPublicKey,Jr as BlsSignature,Gn as Bool,$n as Byte,Yn as Bytes,rd as Common,Fd as Context,ds as Credential,_e as EVM,ad as EVMUnsignedTx,an as Id,ls as Input,Cn as Int,bo as L1Validator,Is as MintOperation,bs as MintOutput,dn as NodeId,ms as OutputOwners,Ts as OutputOwnersList,mo as PChainOwner,Ce as PVM,Qn as Short,us as Signature,es as Stringpr,Os as TransferInput,ws as TransferOutput,Rs as TransferableInput,Ps as TransferableOutput,Ss as TypeRegistry,Ve as TypeSymbols,Zc as UnsignedTx,Nc as Utxo,Ne as ValidVMs,Vc as addTxSignatures,Uo as avaxSerial,sd as avm,qo as avmSerial,Yr as bls,Kd as evm,Go as evmSerial,od as info,Dn as networkIDs,Md as pvm,Nu as pvmSerial,Qi as secp256k1,Cc as utils};
