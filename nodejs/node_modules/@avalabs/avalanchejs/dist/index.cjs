"use strict";var t=require("@scure/base"),e=require("@noble/hashes/utils"),r=require("@noble/hashes/sha256"),s=require("@noble/hashes/ripemd160"),n=require("util");function o(t,e,r,s){var n,o=arguments.length,a=o<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(t,e,r,s);else for(var i=t.length-1;i>=0;i--)(n=t[i])&&(a=(o<3?n(a):o>3?n(e,r,a):n(e,r))||a);return o>3&&a&&Object.defineProperty(e,r,a),a}function a(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}const i=Symbol.for("nodejs.util.inspect.custom");function u(t){const e=t.split("-");if(e.length<2)throw new Error(`Invalid address: ${t}`);const r=e[0],s=e[1],[n,o]=d(s);return[r,n,o]}function c(t){return u(t)[2]}function d(e){const{prefix:r,words:s}=t.bech32.decode(e);return[r,t.bech32.fromWords(s)]}function p(e,r){const s=t.bech32.toWords(r);return t.bech32.encode(e,s)}function f(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function l(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Expected Uint8Array");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function h(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const m=BigInt(2**32-1),x=BigInt(32);function g(t,e=!1){return e?{h:Number(t&m),l:Number(t>>x&m)}:{h:0|Number(t>>x&m),l:0|Number(t&m)}}function b(t,e=!1){let r=new Uint32Array(t.length),s=new Uint32Array(t.length);for(let n=0;n<t.length;n++){const{h:o,l:a}=g(t[n],e);[r[n],s[n]]=[o,a]}return[r,s]}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function y(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);var e;return t}class w{clone(){return this._cloneInto()}}const[I,B,T]=[[],[],[]],O=BigInt(0),S=BigInt(1),v=BigInt(2),A=BigInt(7),E=BigInt(256),P=BigInt(113);for(let t=0,e=S,r=1,s=0;t<24;t++){[r,s]=[s,(2*r+3*s)%5],I.push(2*(5*s+r)),B.push((t+1)*(t+2)/2%64);let n=O;for(let t=0;t<7;t++)e=(e<<S^(e>>A)*P)%E,e&v&&(n^=S<<(S<<BigInt(t))-S);T.push(n)}const[k,R]=b(T,!0),D=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),C=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class N extends w{constructor(t,e,r,s=!1,n=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=s,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,f(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var o;this.state=new Uint8Array(200),this.state32=(o=this.state,new Uint32Array(o.buffer,o.byteOffset,Math.floor(o.byteLength/4)))}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const s=(e+8)%10,n=(e+2)%10,o=r[n],a=r[n+1],i=D(o,a,1)^r[s],u=C(o,a,1)^r[s+1];for(let r=0;r<50;r+=10)t[e+r]^=i,t[e+r+1]^=u}let e=t[2],n=t[3];for(let r=0;r<24;r++){const s=B[r],o=D(e,n,s),a=C(e,n,s),i=I[r];e=t[i],n=t[i+1],t[i]=o,t[i+1]=a}for(let e=0;e<50;e+=10){for(let s=0;s<10;s++)r[s]=t[e+s];for(let s=0;s<10;s++)t[e+s]^=~r[(s+2)%10]&r[(s+4)%10]}t[0]^=k[s],t[1]^=R[s]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){h(this);const{blockLen:e,state:r}=this,s=(t=y(t)).length;for(let n=0;n<s;){const o=Math.min(e-this.pos,s-n);for(let e=0;e<o;e++)r[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:s}=this;t[r]^=e,128&e&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){h(this,!1),l(t),this.finish();const e=this.state,{blockLen:r}=this;for(let s=0,n=t.length;s<n;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,n-s);t.set(e.subarray(this.posOut,this.posOut+o),s),this.posOut+=o,s+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return f(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){l(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:s,rounds:n,enableXOF:o}=this;return t||(t=new N(e,r,s,o,n)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=n,t.suffix=r,t.outputLen=s,t.enableXOF=o,t.destroyed=this.destroyed,t}}const _=((t,e,r)=>function(t){const e=e=>t().update(y(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}((()=>new N(e,t,r))))(1,136,32),V=BigInt(0),U=BigInt(1),L=BigInt(2);function M(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const q=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function F(t){if(!M(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=q[t[r]];return e}function X(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function j(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const H=48,K=57,W=65,G=70,Z=97,$=102;function z(t){return t>=H&&t<=K?t-H:t>=W&&t<=G?t-(W-10):t>=Z&&t<=$?t-(Z-10):void 0}function Y(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(r);for(let e=0,n=0;e<r;e++,n+=2){const r=z(t.charCodeAt(n)),o=z(t.charCodeAt(n+1));if(void 0===r||void 0===o){const e=t[n]+t[n+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+n)}s[e]=16*r+o}return s}function J(t){return j(F(t))}function Q(t){if(!M(t))throw new Error("Uint8Array expected");return j(F(Uint8Array.from(t).reverse()))}function tt(t,e){return Y(t.toString(16).padStart(2*e,"0"))}function et(t,e){return tt(t,e).reverse()}function rt(t,e,r){let s;if("string"==typeof e)try{s=Y(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!M(e))throw new Error(`${t} must be hex string or Uint8Array`);s=Uint8Array.from(e)}const n=s.length;if("number"==typeof r&&n!==r)throw new Error(`${t} expected ${r} bytes, got ${n}`);return s}function st(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];if(!M(s))throw new Error("Uint8Array expected");e+=s.length}let r=new Uint8Array(e),s=0;for(let e=0;e<t.length;e++){const n=t[e];r.set(n,s),s+=n.length}return r}function nt(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function ot(t){let e;for(e=0;t>V;t>>=U,e+=1);return e}function at(t,e){return t>>BigInt(e)&U}const it=t=>(L<<BigInt(t-1))-U,ut=t=>new Uint8Array(t),ct=t=>Uint8Array.from(t);function dt(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let s=ut(t),n=ut(t),o=0;const a=()=>{s.fill(1),n.fill(0),o=0},i=(...t)=>r(n,s,...t),u=(t=ut())=>{n=i(ct([0]),t),s=i(),0!==t.length&&(n=i(ct([1]),t),s=i())},c=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){s=i();const e=s.slice();r.push(e),t+=s.length}return st(...r)};return(t,e)=>{let r;for(a(),u(t);!(r=e(c()));)u();return a(),r}}const pt={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||M(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function ft(t,e,r={}){const s=(e,r,s)=>{const n=pt[r];if("function"!=typeof n)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(s&&void 0===o||n(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))s(t,r,!1);for(const[t,e]of Object.entries(r))s(t,e,!0);return t}var lt=Object.freeze({__proto__:null,bitGet:at,bitLen:ot,bitMask:it,bitSet:(t,e,r)=>t|(r?U:V)<<BigInt(e),bytesToHex:F,bytesToNumberBE:J,bytesToNumberLE:Q,concatBytes:st,createHmacDrbg:dt,ensureBytes:rt,equalBytes:function(t,e){if(t.length!==e.length)return!1;let r=0;for(let s=0;s<t.length;s++)r|=t[s]^e[s];return 0===r},hexToBytes:Y,hexToNumber:j,isBytes:M,numberToBytesBE:tt,numberToBytesLE:et,numberToHexUnpadded:X,numberToVarBytesBE:function(t){return Y(X(t))},utf8ToBytes:nt,validateObject:ft});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ht=BigInt(0),mt=BigInt(1),xt=BigInt(2),gt=BigInt(3),bt=BigInt(4),yt=BigInt(5),wt=BigInt(8);function It(t,e){const r=t%e;return r>=ht?r:e+r}function Bt(t,e,r){if(r<=ht||e<ht)throw new Error("Expected power/modulo > 0");if(r===mt)return ht;let s=mt;for(;e>ht;)e&mt&&(s=s*t%r),t=t*t%r,e>>=mt;return s}function Tt(t,e,r){let s=t;for(;e-- >ht;)s*=s,s%=r;return s}function Ot(t,e){if(t===ht||e<=ht)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=It(t,e),s=e,n=ht,o=mt;for(;r!==ht;){const t=s%r,e=n-o*(s/r);s=r,r=t,n=o,o=e}if(s!==mt)throw new Error("invert: does not exist");return It(n,e)}function St(t){if(t%bt===gt){const e=(t+mt)/bt;return function(t,r){const s=t.pow(r,e);if(!t.eql(t.sqr(s),r))throw new Error("Cannot find square root");return s}}if(t%wt===yt){const e=(t-yt)/wt;return function(t,r){const s=t.mul(r,xt),n=t.pow(s,e),o=t.mul(r,n),a=t.mul(t.mul(o,xt),n),i=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(i),r))throw new Error("Cannot find square root");return i}}return function(t){const e=(t-mt)/xt;let r,s,n;for(r=t-mt,s=0;r%xt===ht;r/=xt,s++);for(n=xt;n<t&&Bt(n,e,t)!==t-mt;n++);if(1===s){const e=(t+mt)/bt;return function(t,r){const s=t.pow(r,e);if(!t.eql(t.sqr(s),r))throw new Error("Cannot find square root");return s}}const o=(r+mt)/xt;return function(t,a){if(t.pow(a,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=s,u=t.pow(t.mul(t.ONE,n),r),c=t.pow(a,o),d=t.pow(a,r);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(d);e<i&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(u,mt<<BigInt(i-e-1));u=t.sqr(r),c=t.mul(c,r),d=t.mul(d,u),i=e}return c}}(t)}BigInt(9),BigInt(16);const vt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function At(t){return ft(t,vt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Et(t,e,r){if(r<ht)throw new Error("Expected power > 0");if(r===ht)return t.ONE;if(r===mt)return e;let s=t.ONE,n=e;for(;r>ht;)r&mt&&(s=t.mul(s,n)),n=t.sqr(n),r>>=mt;return s}function Pt(t,e){const r=new Array(e.length),s=e.reduce(((e,s,n)=>t.is0(s)?e:(r[n]=e,t.mul(e,s))),t.ONE),n=t.inv(s);return e.reduceRight(((e,s,n)=>t.is0(s)?e:(r[n]=t.mul(e,r[n]),t.mul(e,s))),n),r}function kt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Rt(t,e,r=!1,s={}){if(t<=ht)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:n,nByteLength:o}=kt(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=St(t),i=Object.freeze({ORDER:t,BITS:n,BYTES:o,MASK:it(n),ZERO:ht,ONE:mt,create:e=>It(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return ht<=e&&e<t},is0:t=>t===ht,isOdd:t=>(t&mt)===mt,neg:e=>It(-e,t),eql:(t,e)=>t===e,sqr:e=>It(e*e,t),add:(e,r)=>It(e+r,t),sub:(e,r)=>It(e-r,t),mul:(e,r)=>It(e*r,t),pow:(t,e)=>Et(i,t,e),div:(e,r)=>It(e*Ot(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Ot(e,t),sqrt:s.sqrt||(t=>a(i,t)),invertBatch:t=>Pt(i,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?et(t,o):tt(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?Q(t):J(t)}});return Object.freeze(i)}function Dt(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Ct(t){const e=Dt(t);return e+Math.ceil(e/2)}function Nt(t,e,r=!1){const s=t.length,n=Dt(e),o=Ct(e);if(s<16||s<o||s>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${s}`);const a=It(r?J(t):Q(t),e-mt)+mt;return r?et(a,n):tt(a,n)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=BigInt(0),Vt=BigInt(1);function Ut(t){return At(t.Fp),ft(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...kt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:Lt,hexToBytes:Mt}=lt,qt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=qt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],s=t.subarray(2,r+2);if(!r||s.length!==r)throw new e("Invalid signature integer: wrong length");if(128&s[0])throw new e("Invalid signature integer: negative");if(0===s[0]&&!(128&s[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Lt(s),l:t.subarray(r+2)}},toSig(t){const{Err:e}=qt,r="string"==typeof t?Mt(t):t;if(!M(r))throw new Error("ui8a expected");let s=r.length;if(s<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==s-2)throw new e("Invalid signature: incorrect length");const{d:n,l:o}=qt._parseInt(r.subarray(2)),{d:a,l:i}=qt._parseInt(o);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:n,s:a}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},s=e(r(t.s)),n=e(r(t.r)),o=s.length/2,a=n.length/2,i=r(o),u=r(a);return`30${r(a+o+4)}02${u}${n}02${i}${s}`}},Ft=BigInt(0),Xt=BigInt(1),jt=BigInt(2),Ht=BigInt(3),Kt=BigInt(4);function Wt(t){const e=function(t){const e=Ut(t);ft(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:s,a:n}=e;if(r){if(!s.eql(n,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,s=e.toBytes||((t,e,s)=>{const n=e.toAffine();return st(Uint8Array.from([4]),r.toBytes(n.x),r.toBytes(n.y))}),n=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:s,b:n}=e,o=r.sqr(t),a=r.mul(o,t);return r.add(r.add(a,r.mul(t,s)),n)}if(!r.eql(r.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(t){return"bigint"==typeof t&&Ft<t&&t<e.n}function i(t){if(!a(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function u(t){const{allowedPrivateKeyLengths:r,nByteLength:s,wrapPrivateKey:n,n:o}=e;if(r&&"bigint"!=typeof t){if(M(t)&&(t=F(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*s,"0")}let a;try{a="bigint"==typeof t?t:J(rt("private key",t,s))}catch(e){throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof t}`)}return n&&(a=It(a,o)),i(a),a}const c=new Map;function d(t){if(!(t instanceof p))throw new Error("ProjectivePoint expected")}class p{constructor(t,e,s){if(this.px=t,this.py=e,this.pz=s,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==s||!r.isValid(s))throw new Error("z required")}static fromAffine(t){const{x:e,y:s}=t||{};if(!t||!r.isValid(e)||!r.isValid(s))throw new Error("invalid affine point");if(t instanceof p)throw new Error("projective point not allowed");const n=t=>r.eql(t,r.ZERO);return n(e)&&n(s)?p.ZERO:new p(e,s,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(p.fromAffine)}static fromHex(t){const e=p.fromAffine(n(rt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return p.BASE.multiply(u(t))}_setWindowSize(t){this._WINDOW_SIZE=t,c.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:s}=this.toAffine();if(!r.isValid(t)||!r.isValid(s))throw new Error("bad point: x or y not FE");const n=r.sqr(s),a=o(t);if(!r.eql(n,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){d(t);const{px:e,py:s,pz:n}=this,{px:o,py:a,pz:i}=t,u=r.eql(r.mul(e,i),r.mul(o,n)),c=r.eql(r.mul(s,i),r.mul(a,n));return u&&c}negate(){return new p(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:s}=e,n=r.mul(s,Ht),{px:o,py:a,pz:i}=this;let u=r.ZERO,c=r.ZERO,d=r.ZERO,f=r.mul(o,o),l=r.mul(a,a),h=r.mul(i,i),m=r.mul(o,a);return m=r.add(m,m),d=r.mul(o,i),d=r.add(d,d),u=r.mul(t,d),c=r.mul(n,h),c=r.add(u,c),u=r.sub(l,c),c=r.add(l,c),c=r.mul(u,c),u=r.mul(m,u),d=r.mul(n,d),h=r.mul(t,h),m=r.sub(f,h),m=r.mul(t,m),m=r.add(m,d),d=r.add(f,f),f=r.add(d,f),f=r.add(f,h),f=r.mul(f,m),c=r.add(c,f),h=r.mul(a,i),h=r.add(h,h),f=r.mul(h,m),u=r.sub(u,f),d=r.mul(h,l),d=r.add(d,d),d=r.add(d,d),new p(u,c,d)}add(t){d(t);const{px:s,py:n,pz:o}=this,{px:a,py:i,pz:u}=t;let c=r.ZERO,f=r.ZERO,l=r.ZERO;const h=e.a,m=r.mul(e.b,Ht);let x=r.mul(s,a),g=r.mul(n,i),b=r.mul(o,u),y=r.add(s,n),w=r.add(a,i);y=r.mul(y,w),w=r.add(x,g),y=r.sub(y,w),w=r.add(s,o);let I=r.add(a,u);return w=r.mul(w,I),I=r.add(x,b),w=r.sub(w,I),I=r.add(n,o),c=r.add(i,u),I=r.mul(I,c),c=r.add(g,b),I=r.sub(I,c),l=r.mul(h,w),c=r.mul(m,b),l=r.add(c,l),c=r.sub(g,l),l=r.add(g,l),f=r.mul(c,l),g=r.add(x,x),g=r.add(g,x),b=r.mul(h,b),w=r.mul(m,w),g=r.add(g,b),b=r.sub(x,b),b=r.mul(h,b),w=r.add(w,b),x=r.mul(g,w),f=r.add(f,x),x=r.mul(I,w),c=r.mul(y,c),c=r.sub(c,x),x=r.mul(y,g),l=r.mul(I,l),l=r.add(l,x),new p(c,f,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(p.ZERO)}wNAF(t){return l.wNAFCached(this,c,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(p.fromAffine)}))}multiplyUnsafe(t){const s=p.ZERO;if(t===Ft)return s;if(i(t),t===Xt)return this;const{endo:n}=e;if(!n)return l.unsafeLadder(this,t);let{k1neg:o,k1:a,k2neg:u,k2:c}=n.splitScalar(t),d=s,f=s,h=this;for(;a>Ft||c>Ft;)a&Xt&&(d=d.add(h)),c&Xt&&(f=f.add(h)),h=h.double(),a>>=Xt,c>>=Xt;return o&&(d=d.negate()),u&&(f=f.negate()),f=new p(r.mul(f.px,n.beta),f.py,f.pz),d.add(f)}multiply(t){i(t);let s,n,o=t;const{endo:a}=e;if(a){const{k1neg:t,k1:e,k2neg:i,k2:u}=a.splitScalar(o);let{p:c,f:d}=this.wNAF(e),{p:f,f:h}=this.wNAF(u);c=l.constTimeNegate(t,c),f=l.constTimeNegate(i,f),f=new p(r.mul(f.px,a.beta),f.py,f.pz),s=c.add(f),n=d.add(h)}else{const{p:t,f:e}=this.wNAF(o);s=t,n=e}return p.normalizeZ([s,n])[0]}multiplyAndAddUnsafe(t,e,r){const s=p.BASE,n=(t,e)=>e!==Ft&&e!==Xt&&t.equals(s)?t.multiply(e):t.multiplyUnsafe(e),o=n(this,e).add(n(t,r));return o.is0()?void 0:o}toAffine(t){const{px:e,py:s,pz:n}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(n));const a=r.mul(e,t),i=r.mul(s,t),u=r.mul(n,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:a,y:i}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Xt)return!0;if(r)return r(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Xt?this:r?r(p,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),s(p,this,t)}toHex(t=!0){return F(this.toRawBytes(t))}}p.BASE=new p(e.Gx,e.Gy,r.ONE),p.ZERO=new p(r.ZERO,r.ONE,r.ZERO);const f=e.nBitLength,l=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},s=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let s=t.ZERO,n=e;for(;r>_t;)r&Vt&&(s=s.add(n)),n=n.double(),r>>=Vt;return s},precomputeWindow(t,e){const{windows:r,windowSize:n}=s(e),o=[];let a=t,i=a;for(let t=0;t<r;t++){i=a,o.push(i);for(let t=1;t<n;t++)i=i.add(a),o.push(i);a=i.double()}return o},wNAF(e,n,o){const{windows:a,windowSize:i}=s(e);let u=t.ZERO,c=t.BASE;const d=BigInt(2**e-1),p=2**e,f=BigInt(e);for(let t=0;t<a;t++){const e=t*i;let s=Number(o&d);o>>=f,s>i&&(s-=p,o+=Vt);const a=e,l=e+Math.abs(s)-1,h=t%2!=0,m=s<0;0===s?c=c.add(r(h,n[a])):u=u.add(r(m,n[l]))}return{p:u,f:c}},wNAFCached(t,e,r,s){const n=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,n),1!==n&&e.set(t,s(o))),this.wNAF(n,o,r)}}}(p,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:p,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:a}}function Gt(t){const e=function(t){const e=Ut(t);return ft(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:s}=e,n=r.BYTES+1,o=2*r.BYTES+1;function a(t){return It(t,s)}function i(t){return Ot(t,s)}const{ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:d,isWithinCurveOrder:p}=Wt({...e,toBytes(t,e,s){const n=e.toAffine(),o=r.toBytes(n.x),a=st;return s?a(Uint8Array.from([e.hasEvenY()?2:3]),o):a(Uint8Array.from([4]),o,r.toBytes(n.y))},fromBytes(t){const e=t.length,s=t[0],a=t.subarray(1);if(e!==n||2!==s&&3!==s){if(e===o&&4===s){return{x:r.fromBytes(a.subarray(0,r.BYTES)),y:r.fromBytes(a.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${n} compressed bytes or ${o} uncompressed bytes`)}{const t=J(a);if(!(Ft<(i=t)&&i<r.ORDER))throw new Error("Point is not on curve");const e=d(t);let n=r.sqrt(e);return!(1&~s)!==((n&Xt)===Xt)&&(n=r.neg(n)),{x:t,y:n}}var i}}),f=t=>F(tt(t,e.nByteLength));function l(t){return t>s>>Xt}const h=(t,e,r)=>J(t.slice(e,r));class m{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=rt("compactSignature",t,2*r),new m(h(t,0,r),h(t,r,2*r))}static fromDER(t){const{r:e,s:r}=qt.toSig(rt("DER",t));return new m(e,r)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new m(this.r,this.s,t)}recoverPublicKey(t){const{r:s,s:n,recovery:o}=this,c=y(rt("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const d=2===o||3===o?s+e.n:s;if(d>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const p=1&o?"03":"02",l=u.fromHex(p+f(d)),h=i(d),m=a(-c*h),x=a(n*h),g=u.BASE.multiplyAndAddUnsafe(l,m,x);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Y(this.toDERHex())}toDERHex(){return qt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Y(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const x={isValidPrivateKey(t){try{return c(t),!0}catch(t){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const t=Ct(e.n);return Nt(e.randomBytes(t),e.n)},precompute:(t=8,e=u.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function g(t){const e=M(t),r="string"==typeof t,s=(e||r)&&t.length;return e?s===n||s===o:r?s===2*n||s===2*o:t instanceof u}const b=e.bits2int||function(t){const r=J(t),s=8*t.length-e.nBitLength;return s>0?r>>BigInt(s):r},y=e.bits2int_modN||function(t){return a(b(t))},w=it(e.nBitLength);function I(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Ft<=t&&t<w))throw new Error(`bigint expected < 2^${e.nBitLength}`);return tt(t,e.nByteLength)}function B(t,s,n=T){if(["recovered","canonical"].some((t=>t in n)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:d}=e;let{lowS:f,prehash:h,extraEntropy:x}=n;null==f&&(f=!0),t=rt("msgHash",t),h&&(t=rt("prehashed msgHash",o(t)));const g=y(t),w=c(s),B=[I(w),I(g)];if(null!=x){const t=!0===x?d(r.BYTES):x;B.push(rt("extraEntropy",t))}const O=st(...B),S=g;return{seed:O,k2sig:function(t){const e=b(t);if(!p(e))return;const r=i(e),s=u.BASE.multiply(e).toAffine(),n=a(s.x);if(n===Ft)return;const o=a(r*a(S+n*w));if(o===Ft)return;let c=(s.x===n?0:2)|Number(s.y&Xt),d=o;return f&&l(o)&&(d=function(t){return l(t)?a(-t):t}(o),c^=1),new m(n,d,c)}}}const T={lowS:e.lowS,prehash:!1},O={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return u.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(g(t))throw new Error("first arg must be private key");if(!g(e))throw new Error("second arg must be public key");return u.fromHex(e).multiply(c(t)).toRawBytes(r)},sign:function(t,r,s=T){const{seed:n,k2sig:o}=B(t,r,s),a=e;return dt(a.hash.outputLen,a.nByteLength,a.hmac)(n,o)},verify:function(t,r,s,n=O){const o=t;if(r=rt("msgHash",r),s=rt("publicKey",s),"strict"in n)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:d}=n;let p,f;try{if("string"==typeof o||M(o))try{p=m.fromDER(o)}catch(t){if(!(t instanceof qt.Err))throw t;p=m.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;p=new m(t,e)}}f=u.fromHex(s)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&p.hasHighS())return!1;d&&(r=e.hash(r));const{r:l,s:h}=p,x=y(r),g=i(h),b=a(x*g),w=a(l*g),I=u.BASE.multiplyAndAddUnsafe(f,b,w)?.toAffine();return!!I&&a(I.x)===l},ProjectivePoint:u,Signature:m,utils:x}}function Zt(t,e){if(At(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=function(t,e){const r=t.ORDER;let s=Ft;for(let t=r-Xt;t%jt===Ft;t/=jt)s+=Xt;const n=s,o=jt<<n-Xt-Xt,a=o*jt,i=(r-Xt)/a,u=(i-Xt)/jt,c=a-Xt,d=o,p=t.pow(e,i),f=t.pow(e,(i+Xt)/jt);let l=(e,r)=>{let s=p,o=t.pow(r,c),a=t.sqr(o);a=t.mul(a,r);let i=t.mul(e,a);i=t.pow(i,u),i=t.mul(i,o),o=t.mul(i,r),a=t.mul(i,e);let l=t.mul(a,o);i=t.pow(l,d);let h=t.eql(i,t.ONE);o=t.mul(a,f),i=t.mul(l,s),a=t.cmov(o,a,h),l=t.cmov(i,l,h);for(let e=n;e>Xt;e--){let r=e-jt;r=jt<<r-Xt;let n=t.pow(l,r);const i=t.eql(n,t.ONE);o=t.mul(a,s),s=t.mul(s,s),n=t.mul(l,s),a=t.cmov(o,a,i),l=t.cmov(n,l,i)}return{isValid:h,value:a}};if(t.ORDER%Kt===Ht){const r=(t.ORDER-Ht)/Kt,s=t.sqrt(t.neg(e));l=(e,n)=>{let o=t.sqr(n);const a=t.mul(e,n);o=t.mul(o,a);let i=t.pow(o,r);i=t.mul(i,a);const u=t.mul(i,s),c=t.mul(t.sqr(i),n),d=t.eql(c,e);return{isValid:d,value:t.cmov(u,i,d)}}}return l}(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return s=>{let n,o,a,i,u,c,d,p;n=t.sqr(s),n=t.mul(n,e.Z),o=t.sqr(n),o=t.add(o,n),a=t.add(o,t.ONE),a=t.mul(a,e.B),i=t.cmov(e.Z,t.neg(o),!t.eql(o,t.ZERO)),i=t.mul(i,e.A),o=t.sqr(a),c=t.sqr(i),u=t.mul(c,e.A),o=t.add(o,u),o=t.mul(o,a),c=t.mul(c,i),u=t.mul(c,e.B),o=t.add(o,u),d=t.mul(n,a);const{isValid:f,value:l}=r(o,c);p=t.mul(n,s),p=t.mul(p,l),d=t.cmov(d,a,f),p=t.cmov(p,l,f);const h=t.isOdd(s)===t.isOdd(p);return p=t.cmov(t.neg(p),p,h),d=t.div(d,i),{x:d,y:p}}}const $t=J;function zt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const r=Array.from({length:e}).fill(0);for(let s=e-1;s>=0;s--)r[s]=255&t,t>>>=8;return new Uint8Array(r)}function Yt(t,e){const r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t[s]^e[s];return r}function Jt(t){if(!M(t))throw new Error("Uint8Array expected")}function Qt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function te(t,e,r){ft(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:s,k:n,m:o,hash:a,expand:i,DST:u}=r;Jt(t),Qt(e);const c=function(t){if(M(t))return t;if("string"==typeof t)return nt(t);throw new Error("DST must be Uint8Array or string")}(u),d=s.toString(2).length,p=Math.ceil((d+n)/8),f=e*o*p;let l;if("xmd"===i)l=function(t,e,r,s){Jt(t),Jt(e),Qt(r),e.length>255&&(e=s(st(nt("H2C-OVERSIZE-DST-"),e)));const{outputLen:n,blockLen:o}=s,a=Math.ceil(r/n);if(a>255)throw new Error("Invalid xmd length");const i=st(e,zt(e.length,1)),u=zt(0,o),c=zt(r,2),d=new Array(a),p=s(st(u,t,c,zt(0,1),i));d[0]=s(st(p,zt(1,1),i));for(let t=1;t<=a;t++){const e=[Yt(p,d[t-1]),zt(t+1,1),i];d[t]=s(st(...e))}return st(...d).slice(0,r)}(t,c,f,a);else if("xof"===i)l=function(t,e,r,s,n){if(Jt(t),Jt(e),Qt(r),e.length>255){const t=Math.ceil(2*s/8);e=n.create({dkLen:t}).update(nt("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return n.create({dkLen:r}).update(t).update(zt(r,2)).update(e).update(zt(e.length,1)).digest()}(t,c,f,n,a);else{if("_internal_pass"!==i)throw new Error('expand must be "xmd" or "xof"');l=t}const h=new Array(e);for(let t=0;t<e;t++){const e=new Array(o);for(let r=0;r<o;r++){const n=p*(r+t*o),a=l.subarray(n,n+p);e[r]=It($t(a),s)}h[t]=e}return h}function ee(t,e){const r=e.map((t=>Array.from(t).reverse()));return(e,s)=>{const[n,o,a,i]=r.map((r=>r.reduce(((r,s)=>t.add(t.mul(r,e),s)))));return e=t.div(n,o),s=t.mul(s,t.div(a,i)),{x:e,y:s}}}function re(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(s,n){const o=te(s,2,{...r,DST:r.DST,...n}),a=t.fromAffine(e(o[0])),i=t.fromAffine(e(o[1])),u=a.add(i).clearCofactor();return u.assertValidity(),u},encodeToCurve(s,n){const o=te(s,1,{...r,DST:r.encodeDST,...n}),a=t.fromAffine(e(o[0])).clearCofactor();return a.assertValidity(),a}}}class se extends w{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");f(t.outputLen),f(t.blockLen)}(t);const r=y(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,n=new Uint8Array(s);n.set(r.length>s?t.create().update(r).digest():r);for(let t=0;t<n.length;t++)n[t]^=54;this.iHash.update(n),this.oHash=t.create();for(let t=0;t<n.length;t++)n[t]^=106;this.oHash.update(n),n.fill(0)}update(t){return h(this),this.iHash.update(t),this}digestInto(t){h(this),l(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:n,blockLen:o,outputLen:a}=this;return t.finished=s,t.destroyed=n,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ne=(t,e,r)=>new se(t,e).update(r).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function oe(t){return{hash:t,hmac:(r,...s)=>ne(t,r,e.concatBytes(...s)),randomBytes:e.randomBytes}}ne.create=(t,e)=>new se(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ae=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ie=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ue=BigInt(1),ce=BigInt(2),de=(t,e)=>(t+e/ce)/e;const pe=Rt(ae,void 0,void 0,{sqrt:function(t){const e=ae,r=BigInt(3),s=BigInt(6),n=BigInt(11),o=BigInt(22),a=BigInt(23),i=BigInt(44),u=BigInt(88),c=t*t*t%e,d=c*c*t%e,p=Tt(d,r,e)*d%e,f=Tt(p,r,e)*d%e,l=Tt(f,ce,e)*c%e,h=Tt(l,n,e)*l%e,m=Tt(h,o,e)*h%e,x=Tt(m,i,e)*m%e,g=Tt(x,u,e)*x%e,b=Tt(g,i,e)*m%e,y=Tt(b,r,e)*d%e,w=Tt(y,a,e)*h%e,I=Tt(w,s,e)*c%e,B=Tt(I,ce,e);if(!pe.eql(pe.sqr(B),t))throw new Error("Cannot find square root");return B}}),fe=function(t,e){const r=e=>Gt({...t,...oe(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:pe,n:ie,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ie,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-ue*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),n=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,a=BigInt("0x100000000000000000000000000000000"),i=de(o*t,e),u=de(-s*t,e);let c=It(t-i*r-u*n,e),d=It(-i*s-u*o,e);const p=c>a,f=d>a;if(p&&(c=e-c),f&&(d=e-d),c>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:p,k1:c,k2neg:f,k2:d}}}},r.sha256);BigInt(0),fe.ProjectivePoint,Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));
/*! micro-eth-signer - MIT License (c) 2021 Paul Miller (paulmillr.com) */
const le=t=>fe.getPublicKey(t,!1),he=t=>fe.ProjectivePoint.fromHex(t).toRawBytes(!1);function me(t){return/^0x/i.test(t)?t:`0x${t}`}function xe(t){return t.replace(/^0x/i,"")}function ge(t){return e.hexToBytes(xe(t))}const be={fromPrivateKey:t=>("string"==typeof t&&(t=ge(t)),be.fromPublicKey(le(t))),fromPublicKey(t){const r=he(t),s=e.bytesToHex(_(r.subarray(1,65))).slice(24);return be.checksum(s)},checksum(t){const r=xe(t.toLowerCase());if(40!==r.length)throw new Error("Invalid address, must have 40 chars");const s=xe(e.bytesToHex(_(r)));let n="";for(let t=0;t<r.length;t++){const e=Number.parseInt(s[t],16);let o=r[t];e>7&&(o=o.toUpperCase()),n+=o}return me(n)},verifyChecksum(t){const r=xe(t);if(40!==r.length)throw new Error("Invalid address, must have 40 chars");if(r===r.toLowerCase()||r===r.toUpperCase())return!0;const s=e.bytesToHex(_(r.toLowerCase()));for(let t=0;t<40;t++){const e=r[t],n=Number.parseInt(s[t],16);if(n>7&&e.toUpperCase()!==e)return!1;if(n<=7&&e.toLowerCase()!==e)return!1}return!0}};function ye(t){return BigInt(Be(t))}function we(t){return Number.parseInt(e.bytesToHex(t),16)}function Ie(t){return 1===we(t)}function Be(t){return me(e.bytesToHex(t))}function Te(t){return 1&(t=xe(t)).length&&(t="0"+t),e.hexToBytes(t)}function Oe(t,e){const r=e-t.length;if(r<=0)return t;const s=new Uint8Array(e);return s.set(t,r),s}const Se=t=>{let e=0;for(let r=0;r<t.length;r++){let s=t[r];for(;0!==s;)e+=1&s,s>>=1}return e};class ve{}const Ae="AVM",Ee="EVM",Pe="PVM",ke=[Ae,Ee,Pe];var Re,De;exports.TypeSymbols=void 0,(Re=exports.TypeSymbols||(exports.TypeSymbols={})).Codec="codec",Re.BaseTx="avax.BaseTx",Re.TransferableOutput="avax.TransferableOutput",Re.TransferableInput="avax.TransferableInput",Re.TransferableOp="avax.TransferableOp",Re.UTXOID="avax.UTXOID",Re.UTXO="avax.Utxo",Re.Id="common.Id",Re.Address="common.Address",Re.NodeId="common.NodeId",Re.BlsSignature="common.BlsSignature",Re.BlsPublicKey="common.BlsPublicKey",Re.Int="primitives.Int",Re.BigIntPr="primitives.BigInt",Re.StringPr="primitives.String",Re.Byte="primitives.Byte",Re.Bytes="primitives.Bytes",Re.Short="primitives.Short",Re.Bool="primitives.Bool",Re.Input="secp256k1fx.Input",Re.TransferInput="secp256k1fx.TransferInput",Re.TransferOutput="secp256k1fx.TransferOutput",Re.OutputOwners="secp256k1fx.OutputOwners",Re.OutputOwnersList="secp256k1fx.OutputOwnersList",Re.Credential="secp256k1fx.Credential",Re.Signature="secp256k1fx.Signature",Re.SecpMintOperation="secp256k1fx.MintOperation",Re.SecpMintOutput="secp256k1fx.MintOutput",Re.NftFxMintOperation="nftfx.MintOperation",Re.NftFxMintOutput="nftfx.MintOutput",Re.NftFxTransferOperation="nftfx.TransferOperation",Re.NftFxTransferOutput="nftfx.TransferOutput",Re.NftFxCredential="nftfx.Credential",Re.AvmBaseTx="avm.BaseTx",Re.AvmExportTx="avm.ExportTx",Re.AvmImportTx="avm.ImportTx",Re.CreateAssetTx="avm.CreateAssetTx",Re.OperationTx="avm.OperationTx",Re.InitialState="avm.InitialState",Re.AvmSignedTx="avm.SignedTx",Re.PvmBaseTx="pvm.BaseTx",Re.StakeableLockIn="pvm.StakeableLockIn",Re.StakeableLockOut="pvm.StakeableLockOut",Re.AddDelegatorTx="pvm.AddDelegatorTx",Re.AddValidatorTx="pvm.AddValidatorTx",Re.AddPermissionlessDelegatorTx="pvm.AddPermissionlessDelegator",Re.AddPermissionlessValidatorTx="pvm.AddPermissionlessValidator",Re.Validator="pvm.Validator",Re.SubnetValidator="pvm.SubnetValidator",Re.Signer="pvm.signer",Re.SignerEmpty="pvm.signerEmpty",Re.ProofOfPossession="pvm.proofOfPossession",Re.AddSubnetValidatorTx="pvm.AddSubnetValidator",Re.AdvanceTimeTx="pvm.AdvanceTimeTx",Re.CreateChainTx="pvm.CreateChainTx",Re.CreateSubnetTx="pvm.CreateSubnetTx",Re.PvmExportTx="pvm.ExportTx",Re.PvmImportTx="pvm.ImportTx",Re.RewardValidatorTx="pvm.RewardValidatorTx",Re.RemoveSubnetValidatorTx="pvm.RemoveSubnetValidator",Re.TransformSubnetTx="pvm.TransformSubnetTx",Re.TransferSubnetOwnershipTx="pvm.TransferSubnetOwnershipTx",Re.L1Validator="pvm.L1Validator",Re.ConvertSubnetToL1Tx="pvm.ConvertSubnetToL1Tx",Re.RegisterL1ValidatorTx="pvm.RegisterL1ValidatorTx",Re.SetL1ValidatorWeightTx="pvm.SetL1ValidatorWeightTx",Re.IncreaseL1ValidatorBalanceTx="pvm.IncreaseL1ValidatorBalanceTx",Re.DisableL1ValidatorTx="pvm.DisableL1ValidatorTx",Re.PChainOwner="pvm.PChainOwner",Re.EvmExportTx="evm.ExportTx",Re.EvmInput="evm.Input",Re.EvmOutput="evm.Output",Re.EvmImportTx="evm.ImportTx",Re.WarpMessage="warp.Message",Re.WarpUnsignedMessage="warp.UnsignedMessage",Re.WarpSignature="warp.Signature",Re.AddressedCall="warp.AddressedCall",Re.RegisterL1ValidatorMessage="warp.RegisterL1ValidatorMessage",Re.L1ValidatorWeightMessage="warp.L1ValidatorWeightMessage",Re.SubnetToL1ConversionMessage="warp.SubnetToL1ConversionMessage",Re.L1ValidatorRegistrationMessage="warp.L1ValidatorRegistrationMessage",Re.ValidatorData="warp.ValidatorData",Re.ConversionData="warp.ConversionData",exports.Address=De=class extends ve{address;_type=exports.TypeSymbols.Address;constructor(t){super(),this.address=t}static fromBytes(t){return[new De(t.slice(0,20)),t.slice(20)]}[i](t,e){return e.stylize(this.toJSON(),"string")}toJSON(t="avax"){return this.toString(t)}static fromString(t){return new De(c(t))}static fromHex(t){return new De(Te(t))}toHex(){return Be(this.address)}toBytes(){return Oe(this.address,20)}toString(t="avax"){return p(t,this.address)}value(){return this.toString()}},exports.Address=De=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Address);const Ce=BigInt(2),Ne=BigInt(3);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _e=BigInt(0),Ve=BigInt(1),Ue=BigInt(2),Le=BigInt(3),Me=BigInt(4),qe=BigInt(8),Fe=BigInt(16),Xe=BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),je=Rt(Xe),He=Rt(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")),Ke=({c0:t,c1:e},{c0:r,c1:s})=>({c0:je.add(t,r),c1:je.add(e,s)}),We=({c0:t,c1:e},{c0:r,c1:s})=>({c0:je.sub(t,r),c1:je.sub(e,s)}),Ge=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:je.mul(t,r),c1:je.mul(e,r)};const{c0:s,c1:n}=r;let o=je.mul(t,s),a=je.mul(e,n);return{c0:je.sub(o,a),c1:je.sub(je.mul(je.add(t,e),je.add(s,n)),je.add(o,a))}},Ze=({c0:t,c1:e})=>{const r=je.add(t,e),s=je.sub(t,e),n=je.add(t,t);return{c0:je.mul(r,s),c1:je.mul(n,e)}},$e=Xe*Xe,ze={ORDER:$e,BITS:ot($e),BYTES:Math.ceil(ot($e)/8),MASK:it(ot($e)),ZERO:{c0:je.ZERO,c1:je.ZERO},ONE:{c0:je.ONE,c1:je.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>"bigint"==typeof t&&"bigint"==typeof e,is0:({c0:t,c1:e})=>je.is0(t)&&je.is0(e),eql:({c0:t,c1:e},{c0:r,c1:s})=>je.eql(t,r)&&je.eql(e,s),neg:({c0:t,c1:e})=>({c0:je.neg(t),c1:je.neg(e)}),pow:(t,e)=>Et(ze,t,e),invertBatch:t=>Pt(ze,t),add:Ke,sub:We,mul:Ge,sqr:Ze,addN:Ke,subN:We,mulN:Ge,sqrN:Ze,div:(t,e)=>ze.mul(t,"bigint"==typeof e?je.inv(je.create(e)):ze.inv(e)),inv:({c0:t,c1:e})=>{const r=je.inv(je.create(t*t+e*e));return{c0:je.mul(r,je.create(t)),c1:je.mul(r,je.create(-e))}},sqrt:t=>{if(ze.eql(t,ze.ZERO))return ze.ZERO;const e=ze.pow(t,(ze.ORDER+qe)/Fe),r=ze.div(ze.sqr(e),t),s=Qe,n=[s[0],s[2],s[4],s[6]].find((t=>ze.eql(t,r)));if(!n)throw new Error("No root");const o=s.indexOf(n),a=s[o/2];if(!a)throw new Error("Invalid root");const i=ze.div(e,a),u=ze.neg(i),{re:c,im:d}=ze.reim(i),{re:p,im:f}=ze.reim(u);return d>f||d===f&&c>p?i:u},isOdd:t=>{const{re:e,im:r}=ze.reim(t);return BigInt(e%Ue||e===_e&&r%Ue)==Ve},fromBytes(t){if(t.length!==ze.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:je.fromBytes(t.subarray(0,je.BYTES)),c1:je.fromBytes(t.subarray(je.BYTES))}},toBytes:({c0:t,c1:e})=>st(je.toBytes(t),je.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:s},n)=>({c0:je.cmov(t,r,n),c1:je.cmov(e,s,n)}),reim:({c0:t,c1:e})=>({re:t,im:e}),mulByNonresidue:({c0:t,c1:e})=>({c0:je.sub(t,e),c1:je.add(t,e)}),multiplyByB:({c0:t,c1:e})=>{let r=je.mul(t,Me),s=je.mul(e,Me);return{c0:je.sub(r,s),c1:je.add(r,s)}},fromBigTuple:t=>{if(2!==t.length)throw new Error("Invalid tuple");const e=t.map((t=>je.create(t)));return{c0:e[0],c1:e[1]}},frobeniusMap:({c0:t,c1:e},r)=>({c0:t,c1:je.mul(e,Ye[r%2])})},Ye=[BigInt("0x1"),BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")].map((t=>je.create(t))),Je=BigInt("0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),Qe=[[Ve,_e],[Je,-Je],[_e,Ve],[Je,Je],[-Ve,_e],[-Je,Je],[_e,-Ve],[-Je,-Je]].map((t=>ze.fromBigTuple(t))),tr=({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>({c0:ze.add(t,s),c1:ze.add(e,n),c2:ze.add(r,o)}),er=({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>({c0:ze.sub(t,s),c1:ze.sub(e,n),c2:ze.sub(r,o)}),rr=({c0:t,c1:e,c2:r},s)=>{if("bigint"==typeof s)return{c0:ze.mul(t,s),c1:ze.mul(e,s),c2:ze.mul(r,s)};const{c0:n,c1:o,c2:a}=s,i=ze.mul(t,n),u=ze.mul(e,o),c=ze.mul(r,a);return{c0:ze.add(i,ze.mulByNonresidue(ze.sub(ze.mul(ze.add(e,r),ze.add(o,a)),ze.add(u,c)))),c1:ze.add(ze.sub(ze.mul(ze.add(t,e),ze.add(n,o)),ze.add(i,u)),ze.mulByNonresidue(c)),c2:ze.sub(ze.add(u,ze.mul(ze.add(t,r),ze.add(n,a))),ze.add(i,c))}},sr=({c0:t,c1:e,c2:r})=>{let s=ze.sqr(t),n=ze.mul(ze.mul(t,e),Ue),o=ze.mul(ze.mul(e,r),Ue),a=ze.sqr(r);return{c0:ze.add(ze.mulByNonresidue(o),s),c1:ze.add(ze.mulByNonresidue(a),n),c2:ze.sub(ze.sub(ze.add(ze.add(n,ze.sqr(ze.add(ze.sub(t,e),r))),o),s),a)}},nr={ORDER:ze.ORDER,BITS:3*ze.BITS,BYTES:3*ze.BYTES,MASK:it(3*ze.BITS),ZERO:{c0:ze.ZERO,c1:ze.ZERO,c2:ze.ZERO},ONE:{c0:ze.ONE,c1:ze.ZERO,c2:ze.ZERO},create:t=>t,isValid:({c0:t,c1:e,c2:r})=>ze.isValid(t)&&ze.isValid(e)&&ze.isValid(r),is0:({c0:t,c1:e,c2:r})=>ze.is0(t)&&ze.is0(e)&&ze.is0(r),neg:({c0:t,c1:e,c2:r})=>({c0:ze.neg(t),c1:ze.neg(e),c2:ze.neg(r)}),eql:({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>ze.eql(t,s)&&ze.eql(e,n)&&ze.eql(r,o),sqrt:()=>{throw new Error("Not implemented")},div:(t,e)=>nr.mul(t,"bigint"==typeof e?je.inv(je.create(e)):nr.inv(e)),pow:(t,e)=>Et(nr,t,e),invertBatch:t=>Pt(nr,t),add:tr,sub:er,mul:rr,sqr:sr,addN:tr,subN:er,mulN:rr,sqrN:sr,inv:({c0:t,c1:e,c2:r})=>{let s=ze.sub(ze.sqr(t),ze.mulByNonresidue(ze.mul(r,e))),n=ze.sub(ze.mulByNonresidue(ze.sqr(r)),ze.mul(t,e)),o=ze.sub(ze.sqr(e),ze.mul(t,r)),a=ze.inv(ze.add(ze.mulByNonresidue(ze.add(ze.mul(r,n),ze.mul(e,o))),ze.mul(t,s)));return{c0:ze.mul(a,s),c1:ze.mul(a,n),c2:ze.mul(a,o)}},fromBytes:t=>{if(t.length!==nr.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:ze.fromBytes(t.subarray(0,ze.BYTES)),c1:ze.fromBytes(t.subarray(ze.BYTES,2*ze.BYTES)),c2:ze.fromBytes(t.subarray(2*ze.BYTES))}},toBytes:({c0:t,c1:e,c2:r})=>st(ze.toBytes(t),ze.toBytes(e),ze.toBytes(r)),cmov:({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o},a)=>({c0:ze.cmov(t,s,a),c1:ze.cmov(e,n,a),c2:ze.cmov(r,o,a)}),fromBigSix:t=>{if(!Array.isArray(t)||6!==t.length)throw new Error("Invalid Fp6 usage");return{c0:ze.fromBigTuple(t.slice(0,2)),c1:ze.fromBigTuple(t.slice(2,4)),c2:ze.fromBigTuple(t.slice(4,6))}},frobeniusMap:({c0:t,c1:e,c2:r},s)=>({c0:ze.frobeniusMap(t,s),c1:ze.mul(ze.frobeniusMap(e,s),or[s%6]),c2:ze.mul(ze.frobeniusMap(r,s),ar[s%6])}),mulByNonresidue:({c0:t,c1:e,c2:r})=>({c0:ze.mulByNonresidue(r),c1:t,c2:e}),multiplyBy1:({c0:t,c1:e,c2:r},s)=>({c0:ze.mulByNonresidue(ze.mul(r,s)),c1:ze.mul(t,s),c2:ze.mul(e,s)}),multiplyBy01({c0:t,c1:e,c2:r},s,n){let o=ze.mul(t,s),a=ze.mul(e,n);return{c0:ze.add(ze.mulByNonresidue(ze.sub(ze.mul(ze.add(e,r),n),a)),o),c1:ze.sub(ze.sub(ze.mul(ze.add(s,n),ze.add(t,e)),o),a),c2:ze.add(ze.sub(ze.mul(ze.add(t,r),s),o),a)}},multiplyByFp2:({c0:t,c1:e,c2:r},s)=>({c0:ze.mul(t,s),c1:ze.mul(e,s),c2:ze.mul(r,s)})},or=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe")]].map((t=>ze.fromBigTuple(t))),ar=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")]].map((t=>ze.fromBigTuple(t))),ir=BigInt("0xd201000000010000"),ur=ot(ir),cr=({c0:t,c1:e},{c0:r,c1:s})=>({c0:nr.add(t,r),c1:nr.add(e,s)}),dr=({c0:t,c1:e},{c0:r,c1:s})=>({c0:nr.sub(t,r),c1:nr.sub(e,s)}),pr=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:nr.mul(t,r),c1:nr.mul(e,r)};let{c0:s,c1:n}=r,o=nr.mul(t,s),a=nr.mul(e,n);return{c0:nr.add(o,nr.mulByNonresidue(a)),c1:nr.sub(nr.mul(nr.add(t,e),nr.add(s,n)),nr.add(o,a))}},fr=({c0:t,c1:e})=>{let r=nr.mul(t,e);return{c0:nr.sub(nr.sub(nr.mul(nr.add(nr.mulByNonresidue(e),t),nr.add(t,e)),r),nr.mulByNonresidue(r)),c1:nr.add(r,r)}};function lr(t,e){const r=ze.sqr(t),s=ze.sqr(e);return{first:ze.add(ze.mulByNonresidue(s),r),second:ze.sub(ze.sub(ze.sqr(ze.add(t,e)),r),s)}}const hr={ORDER:ze.ORDER,BITS:2*ze.BITS,BYTES:2*ze.BYTES,MASK:it(2*ze.BITS),ZERO:{c0:nr.ZERO,c1:nr.ZERO},ONE:{c0:nr.ONE,c1:nr.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>nr.isValid(t)&&nr.isValid(e),is0:({c0:t,c1:e})=>nr.is0(t)&&nr.is0(e),neg:({c0:t,c1:e})=>({c0:nr.neg(t),c1:nr.neg(e)}),eql:({c0:t,c1:e},{c0:r,c1:s})=>nr.eql(t,r)&&nr.eql(e,s),sqrt:()=>{throw new Error("Not implemented")},inv:({c0:t,c1:e})=>{let r=nr.inv(nr.sub(nr.sqr(t),nr.mulByNonresidue(nr.sqr(e))));return{c0:nr.mul(t,r),c1:nr.neg(nr.mul(e,r))}},div:(t,e)=>hr.mul(t,"bigint"==typeof e?je.inv(je.create(e)):hr.inv(e)),pow:(t,e)=>Et(hr,t,e),invertBatch:t=>Pt(hr,t),add:cr,sub:dr,mul:pr,sqr:fr,addN:cr,subN:dr,mulN:pr,sqrN:fr,fromBytes:t=>{if(t.length!==hr.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:nr.fromBytes(t.subarray(0,nr.BYTES)),c1:nr.fromBytes(t.subarray(nr.BYTES))}},toBytes:({c0:t,c1:e})=>st(nr.toBytes(t),nr.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:s},n)=>({c0:nr.cmov(t,r,n),c1:nr.cmov(e,s,n)}),fromBigTwelve:t=>({c0:nr.fromBigSix(t.slice(0,6)),c1:nr.fromBigSix(t.slice(6,12))}),frobeniusMap(t,e){const r=nr.frobeniusMap(t.c0,e),{c0:s,c1:n,c2:o}=nr.frobeniusMap(t.c1,e),a=mr[e%12];return{c0:r,c1:nr.create({c0:ze.mul(s,a),c1:ze.mul(n,a),c2:ze.mul(o,a)})}},multiplyBy014:({c0:t,c1:e},r,s,n)=>{let o=nr.multiplyBy01(t,r,s),a=nr.multiplyBy1(e,n);return{c0:nr.add(nr.mulByNonresidue(a),o),c1:nr.sub(nr.sub(nr.multiplyBy01(nr.add(e,t),r,ze.add(s,n)),o),a)}},multiplyByFp2:({c0:t,c1:e},r)=>({c0:nr.multiplyByFp2(t,r),c1:nr.multiplyByFp2(e,r)}),conjugate:({c0:t,c1:e})=>({c0:t,c1:nr.neg(e)}),_cyclotomicSquare:({c0:t,c1:e})=>{const{c0:r,c1:s,c2:n}=t,{c0:o,c1:a,c2:i}=e,{first:u,second:c}=lr(r,a),{first:d,second:p}=lr(o,n),{first:f,second:l}=lr(s,i);let h=ze.mulByNonresidue(l);return{c0:nr.create({c0:ze.add(ze.mul(ze.sub(u,r),Ue),u),c1:ze.add(ze.mul(ze.sub(d,s),Ue),d),c2:ze.add(ze.mul(ze.sub(f,n),Ue),f)}),c1:nr.create({c0:ze.add(ze.mul(ze.add(h,o),Ue),h),c1:ze.add(ze.mul(ze.add(c,a),Ue),c),c2:ze.add(ze.mul(ze.add(p,i),Ue),p)})}},_cyclotomicExp(t,e){let r=hr.ONE;for(let s=ur-1;s>=0;s--)r=hr._cyclotomicSquare(r),at(e,s)&&(r=hr.mul(r,t));return r},finalExponentiate:t=>{const e=ir,r=hr.div(hr.frobeniusMap(t,6),t),s=hr.mul(hr.frobeniusMap(r,2),r),n=hr.conjugate(hr._cyclotomicExp(s,e)),o=hr.mul(hr.conjugate(hr._cyclotomicSquare(s)),n),a=hr.conjugate(hr._cyclotomicExp(o,e)),i=hr.conjugate(hr._cyclotomicExp(a,e)),u=hr.mul(hr.conjugate(hr._cyclotomicExp(i,e)),hr._cyclotomicSquare(n)),c=hr.conjugate(hr._cyclotomicExp(u,e)),d=hr.frobeniusMap(hr.mul(n,i),2),p=hr.frobeniusMap(hr.mul(a,s),3),f=hr.frobeniusMap(hr.mul(u,hr.conjugate(s)),1),l=hr.mul(hr.mul(c,hr.conjugate(o)),s);return hr.mul(hr.mul(hr.mul(d,p),f),l)}},mr=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8"),BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")],[BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2"),BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995"),BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3"),BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116"),BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995")]].map((t=>ze.fromBigTuple(t))),xr=ee(ze,[[["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"],["0x0","0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"],["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1","0x0"]],[["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"],["0xc","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"],["0x1","0x0"]],[["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706","0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"],["0x0","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"],["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10","0x0"]],[["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"],["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"],["0x12","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"],["0x1","0x0"]]].map((t=>t.map((t=>ze.fromBigTuple(t.map(BigInt))))))),gr=ee(je,[["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7","0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb","0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0","0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861","0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9","0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983","0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84","0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e","0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317","0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e","0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b","0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"],["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c","0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff","0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19","0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8","0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e","0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5","0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a","0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e","0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641","0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"],["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33","0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696","0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6","0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb","0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb","0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0","0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2","0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29","0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587","0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30","0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132","0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e","0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8","0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133","0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b","0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"],["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1","0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d","0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2","0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416","0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d","0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac","0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c","0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9","0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a","0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55","0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8","0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092","0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc","0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7","0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))),br=Zt(ze,{A:ze.create({c0:je.create(_e),c1:je.create(BigInt(240))}),B:ze.create({c0:je.create(BigInt(1012)),c1:je.create(BigInt(1012))}),Z:ze.create({c0:je.create(BigInt(-2)),c1:je.create(BigInt(-1))})}),yr=Zt(je,{A:je.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),B:je.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),Z:je.create(BigInt(11))}),wr=nr.create({c0:ze.ZERO,c1:ze.ONE,c2:ze.ZERO}),Ir=hr.create({c0:wr,c1:nr.ZERO}),Br=hr.create({c0:nr.ZERO,c1:wr}),[Tr,Or]=hr.invertBatch([Ir,Br]);function Sr(t,e){const r=e.toAffine(),s=(n=r.x,o=r.y,[hr.mul(hr.frobeniusMap(hr.multiplyByFp2(Tr,n),1),Ir).c0.c0,hr.mul(hr.frobeniusMap(hr.multiplyByFp2(Or,o),1),Br).c0.c0]);var n,o;return new t(s[0],s[1],ze.ONE)}const vr=BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac");function Ar(t,e){const r=e.toAffine(),s=(n=r.x,o=r.y,[ze.mul(n,vr),ze.neg(o)]);var n,o;return new t(s[0],s[1],ze.ONE)}const Er=Object.freeze({DST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",encodeDST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",p:je.ORDER,m:2,k:128,expand:"xmd",hash:r.sha256}),Pr=Rr(je.toBytes(_e),{infinity:!0,compressed:!0});function kr(t){const e=224&(t=t.slice())[0],r=!!(e>>7&1),s=!!(e>>6&1),n=!!(e>>5&1);return t[0]&=31,{compressed:r,infinity:s,sort:n,value:t}}function Rr(t,e){if(224&t[0])throw new Error("setMask: non-empty mask");return e.compressed&&(t[0]|=128),e.infinity&&(t[0]|=64),e.sort&&(t[0]|=32),t}function Dr(t){t.assertValidity();const e=t.equals(Nr.G1.ProjectivePoint.ZERO),{x:r,y:s}=t.toAffine();if(e)return Pr.slice();const n=je.ORDER,o=Boolean(s*Ue/n);return Rr(tt(r,je.BYTES),{compressed:!0,sort:o})}function Cr(t){t.assertValidity();const e=je.BYTES;if(t.equals(Nr.G2.ProjectivePoint.ZERO))return st(Pr,tt(_e,e));const{x:r,y:s}=t.toAffine(),{re:n,im:o}=ze.reim(r),{re:a,im:i}=ze.reim(s),u=Boolean((i>_e?i*Ue:a*Ue)/je.ORDER&Ve),c=n;return st(Rr(tt(o,e),{sort:u,compressed:!0}),tt(c,e))}const Nr=function(t){const{Fp:e,Fr:r,Fp2:s,Fp6:n,Fp12:o}=t.fields,a=ot(t.params.x);function i(e){const{x:r,y:n}=e,o=r,i=n;let u=o,c=i,d=s.ONE,p=[];for(let e=a-2;e>=0;e--){let r=s.sqr(c),n=s.sqr(d),a=s.multiplyByB(s.mul(n,Ne)),f=s.mul(a,Ne),l=s.sub(s.sub(s.sqr(s.add(c,d)),n),r);if(p.push([s.sub(a,r),s.mul(s.sqr(u),Ne),s.neg(l)]),u=s.div(s.mul(s.mul(s.sub(r,f),u),c),Ce),c=s.sub(s.sqr(s.div(s.add(r,f),Ce)),s.mul(s.sqr(a),Ne)),d=s.mul(r,l),at(t.params.x,e)){let t=s.sub(c,s.mul(i,d)),e=s.sub(u,s.mul(o,d));p.push([s.sub(s.mul(t,o),s.mul(e,i)),s.neg(t),e]);let r=s.sqr(e),n=s.mul(r,e),a=s.mul(r,u),f=s.add(s.sub(n,s.mul(a,Ce)),s.mul(s.sqr(t),d));u=s.mul(e,f),c=s.sub(s.mul(s.sub(a,f),t),s.mul(n,c)),d=s.mul(d,n)}}return p}function u(e,r){const{x:n}=t.params,i=r[0],u=r[1];let c=o.ONE;for(let t=0,r=a-2;r>=0;r--,t++){const a=e[t];if(c=o.multiplyBy014(c,a[0],s.mul(a[1],i),s.mul(a[2],u)),at(n,r)){t+=1;const r=e[t];c=o.multiplyBy014(c,r[0],s.mul(r[1],i),s.mul(r[2],u))}0!==r&&(c=o.sqr(c))}return o.conjugate(c)}const c={randomPrivateKey:()=>{const e=Ct(r.ORDER);return Nt(t.randomBytes(e),r.ORDER)},calcPairingPrecomputes:i},d=Wt({n:r.ORDER,...t.G1}),p=Object.assign(d,re(d.ProjectivePoint,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),f=Wt({n:r.ORDER,...t.G2}),l=Object.assign(f,re(f.ProjectivePoint,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults})),{ShortSignature:h}=t.G1,{Signature:m}=t.G2;function x(t,e,r=!0){if(t.equals(p.ProjectivePoint.ZERO)||e.equals(l.ProjectivePoint.ZERO))throw new Error("pairing is not available for ZERO point");t.assertValidity(),e.assertValidity();const s=t.toAffine(),n=u(function(t){const e=t;return e._PPRECOMPUTES||(e._PPRECOMPUTES=i(t.toAffine())),e._PPRECOMPUTES}(e),[s.x,s.y]);return r?o.finalExponentiate(n):n}function g(t){return t instanceof p.ProjectivePoint?t:p.ProjectivePoint.fromHex(t)}function b(t,e){return t instanceof p.ProjectivePoint?t:p.hashToCurve(rt("point",t),e)}function y(t){return t instanceof l.ProjectivePoint?t:m.fromHex(t)}function w(t,e){return t instanceof l.ProjectivePoint?t:l.hashToCurve(rt("point",t),e)}return p.ProjectivePoint.BASE._setWindowSize(4),{getPublicKey:function(t){return p.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},getPublicKeyForShortSignatures:function(t){return l.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},sign:function(t,e,r){const s=w(t,r);s.assertValidity();const n=s.multiply(p.normPrivateKeyToScalar(e));return t instanceof l.ProjectivePoint?n:m.toRawBytes(n)},signShortSignature:function(t,e,r){const s=b(t,r);s.assertValidity();const n=s.multiply(p.normPrivateKeyToScalar(e));return t instanceof p.ProjectivePoint?n:h.toRawBytes(n)},verify:function(t,e,r,s){const n=g(r),a=w(e,s),i=p.ProjectivePoint.BASE,u=y(t),c=x(n.negate(),a,!1),d=x(i,u,!1),f=o.finalExponentiate(o.mul(d,c));return o.eql(f,o.ONE)},verifyBatch:function(t,e,r,s){if(!e.length)throw new Error("Expected non-empty messages array");if(r.length!==e.length)throw new Error("Pubkey count should equal msg count");const n=y(t),a=e.map((t=>w(t,s))),i=r.map(g);try{const t=[];for(const e of new Set(a)){const r=a.reduce(((t,r,s)=>r===e?t.add(i[s]):t),p.ProjectivePoint.ZERO);t.push(x(r,e,!1))}t.push(x(p.ProjectivePoint.BASE.negate(),n,!1));const e=t.reduce(((t,e)=>o.mul(t,e)),o.ONE),r=o.finalExponentiate(e);return o.eql(r,o.ONE)}catch{return!1}},verifyShortSignature:function(t,e,r,s){const n=y(r),a=b(e,s),i=l.ProjectivePoint.BASE,u=g(t),c=x(a,n,!1),d=x(u,i.negate(),!1),p=o.finalExponentiate(o.mul(d,c));return o.eql(p,o.ONE)},aggregatePublicKeys:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(g).reduce(((t,e)=>t.add(e)),p.ProjectivePoint.ZERO);return t[0]instanceof p.ProjectivePoint?(e.assertValidity(),e):e.toRawBytes(!0)},aggregateSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(y).reduce(((t,e)=>t.add(e)),l.ProjectivePoint.ZERO);return t[0]instanceof l.ProjectivePoint?(e.assertValidity(),e):m.toRawBytes(e)},aggregateShortSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(g).reduce(((t,e)=>t.add(e)),p.ProjectivePoint.ZERO);return t[0]instanceof p.ProjectivePoint?(e.assertValidity(),e):h.toRawBytes(e)},millerLoop:u,pairing:x,G1:p,G2:l,Signature:m,ShortSignature:h,fields:{Fr:r,Fp:e,Fp2:s,Fp6:n,Fp12:o},params:{x:t.params.x,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:c}}({fields:{Fp:je,Fp2:ze,Fp6:nr,Fp12:hr,Fr:He},G1:{Fp:je,h:BigInt("0x396c8c005555e1568c00aaab0000aaab"),Gx:BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),Gy:BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),a:je.ZERO,b:Me,htfDefaults:{...Er,m:1,DST:"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>{const r=BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),s=new t(je.mul(e.px,r),e.py,e.pz);return e.multiplyUnsafe(Nr.params.x).negate().multiplyUnsafe(Nr.params.x).equals(s)},clearCofactor:(t,e)=>e.multiplyUnsafe(Nr.params.x).add(e),mapToCurve:t=>{const{x:e,y:r}=yr(je.create(t[0]));return gr(e,r)},fromBytes:t=>{const{compressed:e,infinity:r,sort:s,value:n}=kr(t);if(48===n.length&&e){const t=je.ORDER,e=J(n),o=je.create(e&je.MASK);if(r){if(o!==_e)throw new Error("G1: non-empty compressed point at infinity");return{x:_e,y:_e}}const a=je.add(je.pow(o,Le),je.create(Nr.params.G1b));let i=je.sqrt(a);if(!i)throw new Error("Invalid compressed G1 point");return i*Ue/t!==BigInt(s)&&(i=je.neg(i)),{x:je.create(o),y:je.create(i)}}if(96!==n.length||e)throw new Error("Invalid point G1, expected 48/96 bytes");{const t=J(n.subarray(0,je.BYTES)),e=J(n.subarray(je.BYTES));if(r){if(t!==_e||e!==_e)throw new Error("G1: non-empty point at infinity");return Nr.G1.ProjectivePoint.ZERO.toAffine()}return{x:je.create(t),y:je.create(e)}}},toBytes:(t,e,r)=>{const s=e.equals(t.ZERO),{x:n,y:o}=e.toAffine();if(r){if(s)return Pr.slice();const t=je.ORDER,e=Boolean(o*Ue/t);return Rr(tt(n,je.BYTES),{compressed:!0,sort:e})}if(s){return st(new Uint8Array([64]),new Uint8Array(2*je.BYTES-1))}return st(tt(n,je.BYTES),tt(o,je.BYTES))},ShortSignature:{fromHex(t){const{infinity:e,sort:r,value:s}=kr(rt("signatureHex",t,48)),n=je.ORDER,o=J(s);if(e)return Nr.G1.ProjectivePoint.ZERO;const a=je.create(o&je.MASK),i=je.add(je.pow(a,Le),je.create(Nr.params.G1b));let u=je.sqrt(i);if(!u)throw new Error("Invalid compressed G1 point");const c=BigInt(r);u*Ue/n!==c&&(u=je.neg(u));const d=Nr.G1.ProjectivePoint.fromAffine({x:a,y:u});return d.assertValidity(),d},toRawBytes:t=>Dr(t),toHex:t=>F(Dr(t))}},G2:{Fp:ze,h:BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),Gx:ze.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]),Gy:ze.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")]),a:ze.ZERO,b:ze.fromBigTuple([Me,Me]),hEff:BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),htfDefaults:{...Er},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:t=>{const{x:e,y:r}=br(ze.fromBigTuple(t));return xr(e,r)},isTorsionFree:(t,e)=>e.multiplyUnsafe(Nr.params.x).negate().equals(Sr(t,e)),clearCofactor:(t,e)=>{const r=Nr.params.x;let s=e.multiplyUnsafe(r).negate(),n=Sr(t,e),o=e.double();o=Ar(t,o),o=o.subtract(n),n=s.add(n),n=n.multiplyUnsafe(r).negate(),o=o.add(n),o=o.subtract(s);return o.subtract(e)},fromBytes:t=>{const{compressed:e,infinity:r,sort:s,value:n}=kr(t);if(!e&&!r&&s||!e&&r&&s||s&&r&&e)throw new Error("Invalid encoding flag: "+(224&t[0]));const o=je.BYTES,a=(t,e,r)=>J(t.slice(e,r));if(96===n.length&&e){const t=Nr.params.G2b,e=je.ORDER;if(r){if(n.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid compressed G2 point");return{x:ze.ZERO,y:ze.ZERO}}const i=a(n,0,o),u=a(n,o,2*o),c=ze.create({c0:je.create(u),c1:je.create(i)}),d=ze.add(ze.pow(c,Le),t);let p=ze.sqrt(d);const f=p.c1===_e?p.c0*Ue/e:p.c1*Ue/e?Ve:_e;return p=s&&f>0?p:ze.neg(p),{x:c,y:p}}if(192!==n.length||e)throw new Error("Invalid point G2, expected 96/192 bytes");{if(r){if(n.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid uncompressed G2 point");return{x:ze.ZERO,y:ze.ZERO}}const t=a(n,0,o),e=a(n,o,2*o),s=a(n,2*o,3*o),i=a(n,3*o,4*o);return{x:ze.fromBigTuple([e,t]),y:ze.fromBigTuple([i,s])}}},toBytes:(t,e,r)=>{const{BYTES:s,ORDER:n}=je,o=e.equals(t.ZERO),{x:a,y:i}=e.toAffine();if(r){if(o)return st(Pr,tt(_e,s));const t=Boolean(i.c1===_e?i.c0*Ue/n:i.c1*Ue/n);return st(Rr(tt(a.c1,s),{compressed:!0,sort:t}),tt(a.c0,s))}{if(o)return st(new Uint8Array([64]),new Uint8Array(4*s-1));const{re:t,im:e}=ze.reim(a),{re:r,im:n}=ze.reim(i);return st(tt(e,s),tt(t,s),tt(n,s),tt(r,s))}},Signature:{fromHex(t){const{infinity:e,sort:r,value:s}=kr(rt("signatureHex",t)),n=je.ORDER,o=t.length/2;if(48!==o&&96!==o)throw new Error("Invalid compressed signature length, must be 96 or 192");const a=J(s.slice(0,o)),i=J(s.slice(o));if(e)return Nr.G2.ProjectivePoint.ZERO;const u=je.create(a&je.MASK),c=je.create(i),d=ze.create({c0:c,c1:u}),p=ze.add(ze.pow(d,Le),Nr.params.G2b);let f=ze.sqrt(p);if(!f)throw new Error("Failed to find a square root");const{re:l,im:h}=ze.reim(f),m=BigInt(r);(h>_e&&h*Ue/n!==m||h===_e&&l*Ue/n!==m)&&(f=ze.neg(f));const x=Nr.G2.ProjectivePoint.fromAffine({x:d,y:f});return x.assertValidity(),x},toRawBytes:t=>Cr(t),toHex:t=>F(Cr(t))}},params:{x:ir,r:He.ORDER},htfDefaults:Er,hash:r.sha256,randomBytes:e.randomBytes}),_r=48,Vr=96,Ur="BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",Lr="BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";function Mr(t){return Nr.G1.ProjectivePoint.fromHex(t)}function qr(t){return t.toRawBytes()}function Fr(t){return Nr.Signature.fromHex(t)}function Xr(t){return t.toRawBytes()}function jr(t,e,r){return Nr.verify(e,r,t,{DST:Lr})}var Hr,Kr,Wr=Object.freeze({__proto__:null,PUBLIC_KEY_LENGTH:_r,SIGNATURE_LENGTH:Vr,publicKeyFromBytes:Mr,publicKeyToBytes:qr,secretKeyFromBytes:function(t){return Nr.G1.normPrivateKeyToScalar(t)},secretKeyToBytes:function(t){return Te(t.toString(16))},sign:function(t,e){return Nr.sign(t,e,{DST:Ur})},signProofOfPossession:function(t,e){return Nr.sign(t,e,{DST:Lr})},signatureFromBytes:Fr,signatureToBytes:Xr,verify:function(t,e,r){return Nr.verify(e,r,t,{DST:Ur})},verifyProofOfPossession:jr});exports.BlsSignature=Hr=class extends ve{signature;_type=exports.TypeSymbols.BlsSignature;constructor(t){super(),this.signature=t}static fromSignatureBytes(t){return new Hr(Fr(t))}static fromBytes(t){const e=Fr(t.slice(0,Vr)),r=t.slice(Vr);return[new Hr(e),r]}static fromHex(t){return new Hr(Fr(Te(t)))}toBytes(){return Xr(this.signature)}toString(){return this.signature.toHex()}toJSON(){return this.toString()}},exports.BlsSignature=Hr=o([t=>{},a("design:paramtypes",[Object])],exports.BlsSignature),exports.BlsPublicKey=Kr=class extends ve{publicKey;_type=exports.TypeSymbols.BlsPublicKey;constructor(t){super(),this.publicKey=t}static fromPublicKeyBytes(t){return new Kr(Mr(t))}static fromBytes(t){const e=Mr(t.slice(0,_r)),r=t.slice(_r);return[new Kr(e),r]}static fromHex(t){return new Kr(Mr(Te(t)))}toBytes(){return qr(this.publicKey)}toString(){return this.publicKey.toHex()}toJSON(){return this.toString()}},exports.BlsPublicKey=Kr=o([t=>{},a("design:paramtypes",[Object])],exports.BlsPublicKey);const Gr={encode:s=>t.base58.encode(e.concatBytes(s,r.sha256(s).subarray(-4))),decode:e=>t.base58.decode(e).subarray(0,-4)},Zr=(t,e)=>{let r;for(r=0;r<t.length&&r<e.length;r++){const s=t[r],n=e[r];if(s!==n)return s-n}return r===t.length&&r===e.length?0:r===t.length?-1:1};var $r;const zr=32;var Yr;exports.Id=$r=class extends ve{idVal;_type=exports.TypeSymbols.Id;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new $r(t.slice(0,zr)),t.slice(zr)]}static compare(t,e){return Zr(t.toBytes(),e.toBytes())}[i](t,e){return e.stylize(this.toString(),"string")}toBytes(){return Oe(this.idVal,zr)}toJSON(){return this.toString()}toString(){return Gr.encode(this.toBytes())}static fromString(t){return $r.fromBytes(Gr.decode(t))[0]}static fromHex(t){return new $r(Te(t))}value(){return this.toString()}},exports.Id=$r=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Id);const Jr="NodeID-",Qr=20;exports.NodeId=Yr=class extends ve{idVal;_type=exports.TypeSymbols.NodeId;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new Yr(t.slice(0,Qr)),t.slice(Qr)]}[i](t,e){return e.stylize(this.toString(),"string")}toBytes(){return Oe(this.idVal,Qr)}toJSON(){return this.toString()}toString(){return Jr+Gr.encode(this.toBytes())}static fromString(t){if(!t.includes(Jr))throw new Error("ID is missing prefix");return this.fromBytes(Gr.decode(t.replace(Jr,"")))[0]}static fromHex(t){return new Yr(Te(t))}value(){return this.toString()}},exports.NodeId=Yr=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.NodeId);const ts=new exports.Id(new Uint8Array(32)),es=new exports.Id(new Uint8Array(32)),rs=1,ss=2,ns=3,os=4,as=5,is=10,us=12345,cs="avax",ds="cascade",ps="denali",fs="everest",ls="fuji",hs="testing",ms="local",xs="custom",gs={[rs]:cs,[ss]:ds,[ns]:ps,[os]:fs,[as]:ls,[is]:hs,[us]:ms},bs=t=>gs[t]??xs;var ys,ws=Object.freeze({__proto__:null,CascadeHRP:ds,CascadeID:2,CascadeName:"cascade",DenaliHRP:ps,DenaliID:3,DenaliName:"denali",EverestHRP:fs,EverestID:4,EverestName:"everest",FallbackHRP:xs,FujiHRP:ls,FujiID:5,FujiName:"fuji",LocalHRP:ms,LocalID:12345,LocalName:"local",MainnetHRP:cs,MainnetID:1,MainnetName:"mainnet",NetworkIDToHRP:gs,PlatformChainID:es,PrimaryNetworkID:ts,TestnetID:5,TestnetName:"testnet",UnitTestHRP:hs,UnitTestID:10,UnitTestName:"testing",getHRP:bs});class Is{getVM(){return this.vm}}class Bs extends Is{getInputs(){return this.baseTx?.inputs??[]}getBlockchainId(){return this.baseTx?.BlockchainId.toString()??""}getSigIndices(){return this.getInputs().map((t=>t.sigIndicies())).filter((t=>void 0!==t))}}exports.Int=ys=class extends ve{int;_type=exports.TypeSymbols.Int;constructor(t){super(),this.int=t}static fromBytes(t){return[new ys(we(t.slice(0,4))),t.slice(4)]}[i](){return this.value()}toJSON(){return this.int}toBytes(){return Oe(Te(this.int.toString(16)),4)}value(){return this.int}},exports.Int=ys=o([t=>{},a("design:paramtypes",[Number])],exports.Int);const Ts=t=>new exports.Int(t).toBytes(),Os=(t,e,r)=>Ss(t,e.fromBytes,r),Ss=(t,e,r)=>{let s;[s,t]=exports.Int.fromBytes(t);const n=[];for(let o=0;o<s.value();o++){if(0===t.length)throw new Error("not enough bytes");let s;[s,t]=e(t,r),n.push(s)}return[n,t]},vs=t=>({fromBytes:(e,r)=>Os(e,t,r)}),As={fromBytes:(t,e)=>{if(!e)throw new Error("codec required when using unpackCodecList");return Ss(t,e.UnpackPrefix,e)}},Es=(t,r)=>e.concatBytes(Ts(t.length),...t.map((t=>t.toBytes(r))));function Ps(t,e,r){return[...e.map((e=>{let s;if(!t.length)throw new Error("not enough bytes");return[s,t]=e.fromBytes(t,r),s})),t]}function ks(t,r){return e.concatBytes(...t.map((t=>Array.isArray(t)?Es(t,r):t.toBytes(r))))}function Rs(t,...e){return ks(e,t)}var Ds,Cs;exports.BigIntPr=Ds=class extends ve{bigint;_type=exports.TypeSymbols.BigIntPr;constructor(t){super(),this.bigint=t}[i](){return this.bigint}static fromBytes(t){return[new Ds(ye(t.slice(0,8))),t.slice(8)]}toJSON(){return this.bigint.toString()}toBytes(){return Oe(Te(this.bigint.toString(16)),8)}value(){return this.bigint}},exports.BigIntPr=Ds=o([t=>{},a("design:paramtypes",[BigInt])],exports.BigIntPr);var Ns,_s,Vs;exports.Bool=Cs=class extends ve{bool;_type=exports.TypeSymbols.Bool;constructor(t){super(),this.bool=t}static fromBytes(t){return[new Cs(Ie(t.slice(0,1))),t.slice(1)]}toJSON(){return this.bool.toString()}toBytes(){return Oe(Te(this.bool?"1":"0"),1)}value(){return this.bool}},exports.Bool=Cs=o([t=>{},a("design:paramtypes",[Boolean])],exports.Bool),exports.Byte=Ns=class extends ve{byte;_type=exports.TypeSymbols.Byte;constructor(t){super(),this.byte=t}static fromBytes(t){return[new Ns(t.slice(0,1)),t.slice(1)]}toJSON(){return Be(this.byte)}toBytes(){return this.byte}},exports.Byte=Ns=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Byte),exports.Bytes=_s=class extends ve{bytes;_type=exports.TypeSymbols.Bytes;constructor(t){super(),this.bytes=t}toString(e="utf8"){return t.bytesToString(e,this.bytes)}toJSON(){return Be(this.bytes)}static fromBytes(t){const[e,r]=exports.Int.fromBytes(t);return[new _s(r.slice(0,e.value())),r.slice(e.value())]}toBytes(){return e.concatBytes(Ts(this.bytes.length),this.bytes)}get length(){return this.bytes.length}},exports.Bytes=_s=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Bytes);var Us,Ls;function Ms(t){return t._type===exports.TypeSymbols.TransferOutput}function qs(t){return t._type===exports.TypeSymbols.StakeableLockOut}function Fs(t){return t._type===exports.TypeSymbols.OutputOwners}function Xs(t){return t._type===exports.TypeSymbols.StakeableLockIn}function js(t){return t._type===exports.TypeSymbols.TransferInput}exports.Short=Vs=class extends ve{short;_type=exports.TypeSymbols.Short;constructor(t){super(),this.short=t}static fromBytes(t){return[new Vs(we(t.slice(0,2))),t.slice(2)]}toJSON(){return this.short.toString()}toBytes(){return Oe(Te(this.short.toString(16)),2)}value(){return this.short}},exports.Short=Vs=o([t=>{},a("design:paramtypes",[Number])],exports.Short),exports.Stringpr=Us=class extends ve{string;_type=exports.TypeSymbols.StringPr;constructor(t){super(),this.string=t}static fromBytes(t){const[e,r]=exports.Short.fromBytes(t);return[new Us((new TextDecoder).decode(r.slice(0,e.value()))),r.slice(e.value())]}toJSON(){return this.string}toBytes(){return e.concatBytes(Oe(Te(this.string.length.toString(16)),2),(new TextEncoder).encode(this.string))}value(){return this.string}},exports.Stringpr=Us=o([t=>{},a("design:paramtypes",[String])],exports.Stringpr);var Hs,Ks,Ws,Gs,Zs,$s,zs,Ys;function Js(t){return t.toSorted(Zr).map((t=>new exports.Address(t)))}exports.Signature=Ls=class{sig;_type=exports.TypeSymbols.Signature;constructor(t){if(this.sig=t,65!==t.length)throw new Error("incorrect number of bytes for signature")}toJSON(){return e.bytesToHex(this.sig)}static fromJSON(t){return new Ls(ge(t))}static fromBytes(t){return[new Ls(t.slice(0,65)),t.slice(65)]}[i](t,e){return e.stylize(this.toString(),"string")}toString(){return Be(this.sig)}toBytes(){return Oe(this.sig,65)}},exports.Signature=Ls=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Signature),exports.Credential=Hs=class{signatures;_type=exports.TypeSymbols.Credential;constructor(t){this.signatures=t}static fromBytes(t,e){const[r,s]=Os(t,exports.Signature,e);return[new Hs(r),s]}toJSON(){return this.signatures}static fromJSON(t){return new Hs(t.map((t=>exports.Signature.fromJSON(t))))}setSignature(t,e){if(t>=this.signatures.length)throw new Error(`index ${t} is out of bounds for credential`);this.signatures[t]=new exports.Signature(e)}getSignatures(){return this.signatures.map((t=>t.toString()))}toBytes(t){return Es(this.signatures,t)}},exports.Credential=Hs=o([t=>{},a("design:paramtypes",[Array])],exports.Credential),exports.Input=Ks=class{sigIndices;_type=exports.TypeSymbols.Input;constructor(t){this.sigIndices=t}static fromNative(t){return new Ks(t.map((t=>new exports.Int(t))))}static fromBytes(t){const[e,r]=Ps(t,[vs(exports.Int)]);return[new Ks(e),r]}values(){return this.sigIndices.map((t=>t.value()))}toBytes(t){return Es(this.sigIndices,t)}},exports.Input=Ks=o([t=>{},a("design:paramtypes",[Array])],exports.Input),exports.OutputOwners=Ws=class{locktime;threshold;addrs;_type=exports.TypeSymbols.OutputOwners;constructor(t,e,r){this.locktime=t,this.threshold=e,this.addrs=r}static fromNative(t,e=0n,r=1){return new Ws(new exports.BigIntPr(e),new exports.Int(r),Js(t))}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[exports.BigIntPr,exports.Int,vs(exports.Address)],e);return[new Ws(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.locktime,this.threshold],t),Es(this.addrs,t))}equals(t){return this.locktime.value()===t.locktime.value()&&this.threshold.value()===t.threshold.value()&&this.addrs.length===t.addrs.length&&this.addrs.every(((e,r)=>e.value()===t.addrs[r].value()))}},exports.OutputOwners=Ws=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.Int,Array])],exports.OutputOwners),exports.MintOutput=Gs=class{outputOwners;_type=exports.TypeSymbols.SecpMintOutput;constructor(t){this.outputOwners=t}static fromBytes(t,e){let r;return[r,t]=exports.OutputOwners.fromBytes(t,e),[new Gs(r),t]}toBytes(t){return this.outputOwners.toBytes(t)}},exports.MintOutput=Gs=o([t=>{},a("design:paramtypes",[exports.OutputOwners])],exports.MintOutput),exports.TransferOutput=Zs=class{amt;outputOwners;_type=exports.TypeSymbols.TransferOutput;constructor(t,e){this.amt=t,this.outputOwners=e}amount(){return this.amt.value()}getLocktime(){return this.outputOwners.locktime.value()}getOwners(){return this.outputOwners.addrs.map((t=>t.toBytes()))}getThreshold(){return this.outputOwners.threshold.value()}static fromBytes(t){const[e,r,s]=Ps(t,[exports.BigIntPr,exports.OutputOwners]);return[new Zs(e,r),s]}toBytes(t){return ks([this.amt,this.outputOwners],t)}},exports.TransferOutput=Zs=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.OutputOwners])],exports.TransferOutput),exports.MintOperation=$s=class{input;mintOutput;transferOutput;_type=exports.TypeSymbols.SecpMintOperation;constructor(t,e,r){this.input=t,this.mintOutput=e,this.transferOutput=r}static fromBytes(t){const[e,r,s,n]=Ps(t,[exports.Input,exports.MintOutput,exports.TransferOutput]);return[new $s(e,r,s),n]}toBytes(t){return e.concatBytes(this.input.toBytes(t),this.mintOutput.toBytes(t),this.transferOutput.toBytes(t))}},exports.MintOperation=$s=o([t=>{},a("design:paramtypes",[exports.Input,exports.MintOutput,exports.TransferOutput])],exports.MintOperation),exports.OutputOwnersList=zs=class{outputOwners;_type=exports.TypeSymbols.OutputOwnersList;constructor(t){this.outputOwners=t}static fromBytes(t,e){const[r,s]=Os(t,exports.OutputOwners,e);return[new zs(r),s]}toBytes(t){return Es(this.outputOwners,t)}},exports.OutputOwnersList=zs=o([t=>{},a("design:paramtypes",[Array])],exports.OutputOwnersList),exports.TransferInput=Ys=class{amt;input;_type=exports.TypeSymbols.TransferInput;constructor(t,e){this.amt=t,this.input=e}static fromBytes(t){const[e,r,s]=Ps(t,[exports.BigIntPr,exports.Input]);return[new Ys(e,r),s]}static fromNative(t,e){return new Ys(new exports.BigIntPr(t),exports.Input.fromNative(e))}sigIndicies(){return this.input.values()}amount(){return this.amt.value()}toBytes(t){return ks([this.amt,this.input],t)}},exports.TransferInput=Ys=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.Input])],exports.TransferInput);const Qs=Object.freeze([exports.TransferInput,exports.MintOutput,exports.TransferOutput,exports.MintOperation,exports.Credential]);var tn;let en=tn=class{txID;outputIdx;_type=exports.TypeSymbols.UTXOID;constructor(t,e){this.txID=t,this.outputIdx=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.Id,exports.Int],e);return[new tn(r,s),n]}static fromNative(t,e){return new tn(exports.Id.fromString(t),new exports.Int(e))}static compare(t,e){const r=exports.Id.compare(t.txID,e.txID);return 0!==r?r:t.outputIdx.value()-e.outputIdx.value()}toBytes(t){return ks([this.txID,this.outputIdx],t)}ID(){return Gr.encode(r.sha256(e.concatBytes(new exports.BigIntPr(BigInt(this.outputIdx.value())).toBytes(),this.txID.toBytes())))}};var rn,sn,nn;en=tn=o([t=>{},a("design:paramtypes",[exports.Id,exports.Int])],en),exports.TransferableInput=rn=class{utxoID;assetId;input;_type=exports.TypeSymbols.TransferableInput;constructor(t,e,r){this.utxoID=t,this.assetId=e,this.input=r}static fromBytes(t,e){const[r,s,n]=Ps(t,[en,exports.Id]),[o,a]=e.UnpackPrefix(n);return[new rn(r,s,o),a]}static fromNative(t,e,r,s,n){return new rn(en.fromNative(t,e),exports.Id.fromString(r),new exports.TransferInput(new exports.BigIntPr(s),new exports.Input(n.map((t=>new exports.Int(t))))))}static fromUtxoAndSigindicies(t,e){const r=t.output;if(!Ms(r))throw new Error("utxo.output must be Transferout");return new rn(t.utxoId,t.assetId,exports.TransferInput.fromNative(r.amount(),e))}sigIndicies(){const t=this.input;if(js(t))return t.sigIndicies();if(Xs(t)){const e=t.transferableInput;if(js(e))return e.sigIndicies()}throw new Error("Input must be TransferInput or StakeableLockIn")}static compare(t,e){return en.compare(t.utxoID,e.utxoID)}amount(){return this.input.amount()}getAssetId(){return this.assetId.toString()}toBytes(t){return e.concatBytes(ks([this.utxoID,this.assetId],t),t.PackPrefix(this.input))}},exports.TransferableInput=rn=o([t=>{},a("design:paramtypes",[en,exports.Id,Object])],exports.TransferableInput),exports.TransferableOutput=sn=class{assetId;output;_type=exports.TypeSymbols.TransferableOutput;constructor(t,e){this.assetId=t,this.output=e}static fromNative(t,e,r,s,n){return new sn(exports.Id.fromString(t),new exports.TransferOutput(new exports.BigIntPr(e),exports.OutputOwners.fromNative(r,s,n)))}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Id],e),[n,o]=e.UnpackPrefix(s);return[new sn(r,n),o]}getAssetId(){return this.assetId.toString()}amount(){return this.output.amount()}toBytes(t){return e.concatBytes(ks([this.assetId],t),t.PackPrefix(this.output))}},exports.TransferableOutput=sn=o([t=>{},a("design:paramtypes",[exports.Id,Object])],exports.TransferableOutput);let on=nn=class{NetworkId;BlockchainId;outputs;inputs;memo;_type=exports.TypeSymbols.BaseTx;constructor(t,e,r,s,n){this.NetworkId=t,this.BlockchainId=e,this.outputs=r,this.inputs=s,this.memo=n}static fromBytes(t,e){const[r,s,n,o,a,i]=Ps(t,[exports.Int,exports.Id,vs(exports.TransferableOutput),vs(exports.TransferableInput),exports.Bytes],e);return[new nn(r,s,n,o,a),i]}static fromNative(t,e,r,s,n){return new nn(new exports.Int(t),exports.Id.fromString(e),r,s,new exports.Bytes(n))}toBytes(t){return e.concatBytes(ks([this.NetworkId,this.BlockchainId],t),Es(this.outputs,t),Es(this.inputs,t),this.memo.toBytes())}};on=nn=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,Array,Array,exports.Bytes])],on);class an extends Bs{vm=Ae}var un;let cn=un=class extends an{baseTx;_type=exports.TypeSymbols.AvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,s]=Ps(t,[on],e);return[new un(r),s]}toBytes(t){return this.baseTx.toBytes(t)}};cn=un=o([t=>{},a("design:paramtypes",[on])],cn);let dn=class{typeIdToType;_type=exports.TypeSymbols.Codec;typeToTypeID;constructor(t){this.typeIdToType=t,this.typeToTypeID=t.reduce(((t,e,r)=>e?t.set((new e)._type,r):t),new Map)}PackPrefix=t=>{const r=this.typeToTypeID.get(t._type);if(void 0===r)throw new Error(`can't marshal unregistered type: ${t._type.toString()}`);return e.concatBytes(Ts(r),t.toBytes(this))};UnpackPrefix=t=>{let e;[e,t]=Ps(t,[exports.Int]);const r=this.typeIdToType[e.value()];if(void 0===r)throw new Error(`couldn't unmarshal interface: unknown type ID ${e.value()}`);const[s,n]=r.fromBytes(t,this);return[s,n]};static fromBytes(t,e){if(!e)throw new Error("codec required");return e.UnpackPrefix(t)}toBytes(){throw new Error("not implemented")}PackPrefixList(t){return e.concatBytes(Ts(t.length),...t.map((t=>this.PackPrefix(t))))}};dn=o([t=>{},a("design:paramtypes",[Array])],dn);class pn{codecs={};RegisterCodec(t,e){if(t in this.codecs)throw new Error("duplicated codec version");this.codecs[t]=e}unpack=(t,e)=>{const[r,s]=this.getCodecFromBuffer(t);return e.fromBytes(s,r)[0]};unpackTransaction=t=>{const[e,r]=this.getCodecFromBuffer(t);return e.UnpackPrefix(r)[0]};getCodecFromBuffer(t){const[e,r]=Ps(t,[exports.Short]);return[this.getCodecForVersion(e),r]}getCodecForVersion(t){if(!this.codecs[t.value()])throw new Error(`codec id(${t.value()}) not found`);return this.codecs[t.value()]}getDefaultCodec(){return this.getCodecForVersion(new exports.Short(0))}getDefaultCodecId(){return new exports.Short(0)}packCodec(t,r=0){const s=new exports.Short(r),n=this.getCodecForVersion(s);return e.concatBytes(s.toBytes(),n.PackPrefix(t))}}class fn extends exports.Credential{_type=exports.TypeSymbols.NftFxCredential}var ln;let hn=ln=class{input;groupId;payload;outputOwnerList;_type=exports.TypeSymbols.NftFxMintOperation;constructor(t,e,r,s){this.input=t,this.groupId=e,this.payload=r,this.outputOwnerList=s}static fromBytes(t){const[e,r,s,n,o]=Ps(t,[exports.Input,exports.Int,exports.Bytes,exports.OutputOwnersList]);return[new ln(e,r,s,n),o]}toBytes(t){return ks([this.input,this.groupId,this.payload,this.outputOwnerList],t)}};var mn;hn=ln=o([t=>{},a("design:paramtypes",[exports.Input,exports.Int,exports.Bytes,exports.OutputOwnersList])],hn);let xn=mn=class{groupId;outputOwners;_type=exports.TypeSymbols.NftFxMintOutput;constructor(t,e){this.groupId=t,this.outputOwners=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.Int,exports.OutputOwners],e);return[new mn(r,s),n]}toBytes(t){return ks([this.groupId,this.outputOwners],t)}};var gn;xn=mn=o([t=>{},a("design:paramtypes",[exports.Int,exports.OutputOwners])],xn);let bn=gn=class{groupId;payload;outputOwners;_type=exports.TypeSymbols.NftFxTransferOutput;constructor(t,e,r){this.groupId=t,this.payload=e,this.outputOwners=r}static fromBytes(t){const[e,r,s,n]=Ps(t,[exports.Int,exports.Bytes,exports.OutputOwners]);return[new gn(e,r,s),n]}toBytes(t){return ks([this.groupId,this.payload,this.outputOwners],t)}};var yn;bn=gn=o([t=>{},a("design:paramtypes",[exports.Int,exports.Bytes,exports.OutputOwners])],bn);let wn=yn=class{input;output;_type=exports.TypeSymbols.NftFxTransferOperation;constructor(t,e){this.input=t,this.output=e}static fromBytes(t){const[e,r,s]=Ps(t,[exports.Input,bn]);return[new yn(e,r),s]}toBytes(t){return ks([this.input,this.output],t)}};wn=yn=o([t=>{},a("design:paramtypes",[exports.Input,bn])],wn);const In=Object.freeze([xn,bn,hn,wn,fn]);var Bn;let Tn=Bn=class{fxId;outputs;_type=exports.TypeSymbols.InitialState;constructor(t,e){this.fxId=t,this.outputs=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.Int,As],e);return[new Bn(r,s),n]}toBytes(t){return e.concatBytes(this.fxId.toBytes(),t.PackPrefixList(this.outputs))}};var On;Tn=Bn=o([t=>{},a("design:paramtypes",[exports.Int,Array])],Tn);let Sn=On=class{baseTx;name;symbol;denomination;initialStates;_type=exports.TypeSymbols.CreateAssetTx;constructor(t,e,r,s,n){this.baseTx=t,this.name=e,this.symbol=r,this.denomination=s,this.initialStates=n}static fromBytes(t,e){const[r,s,n,o,a,i]=Ps(t,[on,exports.Stringpr,exports.Stringpr,exports.Byte,vs(Tn)],e);return[new On(r,s,n,o,a),i]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.name,this.symbol,this.denomination],t),Es(this.initialStates,t))}};var vn;Sn=On=o([t=>{},a("design:paramtypes",[on,exports.Stringpr,exports.Stringpr,exports.Byte,Array])],Sn);let An=vn=class extends an{baseTx;destination;outs;_type=exports.TypeSymbols.AvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,vs(exports.TransferableOutput)],e);return[new vn(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.destination],t),Es(this.outs,t))}};var En;An=vn=o([t=>{},a("design:paramtypes",[on,exports.Id,Array])],An);let Pn=En=class extends an{baseTx;sourceChain;ins;_type=exports.TypeSymbols.AvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies())).concat(super.getSigIndices())}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,vs(exports.TransferableInput)],e);return[new En(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.sourceChain],t),Es(this.ins,t))}};var kn;Pn=En=o([t=>{},a("design:paramtypes",[on,exports.Id,Array])],Pn);let Rn=kn=class{assetId;UTXOId;transferOp;_type=exports.TypeSymbols.TransferableOp;constructor(t,e,r){this.assetId=t,this.UTXOId=e,this.transferOp=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[exports.Id,vs(en),dn],e);return[new kn(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.assetId],t),Es(this.UTXOId,t),t.PackPrefix(this.transferOp))}};var Dn;Rn=kn=o([t=>{},a("design:paramtypes",[exports.Id,Array,Object])],Rn);let Cn,Nn=Dn=class{baseTx;ops;_type=exports.TypeSymbols.OperationTx;constructor(t,e){this.baseTx=t,this.ops=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[on,vs(Rn)],e);return[new Dn(r,s),n]}toBytes(t){return e.concatBytes(this.baseTx.toBytes(t),Es(this.ops,t))}};Nn=Dn=o([t=>{},a("design:paramtypes",[on,Array])],Nn);const _n=()=>Cn||(Cn=new pn,Cn.RegisterCodec(0,new dn([cn,Sn,Nn,Pn,An,...Qs,...In])),Cn);class Vn extends Is{vm=Ee;getBlockchainId=()=>this.blockchainId.toString()}var Un;let Ln=class{static{Un=this}address;amount;assetId;nonce;_type=exports.TypeSymbols.EvmInput;constructor(t,e,r,s){this.address=t,this.amount=e,this.assetId=r,this.nonce=s}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[exports.Address,exports.BigIntPr,exports.Id,exports.BigIntPr],e);return[new Un(r,s,n,o),a]}static compare=(t,e)=>t.address.value()!==e.address.value()?t.address.value().localeCompare(e.address.value()):t.assetId.value().localeCompare(e.assetId.value());toBytes(t){return Rs(t,this.address,this.amount,this.assetId,this.nonce)}};var Mn;Ln=Un=o([t=>{},a("design:paramtypes",[exports.Address,exports.BigIntPr,exports.Id,exports.BigIntPr])],Ln);let qn=Mn=class extends Vn{networkId;blockchainId;destinationChain;ins;exportedOutputs;_type=exports.TypeSymbols.EvmExportTx;constructor(t,e,r,s,n){super(),this.networkId=t,this.blockchainId=e,this.destinationChain=r,this.ins=s,this.exportedOutputs=n}getSigIndices(){return[[0]]}static fromBytes(t,e){const[r,s,n,o,a,i]=Ps(t,[exports.Int,exports.Id,exports.Id,vs(Ln),vs(exports.TransferableOutput)],e);return[new Mn(r,s,n,o,a),i]}toBytes(t){return Rs(t,this.networkId,this.blockchainId,this.destinationChain,this.ins,this.exportedOutputs)}};var Fn;qn=Mn=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,exports.Id,Array,Array])],qn);let Xn=Fn=class{address;amount;assetId;_type=exports.TypeSymbols.EvmOutput;constructor(t,e,r){this.address=t,this.amount=e,this.assetId=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[exports.Address,exports.BigIntPr,exports.Id],e);return[new Fn(r,s,n),o]}toBytes(t){return Rs(t,this.address,this.amount,this.assetId)}};var jn;Xn=Fn=o([t=>{},a("design:paramtypes",[exports.Address,exports.BigIntPr,exports.Id])],Xn);let Hn,Kn=jn=class extends Vn{networkId;blockchainId;sourceChain;importedInputs;Outs;_type=exports.TypeSymbols.EvmImportTx;constructor(t,e,r,s,n){super(),this.networkId=t,this.blockchainId=e,this.sourceChain=r,this.importedInputs=s,this.Outs=n}getSigIndices(){return this.importedInputs.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,s,n,o,a,i]=Ps(t,[exports.Int,exports.Id,exports.Id,vs(exports.TransferableInput),vs(Xn)],e);return[new jn(r,s,n,o,a),i]}toBytes(t){return Rs(t,this.networkId,this.blockchainId,this.sourceChain,this.importedInputs,this.Outs)}};Kn=jn=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,exports.Id,Array,Array])],Kn);const Wn=new dn([Kn,qn,...Array(3).fill(void 0),...Qs,exports.Input,exports.OutputOwners]),Gn=()=>Hn||(Hn=new pn,Hn.RegisterCodec(0,Wn),Hn);class Zn extends Bs{vm=Pe}var $n;let zn=$n=class{nodeId;startTime;endTime;weight;_type=exports.TypeSymbols.Validator;constructor(t,e,r,s){this.nodeId=t,this.startTime=e,this.endTime=r,this.weight=s}static fromNative(t,e,r,s){return new $n(exports.NodeId.fromString(t),new exports.BigIntPr(e),new exports.BigIntPr(r),new exports.BigIntPr(s))}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[exports.NodeId,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr],e);return[new $n(r,s,n,o),a]}toBytes(t){return ks([this.nodeId,this.startTime,this.endTime,this.weight],t)}};var Yn;zn=$n=o([t=>{},a("design:paramtypes",[exports.NodeId,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr])],zn);let Jn=Yn=class extends Zn{baseTx;validator;stake;rewardsOwner;_type=exports.TypeSymbols.AddDelegatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=s}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[on,zn,vs(exports.TransferableOutput),dn],e);return[new Yn(r,s,n,o),a]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.validator,this.stake],t),t.PackPrefix(this.rewardsOwner))}};Jn=Yn=o([t=>{},a("design:paramtypes",[on,zn,Array,Object])],Jn);class Qn extends Zn{getSubnetAuth(){return this.subnetAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getSubnetAuth().values()].filter((t=>void 0!==t))}}var to;let eo=to=class{validator;subnetId;_type=exports.TypeSymbols.SubnetValidator;constructor(t,e){this.validator=t,this.subnetId=e}static fromNative(t,e,r,s,n){return new to(zn.fromNative(t,e,r,s),n)}static fromBytes(t,e){const[r,s,n]=Ps(t,[zn,exports.Id],e);return[new to(r,s),n]}toBytes(t){return ks([this.validator,this.subnetId],t)}};var ro;eo=to=o([t=>{},a("design:paramtypes",[zn,exports.Id])],eo);let so=ro=class extends Qn{baseTx;subnetValidator;subnetAuth;_type=exports.TypeSymbols.AddSubnetValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.subnetValidator=e,this.subnetAuth=r}getSubnetID(){return this.subnetValidator.subnetId}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,eo,dn],e);return[new ro(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.subnetAuth))}};var no;so=ro=o([t=>{},a("design:paramtypes",[on,eo,Object])],so);let oo=no=class extends Zn{baseTx;validator;stake;rewardsOwner;shares;_type=exports.TypeSymbols.AddValidatorTx;constructor(t,e,r,s,n){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=s,this.shares=n}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,s,n,o,a,i]=Ps(t,[on,zn,vs(exports.TransferableOutput),dn,exports.Int],e);return[new no(r,s,n,o,a),i]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.validator],t),Es(this.stake,t),t.PackPrefix(this.rewardsOwner),this.shares.toBytes())}};var ao;oo=no=o([t=>{},a("design:paramtypes",[on,zn,Array,Object,exports.Int])],oo);let io=ao=class extends Zn{time;_type=exports.TypeSymbols.AdvanceTimeTx;constructor(t){super(),this.time=t}baseTx=void 0;static fromBytes(t,e){const[r,s]=Ps(t,[exports.BigIntPr],e);return[new ao(r),s]}toBytes(t){return Rs(t,this.time)}};var uo;io=ao=o([t=>{},a("design:paramtypes",[exports.BigIntPr])],io);let co=uo=class extends Qn{baseTx;subnetID;chainName;vmID;fxIds;genesisData;subnetAuth;_type=exports.TypeSymbols.CreateChainTx;constructor(t,e,r,s,n,o,a){super(),this.baseTx=t,this.subnetID=e,this.chainName=r,this.vmID=s,this.fxIds=n,this.genesisData=o,this.subnetAuth=a}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,s,n,o,a,i,u,c]=Ps(t,[on,exports.Id,exports.Stringpr,exports.Id,vs(exports.Id),exports.Bytes,dn],e);return[new uo(r,s,n,o,a,i,u),c]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetID,this.chainName,this.vmID],t),Es(this.fxIds,t),this.genesisData.toBytes(),t.PackPrefix(this.subnetAuth))}};var po;co=uo=o([t=>{},a("design:paramtypes",[on,exports.Id,exports.Stringpr,exports.Id,Array,exports.Bytes,Object])],co);let fo=po=class extends Zn{baseTx;subnetOwners;_type=exports.TypeSymbols.CreateSubnetTx;constructor(t,e){super(),this.baseTx=t,this.subnetOwners=e}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,s,n]=Ps(t,[on,dn],e);return[new po(r,s),n]}toBytes(t){return e.concatBytes(ks([this.baseTx],t),t.PackPrefix(this.subnetOwners))}};var lo;fo=po=o([t=>{},a("design:paramtypes",[on,Object])],fo);let ho=lo=class extends Zn{baseTx;destination;outs;_type=exports.TypeSymbols.PvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,vs(exports.TransferableOutput)],e);return[new lo(r,s,n),o]}toBytes(t){return Rs(t,this.baseTx,this.destination,this.outs)}};var mo;ho=lo=o([t=>{},a("design:paramtypes",[on,exports.Id,Array])],ho);let xo=mo=class extends Zn{baseTx;sourceChain;ins;_type=exports.TypeSymbols.PvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,vs(exports.TransferableInput)],e);return[new mo(r,s,n),o]}toBytes(t){return ks([this.baseTx,this.sourceChain,this.ins],t)}};var go;xo=mo=o([t=>{},a("design:paramtypes",[on,exports.Id,Array])],xo);let bo=go=class extends Zn{txId;_type=exports.TypeSymbols.RewardValidatorTx;constructor(t){super(),this.txId=t}baseTx=void 0;static fromBytes(t,e){const[r,s]=Ps(t,[exports.Id],e);return[new go(r),s]}toBytes(t){return Rs(t,this.txId)}};var yo;bo=go=o([t=>{},a("design:paramtypes",[exports.Id])],bo);let wo=yo=class{lockTime;transferableInput;_type=exports.TypeSymbols.StakeableLockIn;constructor(t,e){this.lockTime=t,this.transferableInput=e}static fromBytes(t,e){const[r,s]=Ps(t,[exports.BigIntPr],e),[n,o]=e.UnpackPrefix(s);return[new yo(r,n),o]}amount(){return this.transferableInput.amount()}toBytes(t){return e.concatBytes(Rs(t,this.lockTime),t.PackPrefix(this.transferableInput))}};var Io;wo=yo=o([t=>{},a("design:paramtypes",[exports.BigIntPr,Object])],wo);let Bo=Io=class{lockTime;transferOut;_type=exports.TypeSymbols.StakeableLockOut;constructor(t,e){this.lockTime=t,this.transferOut=e}amount(){return this.transferOut.amount()}getStakeableLocktime(){return this.lockTime.value()}getLocktime(){return this.lockTime.value()}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.BigIntPr,dn],e);return[new Io(r,s),n]}getOwners(){if(Ms(this.transferOut))return this.transferOut.getOwners();throw new Error("Unable to get owners.")}getOutputOwners(){if(Ms(this.transferOut))return this.transferOut.outputOwners;throw new Error("Unable to get output owners.")}toBytes(t){return e.concatBytes(Rs(t,this.lockTime),t.PackPrefix(this.transferOut))}};var To;Bo=Io=o([t=>{},a("design:paramtypes",[exports.BigIntPr,Object])],Bo);let Oo=To=class extends Zn{baseTx;subnetValidator;signer;stake;validatorRewardsOwner;delegatorRewardsOwner;shares;_type=exports.TypeSymbols.AddPermissionlessValidatorTx;constructor(t,e,r,s,n,o,a){super(),this.baseTx=t,this.subnetValidator=e,this.signer=r,this.stake=s,this.validatorRewardsOwner=n,this.delegatorRewardsOwner=o,this.shares=a}getValidatorRewardsOwner(){return this.validatorRewardsOwner}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,s,n,o,a,i,u,c]=Ps(t,[on,eo,dn,vs(exports.TransferableOutput),dn,dn,exports.Int],e);return[new To(r,s,n,o,a,i,u),c]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.signer),Es(this.stake,t),t.PackPrefix(this.validatorRewardsOwner),t.PackPrefix(this.delegatorRewardsOwner),this.shares.toBytes())}};var So;Oo=To=o([t=>{},a("design:paramtypes",[on,eo,Function,Array,Object,Object,exports.Int])],Oo);let vo=So=class extends Zn{baseTx;subnetValidator;stake;delegatorRewardsOwner;_type=exports.TypeSymbols.AddPermissionlessDelegatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.subnetValidator=e,this.stake=r,this.delegatorRewardsOwner=s}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[on,eo,vs(exports.TransferableOutput),dn],e);return[new So(r,s,n,o),a]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetValidator],t),Es(this.stake,t),t.PackPrefix(this.delegatorRewardsOwner))}};vo=So=o([t=>{},a("design:paramtypes",[on,eo,Array,Object])],vo);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const Ao=2n**256n,Eo=Ao-0x1000003d1n,Po=Ao-0x14551231950b75fc4402da1732fc9bebfn,ko=0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Ro=0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,Do={p:Eo,n:Po,a:0n,b:7n,Gx:ko,Gy:Ro},Co=32,No=t=>jo(jo(t*t)*t+Do.b),_o=(t="")=>{throw new Error(t)},Vo=t=>"bigint"==typeof t,Uo=t=>"string"==typeof t,Lo=t=>Vo(t)&&0n<t&&t<Eo,Mo=t=>Vo(t)&&0n<t&&t<Po,qo=(t,e)=>!(t instanceof Uint8Array)||"number"==typeof e&&e>0&&t.length!==e?_o("Uint8Array expected"):t,Fo=t=>new Uint8Array(t),Xo=(t,e)=>qo(Uo(t)?Yo(t):Fo(t),e),jo=(t,e=Eo)=>{let r=t%e;return r>=0n?r:e+r},Ho=t=>t instanceof Wo?t:_o("Point expected");let Ko;class Wo{constructor(t,e,r){this.px=t,this.py=e,this.pz=r}static fromAffine(t){return new Wo(t.x,t.y,1n)}static fromHex(t){let e;const r=(t=Xo(t))[0],s=t.subarray(1),n=Qo(s,0,Co),o=t.length;if(33===o&&[2,3].includes(r)){Lo(n)||_o("Point hex invalid: x not FE");let t=na(No(n));!(1&~r)!==(1n===(1n&t))&&(t=jo(-t)),e=new Wo(n,t,1n)}return 65===o&&4===r&&(e=new Wo(n,Qo(s,Co,64),1n)),e?e.ok():_o("Point is not on curve")}static fromPrivateKey(t){return Go.mul(oa(t))}get x(){return this.aff().x}get y(){return this.aff().y}equals(t){const{px:e,py:r,pz:s}=this,{px:n,py:o,pz:a}=Ho(t),i=jo(e*a),u=jo(n*s),c=jo(r*a),d=jo(o*s);return i===u&&c===d}negate(){return new Wo(this.px,jo(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:e,py:r,pz:s}=this,{px:n,py:o,pz:a}=Ho(t),{a:i,b:u}=Do;let c=0n,d=0n,p=0n;const f=jo(3n*u);let l=jo(e*n),h=jo(r*o),m=jo(s*a),x=jo(e+r),g=jo(n+o);x=jo(x*g),g=jo(l+h),x=jo(x-g),g=jo(e+s);let b=jo(n+a);return g=jo(g*b),b=jo(l+m),g=jo(g-b),b=jo(r+s),c=jo(o+a),b=jo(b*c),c=jo(h+m),b=jo(b-c),p=jo(i*g),c=jo(f*m),p=jo(c+p),c=jo(h-p),p=jo(h+p),d=jo(c*p),h=jo(l+l),h=jo(h+l),m=jo(i*m),g=jo(f*g),h=jo(h+m),m=jo(l-m),m=jo(i*m),g=jo(g+m),l=jo(h*g),d=jo(d+l),l=jo(b*g),c=jo(x*c),c=jo(c-l),l=jo(x*h),p=jo(b*p),p=jo(p+l),new Wo(c,d,p)}mul(t,e=!0){if(!e&&0n===t)return Zo;if(Mo(t)||_o("invalid scalar"),this.equals(Go))return ya(t).p;let r=Zo,s=Go;for(let n=this;t>0n;n=n.double(),t>>=1n)1n&t?r=r.add(n):e&&(s=s.add(n));return r}mulAddQUns(t,e,r){return this.mul(e,!1).add(t.mul(r,!1)).ok()}toAffine(){const{px:t,py:e,pz:r}=this;if(this.equals(Zo))return{x:0n,y:0n};if(1n===r)return{x:t,y:e};const s=sa(r);return 1n!==jo(r*s)&&_o("invalid inverse"),{x:jo(t*s),y:jo(e*s)}}assertValidity(){const{x:t,y:e}=this.aff();return Lo(t)&&Lo(e)||_o("Point invalid: x or y"),jo(e*e)===No(t)?this:_o("Point invalid: not on curve")}multiply(t){return this.mul(t)}aff(){return this.toAffine()}ok(){return this.assertValidity()}toHex(t=!0){const{x:e,y:r}=this.aff();return(t?0n===(1n&r)?"02":"03":"04")+ea(e)+(t?"":ea(r))}toRawBytes(t=!0){return Yo(this.toHex(t))}}Wo.BASE=new Wo(ko,Ro,1n),Wo.ZERO=new Wo(0n,1n,0n);const{BASE:Go,ZERO:Zo}=Wo,$o=(t,e)=>t.toString(16).padStart(e,"0"),zo=t=>Array.from(t).map((t=>$o(t,2))).join(""),Yo=t=>{const e=t.length;(!Uo(t)||e%2)&&_o("hex invalid 1");const r=Fo(e/2);for(let e=0;e<r.length;e++){const s=2*e,n=t.slice(s,s+2),o=Number.parseInt(n,16);(Number.isNaN(o)||o<0)&&_o("hex invalid 2"),r[e]=o}return r},Jo=t=>BigInt("0x"+(zo(t)||"0")),Qo=(t,e,r)=>Jo(t.slice(e,r)),ta=t=>Vo(t)&&t>=0n&&t<Ao?Yo($o(t,64)):_o("bigint expected"),ea=t=>zo(ta(t)),ra=(...t)=>{const e=Fo(t.reduce(((t,e)=>t+qo(e).length),0));let r=0;return t.forEach((t=>{e.set(t,r),r+=t.length})),e},sa=(t,e=Eo)=>{(0n===t||e<=0n)&&_o("no inverse n="+t+" mod="+e);let r=jo(t,e),s=e,n=0n,o=1n;for(;0n!==r;){const t=s%r,e=n-o*(s/r);s=r,r=t,n=o,o=e}return 1n===s?jo(n,e):_o("no inverse")},na=t=>{let e=1n;for(let r=t,s=(Eo+1n)/4n;s>0n;s>>=1n)1n&s&&(e=e*r%Eo),r=r*r%Eo;return jo(e*e)===t?e:_o("sqrt invalid")},oa=t=>(Vo(t)||(t=Jo(Xo(t,Co))),Mo(t)?t:_o("private key out of range")),aa=t=>t>Po>>1n;class ia{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){return t=Xo(t,64),new ia(Qo(t,0,Co),Qo(t,Co,64))}assertValidity(){return Mo(this.r)&&Mo(this.s)?this:_o()}addRecoveryBit(t){return new ia(this.r,this.s,t)}hasHighS(){return aa(this.s)}recoverPublicKey(t){const{r:e,s:r,recovery:s}=this;[0,1,2,3].includes(s)||_o("recovery id invalid");const n=ca(Xo(t,32)),o=2===s||3===s?e+Po:e;o>=Eo&&_o("q.x invalid");const a=1&s?"03":"02",i=Wo.fromHex(a+ea(o)),u=sa(o,Po),c=jo(-n*u,Po),d=jo(r*u,Po);return Go.mulAddQUns(i,c,d)}toCompactRawBytes(){return Yo(this.toCompactHex())}toCompactHex(){return ea(this.r)+ea(this.s)}}const ua=t=>{const e=8*t.length-256,r=Jo(t);return e>0?r>>BigInt(e):r},ca=t=>jo(ua(t),Po),da=t=>ta(t),pa=()=>"object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;let fa;const la={lowS:!0},ha={lowS:!0};async function ma(t,e,r=la){const{seed:s,k2sig:n}=function(t,e,r=la){["der","recovered","canonical"].some((t=>t in r))&&_o("sign() legacy options not supported");let{lowS:s}=r;null==s&&(s=!0);const n=ca(Xo(t)),o=da(n),a=oa(e),i=[da(a),o];let u=r.extraEntropy;if(u){!0===u&&(u=ga.randomBytes(Co));const t=Xo(u);t.length!==Co&&_o(),i.push(t)}const c=n;return{seed:ra(...i),k2sig:t=>{const e=ua(t);if(!Mo(e))return;const r=sa(e,Po),n=Go.mul(e).aff(),o=jo(n.x,Po);if(0n===o)return;const i=jo(r*jo(c+jo(a*o,Po),Po),Po);if(0n===i)return;let u=i,d=(n.x===o?0:2)|Number(1n&n.y);return s&&aa(i)&&(u=jo(-i,Po),d^=1),new ia(o,u,d)}}}(t,e,r);return function(t){let e=Fo(Co),r=Fo(Co),s=0;const n=()=>{e.fill(1),r.fill(0),s=0},o="drbg: tried 1000 values";if(t){const t=(...t)=>ga.hmacSha256Async(r,e,...t),a=async(s=Fo())=>{r=await t(Fo([0]),s),e=await t(),0!==s.length&&(r=await t(Fo([1]),s),e=await t())},i=async()=>(s++>=1e3&&_o(o),e=await t(),e);return async(t,e)=>{let r;for(n(),await a(t);!(r=e(await i()));)await a();return n(),r}}{const t=(...t)=>{const s=fa;return s||_o("etc.hmacSha256Sync not set"),s(r,e,...t)},a=(s=Fo())=>{r=t(Fo([0]),s),e=t(),0!==s.length&&(r=t(Fo([1]),s),e=t())},i=()=>(s++>=1e3&&_o(o),e=t(),e);return(t,e)=>{let r;for(n(),a(t);!(r=e(i()));)a();return n(),r}}}(!0)(s,n)}function xa(t){((t=Xo(t)).length<40||t.length>1024)&&_o("expected proper params");const e=jo(Jo(t),Po-1n)+1n;return ta(e)}const ga={hexToBytes:Yo,bytesToHex:zo,concatBytes:ra,bytesToNumberBE:Jo,numberToBytesBE:ta,mod:jo,invert:sa,hmacSha256Async:async(t,...e)=>{const r=pa();if(!r)return _o("etc.hmacSha256Async not set");const s=r.subtle,n=await s.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Fo(await s.sign("HMAC",n,ra(...e)))},hmacSha256Sync:fa,hashToPrivateKey:xa,randomBytes:t=>{const e=pa();return e||_o("crypto.getRandomValues must be defined"),e.getRandomValues(Fo(t))}},ba={normPrivateKeyToScalar:oa,isValidPrivateKey:t=>{try{return!!oa(t)}catch(t){return!1}},randomPrivateKey:()=>xa(ga.randomBytes(40)),precompute:(t=8,e=Go)=>(e.multiply(3n),e)};Object.defineProperties(ga,{hmacSha256Sync:{configurable:!1,get:()=>fa,set(t){fa||(fa=t)}}});const ya=t=>{const e=Ko||(Ko=(()=>{const t=[];let e=Go,r=e;for(let s=0;s<33;s++){r=e,t.push(r);for(let s=1;s<128;s++)r=r.add(e),t.push(r);e=r.double()}return t})()),r=(t,e)=>{let r=e.negate();return t?r:e};let s=Zo,n=Go;const o=BigInt(255),a=BigInt(8);for(let i=0;i<33;i++){const u=128*i;let c=Number(t&o);t>>=a,c>128&&(c-=256,t+=1n);const d=u,p=u+Math.abs(c)-1,f=i%2!=0,l=c<0;0===c?n=n.add(r(f,e[d])):s=s.add(r(l,e[p]))}return{p:s,f:n}};function wa(t,e){return Ia(r.sha256(t),e)}async function Ia(t,r){const s=await ma(t,r);if(void 0!==s.recovery)return e.concatBytes(s.toCompactRawBytes(),new Uint8Array([s.recovery]));throw new Error("Recovery bit is missing.")}function Ba(t,e){const r=e.slice(-1);return ia.fromCompact(e.slice(0,-1)).addRecoveryBit(r[0]).recoverPublicKey(t).toRawBytes(!0)}function Ta(t){return function(t,e=!0){return Wo.fromPrivateKey(t).toRawBytes(e)}(t,!0)}function Oa(t){return s.ripemd160(r.sha256(t))}function Sa(t){return Te(be.fromPublicKey(t))}var va,Aa=Object.freeze({__proto__:null,SIGNATURE_LENGTH:65,getPublicKey:Ta,publicKeyBytesToAddress:Oa,publicKeyToEthAddress:Sa,randomPrivateKey:function(){return ba.randomPrivateKey()},recoverPublicKey:Ba,sign:wa,signHash:Ia,verify:function(t,e,r){return function(t,e,r,s=ha){let n,o,a,{lowS:i}=s;null==i&&(i=!0),"strict"in s&&_o("verify() legacy options not supported");const u=t&&"object"==typeof t&&"r"in t;u||64===Xo(t).length||_o("signature must be 64 bytes");try{n=u?new ia(t.r,t.s).assertValidity():ia.fromCompact(t),o=ca(Xo(e,Co)),a=r instanceof Wo?r.ok():Wo.fromHex(r)}catch(t){return!1}if(!n)return!1;const{r:c,s:d}=n;if(i&&aa(d))return!1;let p;try{const t=sa(d,Po),e=jo(o*t,Po),r=jo(c*t,Po);p=Go.mulAddQUns(a,e,r).aff()}catch(t){return!1}return!!p&&jo(p.x,Po)===c}(t.slice(0,-1),e,r)}});let Ea=va=class{publicKey;signature;_type=exports.TypeSymbols.ProofOfPossession;constructor(t,e){this.publicKey=t,this.signature=e;const r=Mr(t),s=Fr(e);if(r.assertValidity(),s.assertValidity(),!jr(r,s,qr(r)))throw new Error("Invalid proof of possession")}static fromBytes(t){const e=t.slice(0,_r),r=t.slice(_r,144),s=t.slice(144);return[new va(e,r),s]}toString(){return Be(this.toBytes())}toBytes(){return e.concatBytes(this.publicKey,this.signature)}};var Pa,ka;Ea=va=o([t=>{},a("design:paramtypes",[Uint8Array,Uint8Array])],Ea);let Ra=Pa=class{proof;_type=exports.TypeSymbols.Signer;constructor(t){this.proof=t}static fromBytes(t,e){const[r,s]=Ps(t,[Ea],e);return[new Pa(r),s]}toBytes(t){return ks([this.proof],t)}};Ra=Pa=o([t=>{},a("design:paramtypes",[Ea])],Ra);let Da=ka=class{_type=exports.TypeSymbols.SignerEmpty;static fromBytes(t,e){const[r]=Ps(t,[],e);return[new ka,r]}toBytes(t){return ks([],t)}};var Ca;Da=ka=o([t=>{}],Da);let Na=Ca=class extends Qn{baseTx;nodeId;subnetId;subnetAuth;_type=exports.TypeSymbols.RemoveSubnetValidatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.nodeId=e,this.subnetId=r,this.subnetAuth=s}getSubnetID(){return this.subnetId}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[on,exports.NodeId,exports.Id,dn],e);return[new Ca(r,s,n,o),a]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.nodeId,this.subnetId],t),t.PackPrefix(this.subnetAuth))}};var _a;Na=Ca=o([t=>{},a("design:paramtypes",[on,exports.NodeId,exports.Id,Object])],Na);let Va=_a=class extends Qn{baseTx;subnetID;subnetAuth;subnetOwners;_type=exports.TypeSymbols.TransferSubnetOwnershipTx;constructor(t,e,r,s){super(),this.baseTx=t,this.subnetID=e,this.subnetAuth=r,this.subnetOwners=s}getSubnetID(){return this.subnetID}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[on,exports.Id,dn,dn],e);return[new _a(r,s,n,o),a]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetID],t),t.PackPrefix(this.subnetAuth),t.PackPrefix(this.subnetOwners))}};var Ua;Va=_a=o([t=>{},a("design:paramtypes",[on,exports.Id,Object,Object])],Va);let La=Ua=class extends Qn{baseTx;subnetID;assetId;initialSupply;maximumSupply;minConsumptionRate;maxConsumptionRate;minValidatorStake;maxValidatorStake;minStakeDuration;maxStakeDuration;minDelegationFee;minDelegatorStake;maxValidatorWeightFactor;uptimeRequirement;subnetAuth;_type=exports.TypeSymbols.TransformSubnetTx;constructor(t,e,r,s,n,o,a,i,u,c,d,p,f,l,h,m){super(),this.baseTx=t,this.subnetID=e,this.assetId=r,this.initialSupply=s,this.maximumSupply=n,this.minConsumptionRate=o,this.maxConsumptionRate=a,this.minValidatorStake=i,this.maxValidatorStake=u,this.minStakeDuration=c,this.maxStakeDuration=d,this.minDelegationFee=p,this.minDelegatorStake=f,this.maxValidatorWeightFactor=l,this.uptimeRequirement=h,this.subnetAuth=m}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,s,n,o,a,i,u,c,d,p,f,l,h,m,x,g,b]=Ps(t,[on,exports.Id,exports.Id,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.Int,exports.Int,exports.Int,exports.BigIntPr,exports.Byte,exports.Int,dn],e);return[new Ua(r,s,n,o,a,i,u,c,d,p,f,l,h,m,x,g),b]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetID,this.assetId,this.initialSupply,this.maximumSupply,this.minConsumptionRate,this.maxConsumptionRate,this.minValidatorStake,this.maxValidatorStake,this.minStakeDuration,this.maxStakeDuration,this.minDelegationFee,this.minDelegatorStake,this.maxValidatorWeightFactor,this.uptimeRequirement],t),t.PackPrefix(this.subnetAuth))}};var Ma;La=Ua=o([t=>{},a("design:paramtypes",[on,exports.Id,exports.Id,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.Int,exports.Int,exports.Int,exports.BigIntPr,exports.Byte,exports.Int,Object])],La);let qa=Ma=class extends Zn{baseTx;_type=exports.TypeSymbols.PvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,s]=Ps(t,[on],e);return[new Ma(r),s]}toBytes(t){return this.baseTx.toBytes(t)}};var Fa,Xa,ja;qa=Ma=o([t=>{},a("design:paramtypes",[on])],qa),exports.PChainOwner=Fa=class{threshold;addresses;_type=exports.TypeSymbols.PChainOwner;constructor(t,e){this.threshold=t,this.addresses=e}getAddresses(){return this.addresses}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.Int,vs(exports.Address)],e);return[new Fa(r,s),n]}toBytes(t){return e.concatBytes(ks([this.threshold,this.addresses],t))}static fromNative(t,e=1){return new Fa(new exports.Int(e),t.map((t=>new exports.Address(t))))}},exports.PChainOwner=Fa=o([t=>{},a("design:paramtypes",[exports.Int,Array])],exports.PChainOwner),exports.L1Validator=Xa=class{nodeId;weight;balance;signer;remainingBalanceOwner;deactivationOwner;_type=exports.TypeSymbols.L1Validator;constructor(t,e,r,s,n,o){this.nodeId=t,this.weight=e,this.balance=r,this.signer=s,this.remainingBalanceOwner=n,this.deactivationOwner=o}getBalance(){return this.balance}getNodeId(){return this.nodeId}getWeight(){return this.weight.value()}getRemainingBalanceOwner(){return this.remainingBalanceOwner}getDeactivationOwner(){return this.deactivationOwner}static fromNative(t,e,r,s,n,o){return new Xa(new exports.Bytes(exports.NodeId.fromString(t).toBytes()),new exports.BigIntPr(e),new exports.BigIntPr(r),s,n,o)}static fromBytes(t,e){const[r,s,n,o,a,i,u]=Ps(t,[exports.Bytes,exports.BigIntPr,exports.BigIntPr,Ea,exports.PChainOwner,exports.PChainOwner],e);return[new Xa(r,s,n,o,a,i),u]}toBytes(t){return ks([this.nodeId,this.weight,this.balance,this.signer,this.remainingBalanceOwner,this.deactivationOwner],t)}},exports.L1Validator=Xa=o([t=>{},a("design:paramtypes",[exports.Bytes,exports.BigIntPr,exports.BigIntPr,Ea,exports.PChainOwner,exports.PChainOwner])],exports.L1Validator);let Ha=ja=class extends Qn{baseTx;subnetID;chainID;address;validators;subnetAuth;_type=exports.TypeSymbols.ConvertSubnetToL1Tx;constructor(t,e,r,s,n,o){super(),this.baseTx=t,this.subnetID=e,this.chainID=r,this.address=s,this.validators=n,this.subnetAuth=o}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,s,n,o,a,i,u]=Ps(t,[on,exports.Id,exports.Id,exports.Bytes,vs(exports.L1Validator),dn],e);return[new ja(r,s,n,o,a,i),u]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.subnetID,this.chainID,this.address],t),Es(this.validators,t),t.PackPrefix(this.subnetAuth))}};var Ka;Ha=ja=o([t=>{},a("design:paramtypes",[on,exports.Id,exports.Id,exports.Bytes,Array,Object])],Ha);let Wa=Ka=class extends Zn{baseTx;validationId;balance;_type=exports.TypeSymbols.IncreaseL1ValidatorBalanceTx;constructor(t,e,r){super(),this.baseTx=t,this.validationId=e,this.balance=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,exports.BigIntPr],e);return[new Ka(r,s,n),o]}toBytes(t){return ks([this.baseTx,this.validationId,this.balance],t)}};var Ga;Wa=Ka=o([t=>{},a("design:paramtypes",[on,exports.Id,exports.BigIntPr])],Wa);let Za=Ga=class extends Zn{baseTx;validationId;disableAuth;_type=exports.TypeSymbols.DisableL1ValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.validationId=e,this.disableAuth=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[on,exports.Id,dn],e);return[new Ga(r,s,n),o]}toBytes(t){return e.concatBytes(ks([this.baseTx,this.validationId],t),t.PackPrefix(this.disableAuth))}getDisableAuth(){return this.disableAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getDisableAuth().values()].filter((t=>void 0!==t))}};var $a;Za=Ga=o([t=>{},a("design:paramtypes",[on,exports.Id,Object])],Za);let za=$a=class extends Zn{baseTx;message;_type=exports.TypeSymbols.SetL1ValidatorWeightTx;constructor(t,e){super(),this.baseTx=t,this.message=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[on,exports.Bytes],e);return[new $a(r,s),n]}toBytes(t){return ks([this.baseTx,this.message],t)}};var Ya;za=$a=o([t=>{},a("design:paramtypes",[on,exports.Bytes])],za);let Ja=Ya=class extends Zn{baseTx;balance;blsSignature;message;_type=exports.TypeSymbols.RegisterL1ValidatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.balance=e,this.blsSignature=r,this.message=s}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[on,exports.BigIntPr,exports.BlsSignature,exports.Bytes],e);return[new Ya(r,s,n,o),a]}toBytes(t){return ks([this.baseTx,this.balance,this.blsSignature,this.message],t)}};Ja=Ya=o([t=>{},a("design:paramtypes",[on,exports.BigIntPr,exports.BlsSignature,exports.Bytes])],Ja);const Qa=new dn([...new Array(5),...Qs,exports.Input,exports.OutputOwners,oo,so,Jn,co,fo,xo,ho,io,bo,wo,Bo,Na,La,Oo,vo,Da,Ra,...new Array(4),Va,qa,Ha,Ja,za,Wa,Za]);let ti;const ei=()=>ti||(ti=new pn,ti.RegisterCodec(0,Qa),ti);function ri(t){switch(t){case"AVM":return _n();case"EVM":return Gn();case"PVM":return ei();default:throw new Error("unknown VM")}}function si(t){return ri(t.vm).packCodec(t)}var ni;let oi=ni=class{unsignedTx;credentials;_type=exports.TypeSymbols.AvmSignedTx;constructor(t,e){this.unsignedTx=t,this.credentials=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[dn,vs(dn)],e);return[new ni(r,s),n]}getCredentials(){return this.credentials}getAllSignatures(){return this.getCredentials().flatMap((t=>t.getSignatures()))}toBytes(){const t=ri(this.unsignedTx.vm).getCodecForVersion(new exports.Short(0));return e.concatBytes(new exports.Short(0).toBytes(),t.PackPrefix(this.unsignedTx),t.PackPrefixList(this.credentials))}};function ai(t){return t._type===exports.TypeSymbols.TransferableOutput}function ii(t){return t._type===exports.TypeSymbols.TransferableInput}oi=ni=o([t=>{},a("design:paramtypes",[Function,Array])],oi);var ui=Object.freeze({__proto__:null,AvaxTx:Bs,get BaseTx(){return on},get SignedTx(){return oi},get TransferableInput(){return exports.TransferableInput},get TransferableOutput(){return exports.TransferableOutput},get UTXOID(){return en},isBaseTx:function(t){return t._type===exports.TypeSymbols.BaseTx},isTransferableInput:ii,isTransferableOutput:ai});function ci(t){return t._type===exports.TypeSymbols.AvmBaseTx}function di(t){return t._type===exports.TypeSymbols.AvmExportTx}function pi(t){return t._type===exports.TypeSymbols.AvmImportTx}var fi=Object.freeze({__proto__:null,get BaseTx(){return cn},get CreateAssetTx(){return Sn},get ExportTx(){return An},get ImportTx(){return Pn},get InitialState(){return Tn},get OperationTx(){return Nn},getAVMManager:_n,isAvmBaseTx:ci,isCreateAssetTx:function(t){return t._type===exports.TypeSymbols.CreateAssetTx},isExportTx:di,isImportTx:pi,isOperationTx:function(t){return t._type===exports.TypeSymbols.OperationTx}});function li(t){return t._type==exports.TypeSymbols.EvmExportTx}function hi(t){return t._type==exports.TypeSymbols.EvmImportTx}function mi(t){return hi(t)||li(t)}function xi(t){return!(!li(t)&&!hi(t))}var gi,bi=Object.freeze({__proto__:null,EVMTx:Vn,get ExportTx(){return qn},get ImportTx(){return Kn},get Input(){return Ln},get Output(){return Xn},isEvmTx:mi,isExportTx:li,isImportExportTx:xi,isImportTx:hi});let yi=gi=class{signers;signature;_type=exports.TypeSymbols.WarpSignature;constructor(t,e){this.signers=t,this.signature=e}static fromBytes(t,e){const[r,s,n]=Ps(t,[exports.Bytes,exports.BlsSignature],e);return[new gi(r,s),n]}toBytes(t){return ks([this.signers,this.signature],t)}numOfSigners(){return Se(this.signers.bytes)}};yi=gi=o([t=>{},a("design:paramtypes",[exports.Bytes,exports.BlsSignature])],yi);const wi=new dn([yi]);let Ii;const Bi=()=>Ii||(Ii=new pn,Ii.RegisterCodec(0,wi),Ii);var Ti;let Oi=Ti=class{networkId;sourceChainId;payload;_type=exports.TypeSymbols.WarpUnsignedMessage;constructor(t,e,r){this.networkId=t,this.sourceChainId=e,this.payload=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[exports.Int,exports.Id,exports.Bytes],e);return[new Ti(r,s,n),o]}toBytes(t){return ks([this.networkId,this.sourceChainId,this.payload],t)}};var Si;Oi=Ti=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,exports.Bytes])],Oi);let vi=Si=class{unsignedMessage;signature;_type=exports.TypeSymbols.WarpMessage;constructor(t,e){this.unsignedMessage=t,this.signature=e}static fromBytes(t,e){const[r,s]=Ps(t,[Oi],e),[n,o]=e.UnpackPrefix(s);return[new Si(r,n),o]}toBytes(t){return e.concatBytes(this.unsignedMessage.toBytes(t),t.PackPrefix(this.signature))}};var Ai;vi=Si=o([t=>{},a("design:paramtypes",[Oi,Function])],vi);let Ei=Ai=class{sourceAddress;payload;_type=exports.TypeSymbols.AddressedCall;codecId=new exports.Short(0);typeId=new exports.Int(1);constructor(t,e){this.sourceAddress=t,this.payload=e}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Int],e);if(1!==r.value())throw new Error(`Invalid type id for AddressedCall. Required typeId: 1. Got typeId: ${r.value()}`);const[n,o,a]=Ps(s,[exports.Bytes,exports.Bytes],e),i=new exports.Address(n.bytes);return[new Ai(i,o),a]}toBytes(t){const e=new exports.Bytes(this.sourceAddress.toBytes());return ks([this.typeId,e,this.payload],t)}getSourceAddress(t="hex",e="avax"){return"bech32"===t?this.sourceAddress.toString(e):this.sourceAddress.toHex()}getPayload(){return this.payload.toString("hex")}};var Pi;Ei=Ai=o([t=>{},a("design:paramtypes",[exports.Address,exports.Bytes])],Ei);let ki=Pi=class{subnetId;nodeId;blsPublicKey;expiry;remainingBalanceOwner;disableOwner;weight;_type=exports.TypeSymbols.RegisterL1ValidatorMessage;codecId=new exports.Short(0);typeId=new exports.Int(1);constructor(t,e,r,s,n,o,a){this.subnetId=t,this.nodeId=e,this.blsPublicKey=r,this.expiry=s,this.remainingBalanceOwner=n,this.disableOwner=o,this.weight=a}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Int],e);if(1!==r.value())throw new Error(`Invalid type id for RegisterL1ValidatorMessage. Required typeId: 1. Got typeId: ${r.value()}`);const[n,o,a,i,u,c,d,p]=Ps(s,[exports.Id,exports.Bytes,exports.BlsPublicKey,exports.BigIntPr,exports.PChainOwner,exports.PChainOwner,exports.BigIntPr],e),f=new exports.NodeId(o.bytes);return[new Pi(n,f,a,i,u,c,d),p]}toBytes(t){const e=new exports.Bytes(this.nodeId.toBytes());return ks([this.typeId,this.subnetId,e,this.blsPublicKey,this.expiry,this.remainingBalanceOwner,this.disableOwner,this.weight],t)}getSubnetId(){return this.subnetId.value()}getNodeId(){return this.nodeId.value()}getBlsPublicKey(){return this.blsPublicKey}getExpiry(){return this.expiry.value()}getRemainingBalanceOwner(){return this.remainingBalanceOwner}getDisableOwner(){return this.disableOwner}getWeight(){return this.weight.value()}};var Ri;ki=Pi=o([t=>{},a("design:paramtypes",[exports.Id,exports.NodeId,exports.BlsPublicKey,exports.BigIntPr,exports.PChainOwner,exports.PChainOwner,exports.BigIntPr])],ki);let Di=Ri=class{validationId;nonce;weight;_type=exports.TypeSymbols.L1ValidatorWeightMessage;codecId=new exports.Short(0);typeId=new exports.Int(3);constructor(t,e,r){this.validationId=t,this.nonce=e,this.weight=r}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Int],e);if(3!==r.value())throw new Error(`Invalid type id for L1ValidatorWeightMessage. Required typeId: 3. Got typeId: ${r.value()}`);const[n,o,a,i]=Ps(s,[exports.Id,exports.BigIntPr,exports.BigIntPr],e);return[new Ri(n,o,a),i]}toBytes(t){return ks([this.typeId,this.validationId,this.nonce,this.weight],t)}getWeight(){return this.weight.value()}getNonce(){return this.nonce.value()}getValidationId(){return this.validationId.value()}};var Ci;Di=Ri=o([t=>{},a("design:paramtypes",[exports.Id,exports.BigIntPr,exports.BigIntPr])],Di);let Ni=Ci=class{validationId;registered;_type=exports.TypeSymbols.L1ValidatorRegistrationMessage;codecId=new exports.Short(0);typeId=new exports.Int(2);constructor(t,e){this.validationId=t,this.registered=e}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Int],e);if(2!==r.value())throw new Error(`Invalid type id for L1ValidatorRegistrationMessage. Required typeId: 2. Got typeId: ${r.value()}`);const[n,o,a]=Ps(s,[exports.Id,exports.Bool],e);return[new Ci(n,o),a]}toBytes(t){return ks([this.typeId,this.validationId,this.registered],t)}getValidationId(){return this.validationId.value()}getRegistered(){return this.registered.value()}};var _i;Ni=Ci=o([t=>{},a("design:paramtypes",[exports.Id,exports.Bool])],Ni);let Vi=_i=class{conversionId;_type=exports.TypeSymbols.SubnetToL1ConversionMessage;codecId=new exports.Short(0);typeId=new exports.Int(0);constructor(t){this.conversionId=t}static fromBytes(t,e){const[r,s]=Ps(t,[exports.Int],e);if(0!==r.value())throw new Error(`Invalid type id for SubnetToL1ConversionMessage. Required typeId: 0. Got typeId: ${r.value()}`);const[n,o]=Ps(s,[exports.Id],e);return[new _i(n),o]}toBytes(t){return ks([this.typeId,this.conversionId],t)}getConversionId(){return this.conversionId.value()}};var Ui;Vi=_i=o([t=>{},a("design:paramtypes",[exports.Id])],Vi);let Li=Ui=class{nodeId;blsPublicKey;weight;_type=exports.TypeSymbols.ValidatorData;constructor(t,e,r){this.nodeId=t,this.blsPublicKey=e,this.weight=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[exports.Bytes,exports.BlsPublicKey,exports.BigIntPr],e),a=new exports.NodeId(r.bytes);return[new Ui(a,s,n),o]}toBytes(t){return ks([new exports.Bytes(this.nodeId.toBytes()),this.blsPublicKey,this.weight],t)}};var Mi;Li=Ui=o([t=>{},a("design:paramtypes",[exports.NodeId,exports.BlsPublicKey,exports.BigIntPr])],Li);let qi=Mi=class{subnetId;managerChainId;managerAddress;validators;_type=exports.TypeSymbols.ConversionData;constructor(t,e,r,s){this.subnetId=t,this.managerChainId=e,this.managerAddress=r,this.validators=s}static fromBytes(t,e){const[r,s,n,o,a]=Ps(t,[exports.Id,exports.Id,exports.Bytes,exports.Bytes],e),i=new exports.Address(n.bytes),[u]=Os(o.bytes,Li,e);return[new Mi(r,s,i,u),a]}toBytes(t){const e=new exports.Bytes(this.managerAddress.toBytes()),r=new exports.Bytes(Es(this.validators,t));return ks([this.subnetId,this.managerChainId,e,r],t)}};qi=Mi=o([t=>{},a("design:paramtypes",[exports.Id,exports.Id,exports.Address,Array])],qi);var Fi=Object.freeze({__proto__:null,get AddressedCall(){return Ei},get ConversionData(){return qi},get L1ValidatorRegistrationMessage(){return Ni},get L1ValidatorWeightMessage(){return Di},get RegisterL1ValidatorMessage(){return ki},get SubnetToL1ConversionMessage(){return Vi},get ValidatorData(){return Li}}),Xi=Object.freeze({__proto__:null,AddressedCallPayloads:Fi,get WarpMessage(){return vi},get WarpSignature(){return yi},get WarpUnsignedMessage(){return Oi},codec:wi,getWarpManager:Bi});function ji(t){return t._type===exports.TypeSymbols.PvmBaseTx}function Hi(t){return t._type===exports.TypeSymbols.AddDelegatorTx}function Ki(t){return t._type===exports.TypeSymbols.AddPermissionlessDelegatorTx}function Wi(t){return t._type===exports.TypeSymbols.AddPermissionlessValidatorTx}function Gi(t){return t._type===exports.TypeSymbols.AddSubnetValidatorTx}function Zi(t){return t._type===exports.TypeSymbols.AddValidatorTx}function $i(t){return t._type===exports.TypeSymbols.CreateChainTx}function zi(t){return t._type===exports.TypeSymbols.CreateSubnetTx}function Yi(t){return t._type===exports.TypeSymbols.RemoveSubnetValidatorTx}function Ji(t){return t._type===exports.TypeSymbols.TransferSubnetOwnershipTx}function Qi(t){return t._type===exports.TypeSymbols.PvmExportTx}function tu(t){return t._type===exports.TypeSymbols.PvmImportTx}function eu(t){return t._type===exports.TypeSymbols.ConvertSubnetToL1Tx}function ru(t){return t._type===exports.TypeSymbols.RegisterL1ValidatorTx}function su(t){return t._type===exports.TypeSymbols.SetL1ValidatorWeightTx}function nu(t){return t._type===exports.TypeSymbols.IncreaseL1ValidatorBalanceTx}function ou(t){return t._type===exports.TypeSymbols.DisableL1ValidatorTx}var au=Object.freeze({__proto__:null,AbstractSubnetTx:Qn,get AddDelegatorTx(){return Jn},get AddPermissionlessDelegatorTx(){return vo},get AddPermissionlessValidatorTx(){return Oo},get AddSubnetValidatorTx(){return so},get AddValidatorTx(){return oo},get AdvanceTimeTx(){return io},get BaseTx(){return qa},get ConvertSubnetToL1Tx(){return Ha},get CreateChainTx(){return co},get CreateSubnetTx(){return fo},get DisableL1ValidatorTx(){return Za},get ExportTx(){return ho},get ImportTx(){return xo},get IncreaseL1ValidatorBalanceTx(){return Wa},get ProofOfPossession(){return Ea},get RegisterL1ValidatorTx(){return Ja},get RemoveSubnetValidatorTx(){return Na},get SetL1ValidatorWeightTx(){return za},get Signer(){return Ra},get SignerEmpty(){return Da},get StakeableLockIn(){return wo},get StakeableLockOut(){return Bo},get SubnetValidator(){return eo},get TransferSubnetOwnershipTx(){return Va},get TransformSubnetTx(){return La},get Validator(){return zn},isAddDelegatorTx:Hi,isAddPermissionlessDelegatorTx:Ki,isAddPermissionlessValidatorTx:Wi,isAddSubnetValidatorTx:Gi,isAddValidatorTx:Zi,isAdvanceTimeTx:function(t){return t._type===exports.TypeSymbols.AdvanceTimeTx},isConvertSubnetToL1Tx:eu,isCreateChainTx:$i,isCreateSubnetTx:zi,isDisableL1ValidatorTx:ou,isEmptySigner:function(t){return t._type===exports.TypeSymbols.SignerEmpty},isExportTx:Qi,isImportTx:tu,isIncreaseL1ValidatorBalanceTx:nu,isPvmBaseTx:ji,isRegisterL1ValidatorTx:ru,isRemoveSubnetValidatorTx:Yi,isRewardValidatorTx:function(t){return t._type===exports.TypeSymbols.RewardValidatorTx},isSetL1ValidatorWeightTx:su,isSigner:function(t){return t._type===exports.TypeSymbols.Signer},isTransferSubnetOwnershipTx:Ji,isTransformSubnetTx:function(t){return t._type===exports.TypeSymbols.TransformSubnetTx},warp:Xi});function iu(t){return uu(t.toBytes().length)+1000n*BigInt(t.getSigIndices().flatMap((t=>t)).length)+10000n}function uu(t){return 1n*BigInt(t)}class cu{utxos;constructor(t){this.utxos=t,this.utxos=function(t){const e=t.map((t=>t.ID()));return t.filter(((t,r)=>e.indexOf(t.ID())==r))}(t)}getUTXOs(){return[...this.utxos]}getAssetDict(){const t={};this.utxos.forEach((e=>{const r=e.assetId.toString(),s=t[r]||[];t[r]=[...s,e]}));const e={};for(const r in t)e[r]=new cu(t[r]);return e}getAssetIDs(){const t=this.utxos.map((t=>t.assetId.toString()));return t.filter(((e,r)=>t.indexOf(e)===r))}push(t){return new cu([...this.getUTXOs(),t])}getUTXOIDs(){return this.utxos.map((t=>t.ID()))}merge(t){const e=[...this.getUTXOs(),...t.getUTXOs()];return new cu(e)}getTransferOuts(){const t=this.utxos.filter((t=>Ms(t.output)));return new cu(t)}}function du(t){return e.concatBytes(t,r.sha256(t).subarray(-4))}const pu=(t,e,r,s)=>{if(t.locktime.value()>r)return;const n=new Set(e.map((t=>t.toString()))),o=t.addrs.reduce(((e,r,o)=>e.size()<t.threshold.value()&&n.has(r.value())?s?.length&&!s.includes(o)?e:e.set(r,o):e),new fu);return o.size()<t.threshold.value()?void 0:{sigIndicies:Array.from(o.values()),addressMap:o}};class fu{constructor(t=[]){t.forEach((([t,e])=>{this.set(t,e)}))}storage=new Map;set(t,e){return this.storage.set(t.toHex(),e),this}toJSON(){return Array.from(this.storage.entries())}static fromJSON(t){return new fu(t.map((([t,e])=>[exports.Address.fromHex(t),e])))}get(t){return this.storage.get(t.toHex())}has(t){return this.storage.has(t.toHex())}size(){return this.storage.size}forEach(t){return this.storage.forEach(((e,r)=>t(e,exports.Address.fromHex(r))))}forEachHex(t,e=!1){return e?fu.fromJSON([...this.storage.entries()].sort(((t,e)=>t[1]-e[1])).map((([t],e)=>[t,e]))).storage.forEach(t):this.storage.forEach(t)}values(){return this.storage.values()}}class lu{constructor(t=[]){t.length&&this.push(...t)}storage=[];index={};orderedIndex={};push(...t){t.forEach((t=>{t.forEachHex(((t,e)=>{this.index[e]=this.index[e]??[],this.index[e].push([this.storage.length,t])})),t.forEachHex(((t,e)=>{this.orderedIndex[e]=this.orderedIndex[e]??[],this.orderedIndex[e].push([this.storage.length,t])}),!0),this.storage.push(t)}))}static fromTransferableInputs(t,e,r,s){const n=e.reduce(((t,e)=>t.set(e.utxoId.ID(),e)),new Map),o=t.map(((t,e)=>{const o=n.get(t.utxoID.ID());if(!o)throw new Error("input utxo not found");if(s){const n=Js(s),a=pu(o.getOutputOwners(),n,r,t.sigIndicies());if(!a)throw new Error(`input ${e} has no valid owners`);return a.addressMap}const a=t.sigIndicies().map((t=>[o.getOutputOwners().addrs[t],t]));return new fu(a)}));return new lu(o)}toJSON(){return this.storage}static fromJSON(t){return new lu(t.map((t=>fu.fromJSON(t))))}getAddresses(){return Object.keys(this.index).map((t=>Te(t)))}forEach(t,e=!1){Object.entries(e?this.orderedIndex:this.index).forEach((([e,r])=>{t(r,e)}))}has(t){return t.toHex()in this.index}toArray(){return this.storage}merge(t){t.toArray().forEach((t=>this.push(t)))}getSigIndicesForAddress(t,e=!1){return e?this.orderedIndex[t.toHex()]:this.index[t.toHex()]}}const hu=t=>xi(t)?li(t)?[]:t.importedInputs:[],mu=t=>mi(t)?hu(t):pi(t)||tu(t)?[...t.baseTx.inputs??[],...t.ins??[]]:t.getInputs(),xu=t=>xi(t)&&li(t)?t.exportedOutputs:[],gu=t=>{if(mi(t))return xu(t);if(di(t)||Qi(t))return[...t.baseTx?.outputs??[],...t.outs??[]];if(Zi(t)||Hi(t)||Wi(t)||Ki(t)){const e=[...t.baseTx?.outputs??[],...t.stake??[]];return Zi(t)?e.push(t.getRewardsOwner(),t.getRewardsOwner()):Hi(t)?e.push(t.getRewardsOwner()):Wi(t)?e.push(t.getValidatorRewardsOwner(),t.getDelegatorRewardsOwner()):e.push(t.getDelegatorRewardsOwner()),e}return zi(t)?[...t.baseTx.outputs,t.getSubnetOwners()]:t?.baseTx?.outputs??[]},bu=t=>{const{output:e}=t,r=t.getOutputOwners();return{amount:Ms(e)||qs(e)?e.amount():0n,assetId:t.getAssetId(),locktime:r.locktime.value(),stakeableLocktime:qs(e)?e.getStakeableLocktime():0n,threshold:r.threshold.value(),utxoId:t.ID()}},yu=(t,e)=>{const r=t.get(e.assetId.toString())??0n,s=ii(e)||ai(e)?e.amount():e.amount.value();return t.set(e.assetId.toString(),r+s),t},wu=t=>{if(li(t))return t.ins.reduce(yu,new Map);return mu(t).reduce(yu,new Map)},Iu=t=>{if(hi(t))return t.Outs.reduce(yu,new Map);return gu(t).reduce(((t,e)=>ai(e)?yu(t,e):t),new Map)},Bu=(t,e)=>{const r=wu(t),s=Iu(t),n=new Map,o=(t=>eu(t)?t.validators.reduce(((t,e)=>t+e.balance.value()),0n):ru(t)||nu(t)?t.balance.value():0n)(t);for(const[t,e]of r.entries()){const r=s.get(t)??0n;n.set(t,e-r)}if(o){const t=n.get(e.avaxAssetID);t&&n.set(e.avaxAssetID,t-o)}return n},Tu=(t,e)=>({isValid:t===e,txFee:e});var Ou;!function(t){t[t.Bandwidth=0]="Bandwidth",t[t.DBRead=1]="DBRead",t[t.DBWrite=2]="DBWrite",t[t.Compute=3]="Compute"}(Ou||(Ou={}));const Su=()=>({[Ou.Bandwidth]:0,[Ou.DBRead]:0,[Ou.DBWrite]:0,[Ou.Compute]:0}),vu=({bandwidth:t,dbRead:e,dbWrite:r,compute:s})=>({[Ou.Bandwidth]:t,[Ou.DBRead]:e,[Ou.DBWrite]:r,[Ou.Compute]:s}),Au=(...t)=>{const e=Su();for(const r of t)e[Ou.Bandwidth]+=r[Ou.Bandwidth],e[Ou.DBRead]+=r[Ou.DBRead],e[Ou.DBWrite]+=r[Ou.DBWrite],e[Ou.Compute]+=r[Ou.Compute];return e},Eu=(t,e)=>BigInt(t[Ou.Bandwidth]*e[Ou.Bandwidth]+t[Ou.DBRead]*e[Ou.DBRead]+t[Ou.DBWrite]*e[Ou.DBWrite]+t[Ou.Compute]*e[Ou.Compute]),Pu={[Ou.Bandwidth]:58,[Ou.DBRead]:0,[Ou.DBWrite]:0,[Ou.Compute]:0},ku={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+2+zr+4+4+4+4,[Ou.DBRead]:3,[Ou.DBWrite]:1,[Ou.Compute]:0},Ru={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+4,[Ou.DBRead]:0,[Ou.DBWrite]:1,[Ou.Compute]:0},Du={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+44+zr+4+4+4+4+4,[Ou.DBRead]:1,[Ou.DBWrite]:3,[Ou.Compute]:0},Cu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+44+zr+4+4,[Ou.DBRead]:1,[Ou.DBWrite]:2,[Ou.Compute]:0},Nu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+76+4+4,[Ou.DBRead]:3,[Ou.DBWrite]:3,[Ou.Compute]:0},_u={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+4,[Ou.DBRead]:0,[Ou.DBWrite]:0,[Ou.Compute]:0},Vu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+4,[Ou.DBRead]:0,[Ou.DBWrite]:0,[Ou.Compute]:0},Uu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+Qr+zr+4+4,[Ou.DBRead]:1,[Ou.DBWrite]:3,[Ou.Compute]:0},Lu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+4+4+4,[Ou.DBRead]:1,[Ou.DBWrite]:1,[Ou.Compute]:0},Mu={[Ou.Bandwidth]:36,[Ou.DBRead]:0,[Ou.DBWrite]:4,[Ou.Compute]:0},qu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+zr+4+4+4+4,[Ou.DBRead]:3,[Ou.DBWrite]:2,[Ou.Compute]:0},Fu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+8+Vr+4,[Ou.DBRead]:5,[Ou.DBWrite]:6,[Ou.Compute]:1050},Xu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+4,[Ou.DBRead]:3,[Ou.DBWrite]:5,[Ou.Compute]:0},ju={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+8,[Ou.DBRead]:1,[Ou.DBWrite]:5,[Ou.Compute]:0},Hu={[Ou.Bandwidth]:Pu[Ou.Bandwidth]+zr+4+4,[Ou.DBRead]:1,[Ou.DBWrite]:6,[Ou.Compute]:0},Ku=Bi(),Wu=t=>{let e=Su();for(const r of t){const t={[Ou.Bandwidth]:60,[Ou.DBRead]:0,[Ou.DBWrite]:1,[Ou.Compute]:0};let s=0;qs(r.output)?(t[Ou.Bandwidth]+=12,s=r.output.getOutputOwners().addrs.length):Ms(r.output)&&(s=r.output.outputOwners.addrs.length);const n=s*Qr;t[Ou.Bandwidth]+=n,e=Au(e,t)}return e},Gu=t=>{let e=Su();for(const r of t){const t={[Ou.Bandwidth]:92,[Ou.DBRead]:1,[Ou.DBWrite]:1,[Ou.Compute]:0};Xs(r.input)&&(t[Ou.Bandwidth]+=12);const s=r.sigIndicies().length,n=69*s;t[Ou.Bandwidth]+=n,t[Ou.Compute]+=200*s,e=Au(e,t)}return e},Zu=t=>t instanceof Da?Su():vu({bandwidth:144,dbRead:0,dbWrite:0,compute:1050}),$u=t=>{const e=t.addrs.length;return vu({bandwidth:e*Qr+16,dbRead:0,dbWrite:0,compute:0})},zu=t=>{if(!(t instanceof exports.Input))throw new Error("Unable to calculate auth complexity of transaction. Expected Input as subnet auth.");const e=t.values().length;return vu({bandwidth:69*e+8,dbRead:0,dbWrite:0,compute:200*e})},Yu=(...t)=>{const e=Su();return t.forEach((t=>{e[Ou.Bandwidth]+=t.length})),e},Ju=t=>{const e=5*Ku.unpack(t.bytes,vi).signature.numOfSigners()+1e3;return vu({bandwidth:t.length,dbRead:23,dbWrite:0,compute:e})},Qu=t=>{let e=Su();for(const r of t)e=Au(e,tc(r));return e},tc=t=>{const e=Yu(t.nodeId),r=Zu(t.signer),s=vu({bandwidth:(t.getRemainingBalanceOwner().getAddresses().length+t.getDeactivationOwner().getAddresses().length)*Qr,dbRead:0,dbWrite:0,compute:0});return Au(Mu,e,r,s)},ec=t=>{const e=Wu(t.outputs),r=Gu(t.inputs),s=Au(e,r);return s[Ou.Bandwidth]+=t.memo.length,s},rc=t=>{if(Wi(t))return(t=>Au(Du,ec(t.baseTx),Zu(t.signer),Wu(t.stake),$u(t.getValidatorRewardsOwner()),$u(t.getDelegatorRewardsOwner())))(t);if(Ki(t))return(t=>Au(Cu,ec(t.baseTx),$u(t.getDelegatorRewardsOwner()),Wu(t.stake)))(t);if(Gi(t))return(t=>Au(Nu,ec(t.baseTx),zu(t.subnetAuth)))(t);if($i(t))return(t=>{let e=t.fxIds.length*zr;e+=t.chainName.value().length,e+=t.genesisData.length;const r=vu({bandwidth:e,dbRead:0,dbWrite:0,compute:0});return Au(ku,r,ec(t.baseTx),zu(t.subnetAuth))})(t);if(zi(t))return(t=>Au(Ru,ec(t.baseTx),$u(t.getSubnetOwners())))(t);if(Qi(t))return(t=>Au(_u,ec(t.baseTx),Wu(t.outs)))(t);if(tu(t))return(t=>Au(Vu,ec(t.baseTx),Gu(t.ins)))(t);if(Yi(t))return(t=>Au(Uu,ec(t.baseTx),zu(t.subnetAuth)))(t);if(Ji(t))return(t=>Au(Lu,ec(t.baseTx),zu(t.subnetAuth),$u(t.getSubnetOwners())))(t);if(ji(t))return(t=>Au(Pu,ec(t.baseTx)))(t);if(eu(t))return(t=>Au(qu,Yu(t.address),ec(t.baseTx),zu(t.subnetAuth),Qu(t.validators)))(t);if(ru(t))return(t=>Au(Fu,ec(t.baseTx),Ju(t.message)))(t);if(su(t))return(t=>Au(Xu,ec(t.baseTx),Ju(t.message)))(t);if(nu(t))return(t=>Au(ju,ec(t.baseTx)))(t);if(ou(t))return(t=>Au(Hu,ec(t.baseTx),zu(t.getDisableAuth())))(t);throw new Error("Unsupported transaction type.")},sc=(t,e,r)=>{const s=rc(t);return Eu(s,e)*r};var nc,oc=Object.freeze({__proto__:null,AddressMap:fu,AddressMaps:lu,CCostPerSignature:1000n,CFixedFee:1e4,CTxBytesGas:1n,UtxoSet:cu,add0x:me,addChecksum:du,addressesFromBytes:Js,base58:t.base58,base58check:Gr,bech32ToBytes:c,bufferToBigInt:ye,bufferToBool:Ie,bufferToHex:Be,bufferToNumber:we,bytesCompare:Zr,bytesEqual:(t,e)=>t.length===e.length&&0===Zr(t,e),calcBytesCost:uu,concatBytes:e.concatBytes,costCorethTx:iu,format:function(t,e,r){return`${t}-${p(e,r)}`},formatBech32:p,getBurnedAmountByTx:Bu,getInputAmounts:wu,getManagerForVM:ri,getOutputAmounts:Iu,getTransferableInputsByEvmTx:hu,getTransferableInputsByTx:mu,getTransferableOutputsByEvmTx:xu,getTransferableOutputsByTx:gu,getUtxoInfo:bu,hammingWeight:Se,hexToBuffer:Te,isEtnaEnabled:t=>{const{etnaTime:e}=t;return new Date(e)<new Date},isRewardsOwner:Fs,isStakeableLockIn:Xs,isStakeableLockOut:qs,isTransferInput:js,isTransferOut:Ms,matchOwners:pu,packTx:si,padLeft:Oe,parse:u,parseBech32:d,printDeep:t=>{console.log(n.inspect(t,{depth:null,colors:!0}))},printHex:(t,e="")=>{console.log(`name = ${e}`,Be(t))},printJSON:t=>{console.log(JSON.stringify(t,null,2))},strip0x:xe,unpackWithManager:function(t,e){return ri(t).unpackTransaction(e)},validateBurnedAmount:({unsignedTx:t,context:e,burnedAmount:r,baseFee:s,feeTolerance:n})=>{const o=t.getTx(),a=r??((t,e)=>Bu(t,e).get(e.avaxAssetID)??0n)(o,e);if(xi(o)||(t=>ji(t)||Qi(t)||tu(t)||Wi(t)||Ki(t)||Gi(t)||$i(t)||zi(t)||Yi(t)||Ji(t)||eu(t)||ru(t)||su(t)||nu(t)||ou(t))(o)){return(({burnedAmount:t,feeAmount:e,feeTolerance:r})=>{const s=Math.floor(r);if(s<0)throw new Error("feeTolerance must be be non-negative.");const n=e*BigInt(s)/100n;return{isValid:t>=(n>e?0n:e-n)&&t<=e+n,txFee:t}})({burnedAmount:a,feeAmount:xi(o)?s*iu(t):sc(o,e.platformFeeConfig.weights,s),feeTolerance:n})}return(({unsignedTx:t,context:e,burnedAmount:r})=>{const s=t.getTx();if(ci(s)||di(s)||pi(s))return Tu(r,e.baseTxFee);throw new Error("tx type is not supported")})({unsignedTx:t,context:e,burnedAmount:a})}});exports.Utxo=nc=class{utxoId;assetId;output;_type=exports.TypeSymbols.UTXO;constructor(t,e,r){this.utxoId=t,this.assetId=e,this.output=r}static fromBytes(t,e){const[r,s,n,o]=Ps(t,[en,exports.Id,dn],e);return[new nc(r,s,n),o]}getOutputOwners(){if(Ms(this.output))return this.output.outputOwners;if(qs(this.output))return this.output.getOutputOwners();if(Fs(this.output))return this.output;throw new Error("unable to get output owner")}toBytes(t){return e.concatBytes(ks([this.utxoId,this.assetId],t),t.PackPrefix(this.output))}getAssetId(){return this.assetId.toString()}ID(){return this.utxoId.ID()}},exports.Utxo=nc=o([t=>{},a("design:paramtypes",[en,exports.Id,Object])],exports.Utxo);const ac="https://api.avax.network";class ic{url;reqId=0;constructor(t){this.url=t}async callMethod(t,e,r){const s={jsonrpc:"2.0",id:this.reqId++,method:t,params:e},n=await fetch(this.url,{...r,method:"POST",body:JSON.stringify(s),headers:{"Content-Type":"application/json",...r?.headers}}).then((async t=>t.json())).then((t=>t));if(n.error)throw new Error(n.error.message);return n.result}}class uc{path;base;fetchOptions;rpcProvider;constructor(t=ac,e,r,s){this.path=e,this.base=r,this.fetchOptions=s,this.rpcProvider=new ic(t+e)}setFetchOptions(t){this.fetchOptions=t}getMethodName=t=>this.base?`${this.base}.${t}`:t;callRpc=(t,e)=>this.rpcProvider.callMethod(this.getMethodName(t),e,this.fetchOptions)}class cc extends uc{path;base;manager;constructor(t=ac,e,r,s){super(t,e,r),this.path=e,this.base=r,this.manager=s}async getUTXOs(t){const e=await this.callRpc("getUTXOs",{...t,encoding:"hex"}),r=e.utxos.map((t=>this.manager.unpack(Te(t),exports.Utxo)));return{...e,utxos:r}}issueTx(t){return this.callRpc("issueTx",t)}issueSignedTx(t){return this.issueTx({tx:Be(du(t.toBytes()))})}}class dc extends cc{getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getTx=async t=>{const e=await this.callRpc("getTx",{...t,encoding:"hex"});return this.manager.unpack(Te(e.tx),oi)};getTxJson=t=>this.callRpc("getTx",{...t,encoding:"json"});getTxStatus(t){return this.callRpc("getTxStatus",{includeReason:!0,...t})}getBalance(t){return this.callRpc("getBalance",t)}getAddressTxs(t){return this.callRpc("GetAddressTxs",t)}}class pc extends dc{constructor(t){super(t,"/ext/bc/X","avm",_n())}buildGenesis=async t=>await this.callRpc("buildGenesis",t);getAllBalances(t){return this.callRpc("getAllBalances",t)}getTxFee=async()=>{const t=await this.callRpc("getTxFee");return{txFee:BigInt(t.txFee),createAssetTxFee:BigInt(t.createAssetTxFee)}}}const fc=(t,e)=>{const r=exports.Id.compare(t.assetId,e.assetId);if(0!==r)return r;const s=[qs],n=_n().getDefaultCodec(),o=ei().getDefaultCodec(),a=s.some((e=>e(t.output)))?o:n,i=s.some((t=>t(e.output)))?o:n;return Zr(t.toBytes(a),e.toBytes(i))},lc=(t,e)=>t.address.value()===e.address.value()?Zr(t.assetId.toBytes(),e.assetId.toBytes()):t.address.value().localeCompare(e.address.value()),hc=t=>t.reduce(((t,e)=>(t[e.getAssetId()]=t[e.getAssetId()]??0n,t[e.getAssetId()]+=e.amount(),t)),{}),mc=(t,e)=>({minIssuanceTime:BigInt(Math.floor((new Date).getTime()/1e3)),changeAddresses:t,threshold:1,memo:new Uint8Array,locktime:0n,...Object.fromEntries(Object.entries(e||{}).filter((([,t])=>void 0!==t)))});new exports.OutputOwners(new exports.BigIntPr(0n),new exports.Int(0),[]),new exports.Id(new Uint8Array(32));const xc=new exports.Signature(new Uint8Array(Array(65).fill(0)));class gc{tx;utxos;addressMaps;credentials;constructor(t,e,r,s){this.tx=t,this.utxos=e,this.addressMaps=r,this.credentials=s||this.tx.getSigIndices().map((t=>new exports.Credential(t.map((()=>xc)))))}toJSON(){const t=ri(this.tx.vm).getDefaultCodec();return{codecId:ri(this.tx.vm).getDefaultCodecId(),vm:this.tx.vm,txBytes:Be(this.toBytes()),utxos:this.utxos.map((e=>Be(e.toBytes(t)))),addressMaps:this.addressMaps,credentials:this.credentials}}static fromJSON(t){const e=JSON.parse(t),r=["txBytes","utxos","addressMaps","vm","codecId","credentials"];r.forEach((t=>{if(!e[t])throw new Error(`invalid structure. must have ${r.join(", ")}, missing ${t}`)}));const s=e.vm;if(!ke.includes(s))throw new Error("invalid VM");const n=ri(s),[o,a]=n.getCodecFromBuffer(Te(e.txBytes)),i=o.UnpackPrefix(a)[0],u=e.utxos.map((t=>exports.Utxo.fromBytes(Te(t),o)[0])),c=lu.fromJSON(e.addressMaps),d=e.credentials.map((t=>exports.Credential.fromJSON(t)));return new gc(i,u,c,d)}getSigIndices(){return this.tx.getSigIndices()}hasAddress(t){return this.addressMaps.has(t)}hasPubkey(t){return this.hasAddress(new exports.Address(this.publicKeyBytesToAddress(t)))}getAddresses(){return this.addressMaps.getAddresses()}getSigIndicesForAddress(t){const e=this.getSigIndices().some(((t,e)=>{const r=this.credentials[e].toJSON().length;return Math.max(...t)>r-1}));return this.addressMaps.getSigIndicesForAddress(t,e)}getSigIndicesForPubKey(t){const e=this.publicKeyBytesToAddress(t),r=Sa(t),s=this.getSigIndicesForAddress(new exports.Address(e)),n=this.getSigIndicesForAddress(new exports.Address(r));return s||n}getInputUtxos(){return this.utxos}toBytes(){return si(this.tx)}getBlockchainId(){return this.tx.getBlockchainId()}getTx(){return this.tx}getSignedTx(){return new oi(this.tx,this.credentials)}getCredentials(){return this.credentials}addSignatureAt(t,e,r){if(e>=this.getCredentials().length)throw new Error("index out of bounds");this.getCredentials()[e].setSignature(r,t)}addSignature(t){const e=Ba(r.sha256(this.toBytes()),t);this.addSignatureForPubKey(t,e)}addSignatureForPubKey(t,e){const r=this.getSigIndicesForPubKey(e);r&&r.forEach((([e,r])=>{this.addSignatureAt(t,e,r)}))}publicKeyBytesToAddress(t){return Oa(t)}hasAllSignatures(){const t=this.credentials.map((t=>t.getSignatures())),e=xc.toString(),s=r.sha256(this.toBytes());if(!t.every((t=>t.every((t=>t!==e)))))return!1;let n=!0;return this.addressMaps.forEach((e=>{e.forEach((([e,r])=>{const o=t[e]?.[r];if(!o)throw new Error("error: incorrect structure for credentials");const a=Te(o),i=Ba(s,a);this.hasPubkey(i)||(n=!1)}))}),!0),n}getVM(){return this.tx.getVM()}}function bc(t=new Map,e=new Map,r,s,n,o){const a={amountsToBurn:t,utxos:r,amountsToStake:e,fromAddresses:s,options:n,inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new lu},i=[...o,function({amountsToBurn:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Burn Amount): need ${t} more units of ${e} to burn`)})),{amountsToBurn:t,...e}},function({amountsToStake:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Stake Amount): need ${t} more units of ${e} to stake`)})),{amountsToStake:t,...e}},function({inputs:t,...e}){return t.sort(exports.TransferableInput.compare),{inputs:t,...e}},function({changeOutputs:t,...e}){return t.sort(fc),{changeOutputs:t,...e}},function({stakeOutputs:t,...e}){return t.sort(fc),{stakeOutputs:t,...e}},function({inputs:t,inputUTXOs:e,...r}){return{inputs:t,inputUTXOs:e,...r,addressMaps:lu.fromTransferableInputs(t,e,n.minIssuanceTime,s.map((t=>t.toBytes())))}}].reduce(((t,e)=>e(function(t){return{...t,amountsToBurn:new Map([...t.amountsToBurn]),amountsToStake:new Map([...t.amountsToStake]),inputs:[...t.inputs],inputUTXOs:[...t.inputUTXOs],stakeOutputs:[...t.stakeOutputs],changeOutputs:[...t.changeOutputs]}}(t))),a);return{inputs:i.inputs,inputUTXOs:i.inputUTXOs,stakeOutputs:i.stakeOutputs,changeOutputs:i.changeOutputs,addressMaps:i.addressMaps}}const yc=(...t)=>t.reduce(((t,e)=>e<t?e:t)),wc=new Error("No addresses match UTXO owners");function Ic(t,e,r,s){const n=t.reduce(((t,n)=>{const o=e(n),a=pu(o.outputOwners,[...r],s);return a?[...t,{sigData:a,data:n}]:t}),[]);if(t.length&&!n.length)throw wc;return n}const Bc=({amountsToBurn:t,utxos:e,options:r,changeOutputs:s,inputUTXOs:n,fromAddresses:o,inputs:a,...i})=>{const u=new exports.OutputOwners(new exports.BigIntPr(0n),new exports.Int(r.threshold),Js(r.changeAddresses));return Ic(e.filter((e=>!!t.get(e.assetId.toString()))).filter((t=>!!Ms(t.output))),(t=>t.output),o,r.minIssuanceTime).forEach((({sigData:e,data:r})=>{const o=r.output,i=t.get(r.assetId.toString())??0n,c=yc(i,o.amt.value());if(!c)return;t.set(r.assetId.toString(),i-c),a.push(exports.TransferableInput.fromUtxoAndSigindicies(r,e.sigIndicies)),n.push(r);const d=o.amt.value()-c;d>0&&s.push(new exports.TransferableOutput(r.assetId,new exports.TransferOutput(new exports.BigIntPr(d),u)))})),{utxos:e,fromAddresses:o,options:r,...i,amountsToBurn:t,inputs:a,changeOutputs:s,inputUTXOs:n}},Tc=(t,e,r,s)=>on.fromNative(t.networkID,t.xBlockchainID,e,r,s),Oc=(t,e,r,s)=>on.fromNative(t.networkID,t.pBlockchainID,e,r,s);var Sc=Object.freeze({__proto__:null,AvaxApi:dc,get FeeDimensions(){return Ou},Transaction:Is,UnsignedTx:gc,addDimensions:Au,baseTxUnsafeAvm:Tc,baseTxUnsafePvm:Oc,createDimensions:vu,createEmptyDimensions:Su,dimensionsToGas:Eu});const vc=(t,e,r,s,n,o,a,i)=>{e.sort(fc);const u=hc([...e,...r]),c=hc(s);if(!Object.entries(u).every((([t,e])=>c[t]&&c[t]>=e)))throw new Error("Not enough inputs to cover the outputs");return new gc(new An(Tc(t,r,s,o),exports.Id.fromString(n),e),a,i)};var Ac=Object.freeze({__proto__:null,AVMApi:pc,newBaseTx:function(t,e,r,s,n){const o=Js(e),a=mc(e,n),i=new Map([[t.avaxAssetID,t.baseTxFee]]);s.forEach((t=>{const e=t.assetId.value();i.set(e,(i.get(e)||0n)+t.output.amount())}));const{inputs:u,inputUTXOs:c,changeOutputs:d,addressMaps:p}=bc(i,void 0,r,o,a,[Bc]),f=[...s,...d];return f.sort(fc),new gc(new cn(Tc(t,f,u,a.memo)),c,p)},newExportTx:function(t,e,r,s,n,o){const a=Js(r),i=mc(r,o),u=new Map([[t.avaxAssetID,t.baseTxFee]]);n.forEach((t=>{const e=t.assetId.value();u.set(e,(u.get(e)||0n)+t.output.amount())}));const{inputs:c,changeOutputs:d,inputUTXOs:p,addressMaps:f}=bc(u,void 0,s,a,i,[Bc]);return n.sort(fc),vc(t,n,d,c,e,i.memo,p,f)},newImportTx:function(t,e,r,s,n,o,a=1,i=0n){const u=Js(n),c=mc(n,o),{importedAmounts:d,importedInputs:p,inputUTXOs:f}=((t,e,r)=>{const s=Js(e);return t.reduce(((t,e)=>{const{importedInputs:n,inputUTXOs:o,importedAmounts:a}=t,i=e.output;if(!Ms(i))return t;const u=pu(i.outputOwners,s,r);return u?(n.push(exports.TransferableInput.fromUtxoAndSigindicies(e,u.sigIndicies)),o.push(e),a[e.getAssetId()]=(a[e.getAssetId()]??0n)+i.amount(),t):t}),{importedInputs:[],inputUTXOs:[],importedAmounts:{}})})(r,n,c.minIssuanceTime);if(!p.length)throw new Error("no UTXOs available to import");p.sort(exports.TransferableInput.compare);const l=lu.fromTransferableInputs(p,r,c.minIssuanceTime,n),h=d[t.avaxAssetID]??0n;let m={inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new lu};const x=t.baseTxFee,g=t.avaxAssetID;if(h>x)d[g]-=x;else{if(h<x){const t=new Map([[g,x-h]]);m=bc(t,void 0,r,u,c,[Bc])}delete d[g]}return f.push(...m.inputUTXOs||[]),l.merge(m.addressMaps||new lu),Object.entries(d).forEach((([t,e])=>{m.changeOutputs.push(exports.TransferableOutput.fromNative(t,e,s,i,a))})),new gc(new Pn(on.fromNative(t.networkID,t.xBlockchainID,m.changeOutputs||[],m.inputs||[],c.memo),exports.Id.fromString(e),p),f,l)}});class Ec extends gc{hasPubkey(t){const e=new exports.Address(this.publicKeyBytesToAddress(t)),r=new exports.Address(Sa(t));return this.hasAddress(e)||this.hasAddress(r)}static fromJSON(t){const e=gc.fromJSON(t);return new Ec(e.tx,e.utxos,e.addressMaps,e.credentials)}}class Pc extends uc{baseURL;constructor(t=ac){super(t,"/ext/info","info"),this.baseURL=t}getNodeVersion(){return this.callRpc("getNodeVersion")}async getNodeId(){return this.callRpc("getNodeID")}getNodeIp(){return this.callRpc("getNodeIP")}getNetworkId(){return this.callRpc("getNetworkID")}getNetworkName(){return this.callRpc("getNetworkName")}getBlockchainId(t){return this.callRpc("getBlockchainID",{alias:t})}peers(t){return this.callRpc("peers",{nodeIDs:t})}isBootstrapped(t){return this.callRpc("peers",{chain:t})}uptime(){return this.callRpc("uptime")}getVMs(){return this.callRpc("getVMs")}getUpgradesInfo(){return this.callRpc("upgrades")}}var kc=Object.freeze({__proto__:null,InfoApi:Pc});const Rc=(t,e,r)=>{const s=e.calculateFee(),n=e.hasChangeOutput(r.avaxAssetID,t.changeOutputOwners);if(((t,e,r)=>{if(t<e)throw new Error(`Insufficient funds: provided UTXOs need ${e-t} more unlocked nAVAX (asset id: ${r.avaxAssetID}) to cover fee.`);return t!==e})(t.excessAVAX,s,r))if(n)e.addChangeOutput(new exports.TransferableOutput(exports.Id.fromString(r.avaxAssetID),new exports.TransferOutput(new exports.BigIntPr(t.excessAVAX-s),t.changeOutputOwners)));else{const s=e.calculateFee(new exports.TransferableOutput(exports.Id.fromString(r.avaxAssetID),new exports.TransferOutput(new exports.BigIntPr(0n),t.changeOutputOwners)));t.excessAVAX>s&&e.addChangeOutput(new exports.TransferableOutput(exports.Id.fromString(r.avaxAssetID),new exports.TransferOutput(new exports.BigIntPr(t.excessAVAX-s),t.changeOutputOwners)))}return t},Dc=new Error("StakeableLockOut transferOut must be a TransferOutput."),Cc=(t,e)=>{const r=t.utxos.filter((t=>e=>{if(!qs(e.output))return!1;if(t.minIssuanceTime>=e.output.getLocktime())return!1;if(!Ms(e.output.transferOut))throw Dc;return!!t.toStake.has(e.assetId.value())})(t)),s=Ic(r,(t=>t.output.transferOut),t.fromAddresses,t.minIssuanceTime);for(const{sigData:r,data:n}of s){const s=bu(n);if(0n===(t.toStake.get(s.assetId)??0n))continue;e.addInput(n,new exports.TransferableInput(n.utxoId,n.assetId,new wo(new exports.BigIntPr(s.stakeableLocktime),exports.TransferInput.fromNative(s.amount,r.sigIndicies))));const[o]=e.consumeLockedStakableAsset(s.assetId,s.amount);e.addStakedOutput(new exports.TransferableOutput(n.assetId,new Bo(new exports.BigIntPr(s.stakeableLocktime),new exports.TransferOutput(new exports.BigIntPr(s.amount-o),n.getOutputOwners())))),o>0n&&e.addChangeOutput(new exports.TransferableOutput(n.assetId,new Bo(new exports.BigIntPr(s.stakeableLocktime),new exports.TransferOutput(new exports.BigIntPr(o),n.getOutputOwners()))))}return t},Nc=(t,e,r)=>{const s=Ic(t.utxos.filter((t=>e=>{if(!qs(e.output)&&!Ms(e.output))return!1;if(qs(e.output)&&!Ms(e.output.transferOut))throw Dc;return e.output.getLocktime()<t.minIssuanceTime})(t)),(t=>Ms(t.output)?t.output:t.output.transferOut),t.fromAddresses,t.minIssuanceTime),{otherVerifiedUsableUTXOs:n,avaxVerifiedUsableUTXOs:o}=s.reduce(((t,e)=>e.data.assetId.value()===r.avaxAssetID?{...t,avaxVerifiedUsableUTXOs:[...t.avaxVerifiedUsableUTXOs,e]}:{...t,otherVerifiedUsableUTXOs:[...t.otherVerifiedUsableUTXOs,e]}),{otherVerifiedUsableUTXOs:[],avaxVerifiedUsableUTXOs:[]});for(const{sigData:r,data:s}of n){const n=bu(s),o=t.toBurn.get(n.assetId)??0n,a=t.toStake.get(n.assetId)??0n;if(0n===o&&0n===a)continue;e.addInput(s,new exports.TransferableInput(s.utxoId,s.assetId,exports.TransferInput.fromNative(n.amount,r.sigIndicies)));const[i,u]=e.consumeAsset(n.assetId,n.amount);u>0n&&e.addStakedOutput(new exports.TransferableOutput(s.assetId,new exports.TransferOutput(new exports.BigIntPr(u),t.changeOutputOwners))),i>0n&&e.addChangeOutput(new exports.TransferableOutput(s.assetId,new exports.TransferOutput(new exports.BigIntPr(i),t.changeOutputOwners)))}let a=t.excessAVAX;for(const{sigData:s,data:n}of o){const o=e.calculateFee();if(!e.shouldConsumeAsset(r.avaxAssetID)&&a>=o)break;const i=bu(n);e.addInput(n,new exports.TransferableInput(n.utxoId,n.assetId,exports.TransferInput.fromNative(i.amount,s.sigIndicies)));const[u,c]=e.consumeAsset(r.avaxAssetID,i.amount);c>0n&&e.addStakedOutput(new exports.TransferableOutput(n.assetId,new exports.TransferOutput(new exports.BigIntPr(c),t.changeOutputOwners))),a+=u}return{...t,excessAVAX:a}},_c=(t,e)=>{const r=e.verifyAssetsConsumed();if(r)throw r;return t},Vc=(t,e)=>{const r=e.verifyGasUsage();if(r)throw r;return t},Uc=(t,e)=>t.getAssetId()===e.getAssetId()&&(qs(t.output)&&qs(e.output)&&t.output.getStakeableLocktime()===e.output.getStakeableLocktime()&&t.output.getOutputOwners().equals(e.output.getOutputOwners())||Ms(t.output)&&Ms(e.output)&&t.output.outputOwners.equals(e.output.outputOwners)),Lc=(t,e)=>{if(qs(t.output)&&qs(e.output))return new exports.TransferableOutput(t.assetId,new Bo(t.output.lockTime,new exports.TransferOutput(new exports.BigIntPr(t.amount()+e.amount()),t.output.getOutputOwners())));if(Ms(t.output)&&Ms(e.output))return new exports.TransferableOutput(t.assetId,new exports.TransferOutput(new exports.BigIntPr(t.amount()+e.amount()),t.output.outputOwners));throw new Error("Calling combine on incompatible TransferableOutputs")},Mc=t=>((t,e,r)=>{const s=[];for(const n of t){let t=!1;for(let o=0;o<s.length;o++){const a=s[o];if(e(a,n)){s[o]=r(a,n),t=!0;break}}t||s.push(n)}return s})(t,Uc,Lc);class qc{feeState;initialComplexity;shouldConsolidateOutputs;toBurn;toStake;weights;changeOutputs;inputs;stakeOutputs;inputUTXOs=[];constructor({changeOutputs:t,feeState:e,initialComplexity:r,inputs:s,shouldConsolidateOutputs:n,stakeOutputs:o,toBurn:a,toStake:i,weights:u}){this.feeState=e,this.initialComplexity=r,this.shouldConsolidateOutputs=n,this.toBurn=a,this.toStake=i,this.weights=u,this.changeOutputs=t,this.inputs=s,this.stakeOutputs=o}addInput(t,e){return this.inputs=[...this.inputs,e],this.inputUTXOs=[...this.inputUTXOs,t],this}addChangeOutput(t){return this.changeOutputs=[...this.changeOutputs,t],this}addStakedOutput(t){return this.stakeOutputs=[...this.stakeOutputs,t],this}getComplexity(t=Su()){return Au(this.initialComplexity,Gu(this.inputs),Wu(this.changeOutputs),Wu(this.stakeOutputs),t)}consolidateOutputs(){this.shouldConsolidateOutputs&&(this.changeOutputs=Mc(this.changeOutputs),this.stakeOutputs=Mc(this.stakeOutputs))}shouldConsumeLockedStakeableAsset(t){return this.toStake.has(t)&&0n!==this.toStake.get(t)}shouldConsumeAsset(t){return this.toBurn.has(t)&&0n!==this.toBurn.get(t)||this.shouldConsumeLockedStakeableAsset(t)}consumeLockedStakableAsset(t,e){if(e<0n)throw new Error("Amount to consume must be greater than or equal to 0");const r=this.toStake.get(t)??0n,s=yc(r,e);return this.toStake.set(t,r-s),[e-s,s]}consumeAsset(t,e){if(e<0n)throw new Error("Amount to consume must be greater than or equal to 0");const r=this.toBurn.get(t)??0n,s=yc(r,e);return this.toBurn.set(t,r-s),this.consumeLockedStakableAsset(t,e-s)}calculateGas(t){this.consolidateOutputs();return Eu(this.getComplexity(t?Wu([t]):void 0),this.weights)}calculateFee(t){return this.calculateGas(t)*this.feeState.price}hasChangeOutput(t,e){return this.changeOutputs.some((r=>r.assetId.value()===t&&Ms(r.output)&&r.output.outputOwners.equals(e)))}verifyAssetsConsumed(){for(const[t,e]of this.toStake)if(0n!==e)return new Error(`Insufficient funds! Provided UTXOs need ${e} more units of asset ${t} to stake`);for(const[t,e]of this.toBurn)if(0n!==e)return new Error(`Insufficient funds! Provided UTXOs need ${e} more units of asset ${t}`);return null}verifyGasUsage(){const t=this.calculateGas();return this.feeState.capacity<t?new Error(`Gas usage of transaction (${t.toString()}) exceeds capacity (${this.feeState.capacity.toString()})`):null}getInputsOutputs(){const t=this.calculateFee(),e=[...this.inputs].sort(exports.TransferableInput.compare),r=[...this.changeOutputs].sort(fc),s=[...this.stakeOutputs].sort(fc);return{changeOutputs:r,fee:t,inputs:e,inputUTXOs:this.inputUTXOs,stakeOutputs:s}}}const Fc=({changeOutputOwners:t,excessAVAX:e=0n,feeState:r,fromAddresses:s,initialComplexity:n,minIssuanceTime:o,shouldConsolidateOutputs:a=!1,toBurn:i=new Map,toStake:u=new Map,utxos:c},d,p)=>{try{const f=t||exports.OutputOwners.fromNative(s.map((t=>t.toBytes()))),l=new qc({changeOutputs:[],feeState:r,initialComplexity:n,inputs:[],shouldConsolidateOutputs:a,stakeOutputs:[],toBurn:i,toStake:u,weights:p.platformFeeConfig.weights});return[...d,_c,Rc,Vc].reduce(((t,e)=>e(t,l,p)),{changeOutputOwners:f,excessAVAX:e,initialComplexity:n,fromAddresses:s,minIssuanceTime:o,toBurn:i,toStake:u,utxos:c}),l.getInputsOutputs()}catch(t){if(t instanceof Error)throw t;throw new Error("An unexpected error occurred during spend calculation")}},Xc=({fromAddressesBytes:t,changeAddressesBytes:e})=>exports.OutputOwners.fromNative(e??t,0n,1),jc=({inputs:t,inputUTXOs:e,minIssuanceTime:r,fromAddressesBytes:s})=>lu.fromTransferableInputs(t,e,r,s),Hc=()=>BigInt(Math.floor((new Date).getTime()/1e3)),Kc=({changeAddressesBytes:t,feeState:e,fromAddressesBytes:r,memo:s=new Uint8Array,minIssuanceTime:n=Hc(),outputs:o,utxos:a},i)=>{const u=Js(r),c=new Map;o.forEach((t=>{const e=t.assetId.value(),r=(c.get(e)??0n)+t.amount();c.set(e,r)}));const d=Yu(s),p=Wu(o),f=Au(Pu,d,p),l=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:r}),excessAVAX:0n,feeState:e,fromAddresses:u,initialComplexity:f,minIssuanceTime:n,shouldConsolidateOutputs:!0,toBurn:c,utxos:a},[Nc],i),{changeOutputs:h,inputs:m,inputUTXOs:x}=l,g=jc({inputs:m,inputUTXOs:x,minIssuanceTime:n,fromAddressesBytes:r}),b=[...o,...h].sort(fc);return new gc(new qa(Oc(i,b,m,s)),x,g)},Wc=({feeState:t,fromAddressesBytes:e,locktime:r,memo:s=new Uint8Array,minIssuanceTime:n=Hc(),sourceChainId:o,threshold:a,toAddressesBytes:i,utxos:u},c)=>{const d=Js(e),p=u.filter((t=>Ms(t.output)&&t.assetId.toString()===c.avaxAssetID)),{importedInputs:f,importedAmounts:l,inputUtxos:h}=p.reduce(((t,e)=>{const{sigIndicies:r}=pu(e.getOutputOwners(),d,n)||{};if(void 0===r)return t;const s=e.getAssetId();return{importedInputs:[...t.importedInputs,new exports.TransferableInput(e.utxoId,e.assetId,new exports.TransferInput(e.output.amt,new exports.Input(r.map((t=>new exports.Int(t))))))],importedAmounts:{...t.importedAmounts,[s]:(t.importedAmounts[s]??0n)+e.output.amount()},inputUtxos:[...t.inputUtxos,e]}}),{importedInputs:[],importedAmounts:{},inputUtxos:[]});if(0===f.length)throw new Error("no UTXOs available to import");const m=l[c.avaxAssetID],x=lu.fromTransferableInputs(f,p,n,e),g=Object.entries(l).filter((([t])=>t!==c.avaxAssetID)).map((([t,e])=>exports.TransferableOutput.fromNative(t,e,i))),b=Yu(s),y=Gu(f),w=Wu(g),I=Au(Vu,b,y,w),B=Fc({changeOutputOwners:exports.OutputOwners.fromNative(i,r,a),excessAVAX:m,feeState:t,fromAddresses:d,initialComplexity:I,minIssuanceTime:n,utxos:p},[Nc],c),{changeOutputs:T,inputs:O}=B;return new gc(new xo(new on(new exports.Int(c.networkID),es,[...g,...T].sort(fc),O,new exports.Bytes(s)),exports.Id.fromString(o),f.sort(exports.TransferableInput.compare)),h,x)},Gc=({changeAddressesBytes:t,destinationChainId:e,feeState:r,fromAddressesBytes:s,memo:n=new Uint8Array,minIssuanceTime:o=Hc(),outputs:a,utxos:i},u)=>{const c=Js(s),d=new Map;a.forEach((t=>{const e=t.assetId.value();d.set(e,(d.get(e)??0n)+t.output.amount())}));const p=Yu(n),f=Wu(a),l=Au(_u,p,f),h=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:c,initialComplexity:l,minIssuanceTime:o,toBurn:d,utxos:i},[Nc],u),{changeOutputs:m,inputs:x,inputUTXOs:g}=h,b=jc({inputs:x,inputUTXOs:g,minIssuanceTime:o,fromAddressesBytes:s});return new gc(new ho(new on(new exports.Int(u.networkID),es,m,x,new exports.Bytes(n)),exports.Id.fromString(e),[...a].sort(fc)),g,b)},Zc=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,locktime:s,memo:n=new Uint8Array,minIssuanceTime:o=Hc(),subnetOwners:a,threshold:i,utxos:u},c)=>{const d=Yu(n),p=$u(exports.OutputOwners.fromNative(a,s,i)),f=Au(Ru,d,p),l=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:Js(e),initialComplexity:f,minIssuanceTime:o,utxos:u},[Nc],c),{changeOutputs:h,inputs:m,inputUTXOs:x}=l,g=jc({inputs:m,inputUTXOs:x,minIssuanceTime:o,fromAddressesBytes:e}),b=new fo(on.fromNative(c.networkID,c.pBlockchainID,h,m,n),exports.OutputOwners.fromNative(a,s,i));return new gc(b,x,g)},$c=({changeAddressesBytes:t,chainName:e,feeState:r,fromAddressesBytes:s,fxIds:n,genesisData:o,memo:a=new Uint8Array,minIssuanceTime:i=Hc(),subnetAuth:u,subnetId:c,utxos:d,vmId:p},f)=>{const l=new exports.Bytes((new TextEncoder).encode(JSON.stringify(o))),h=exports.Input.fromNative(u),m=vu({bandwidth:n.length*zr+e.length+l.length+a.length,dbRead:0,dbWrite:0,compute:0}),x=zu(h),g=Au(ku,m,x),b=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:Js(s),initialComplexity:g,minIssuanceTime:i,utxos:d},[Nc],f),{changeOutputs:y,inputs:w,inputUTXOs:I}=b,B=jc({inputs:w,inputUTXOs:I,minIssuanceTime:i,fromAddressesBytes:s}),T=new co(on.fromNative(f.networkID,f.pBlockchainID,y,w,a),exports.Id.fromString(c),new exports.Stringpr(e),exports.Id.fromString(p),n.map(exports.Id.fromString.bind(exports.Id)),l,h);return new gc(T,I,B)},zc=({changeAddressesBytes:t,end:e,feeState:r,fromAddressesBytes:s,nodeId:n,memo:o=new Uint8Array,minIssuanceTime:a=Hc(),start:i,subnetAuth:u,subnetId:c,utxos:d,weight:p},f)=>{const l=Yu(o),h=zu(exports.Input.fromNative(u)),m=Au(Nu,l,h),x=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:Js(s),initialComplexity:m,minIssuanceTime:a,utxos:d},[Nc],f),{changeOutputs:g,inputs:b,inputUTXOs:y}=x,w=jc({inputs:b,inputUTXOs:y,minIssuanceTime:a,fromAddressesBytes:s}),I=new so(on.fromNative(f.networkID,f.pBlockchainID,g,b,o),eo.fromNative(n,i,e,p,exports.Id.fromString(c)),exports.Input.fromNative(u));return new gc(I,y,w)},Yc=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,nodeId:s,memo:n=new Uint8Array,minIssuanceTime:o=Hc(),subnetAuth:a,subnetId:i,utxos:u},c)=>{const d=Yu(n),p=zu(exports.Input.fromNative(a)),f=Au(Uu,d,p),l=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:Js(e),initialComplexity:f,minIssuanceTime:o,utxos:u},[Nc],c),{changeOutputs:h,inputs:m,inputUTXOs:x}=l,g=jc({inputs:m,inputUTXOs:x,minIssuanceTime:o,fromAddressesBytes:e}),b=new Na(on.fromNative(c.networkID,c.pBlockchainID,h,m,n),exports.NodeId.fromString(s),exports.Id.fromString(i),exports.Input.fromNative(a));return new gc(b,x,g)},Jc=({changeAddressesBytes:t,delegatorRewardsOwner:e,end:r,feeState:s,fromAddressesBytes:n,locktime:o=0n,nodeId:a,memo:i=new Uint8Array,minIssuanceTime:u=Hc(),publicKey:c,rewardAddresses:d,shares:p,signature:f,stakingAssetId:l,start:h,subnetId:m,threshold:x=1,utxos:g,weight:b},y)=>{const w=m===ts.toString(),I=l??y.avaxAssetID;if(w&&I!==y.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const B=new Map([[I,b]]),T=function(t,e){return t&&e?new Ra(new Ea(new Uint8Array(t),new Uint8Array(e))):new Da}(c,f),O=exports.OutputOwners.fromNative(d,o,x),S=exports.OutputOwners.fromNative(e,0n),v=Yu(i),A=Zu(T),E=$u(O),P=$u(S),k=Au(Du,v,A,E,P),R=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:n}),excessAVAX:0n,feeState:s,fromAddresses:Js(n),initialComplexity:k,minIssuanceTime:u,shouldConsolidateOutputs:!0,toStake:B,utxos:g},[Cc,Nc],y),{changeOutputs:D,inputs:C,inputUTXOs:N,stakeOutputs:_}=R,V=jc({inputs:C,inputUTXOs:N,minIssuanceTime:u,fromAddressesBytes:n}),U=new Oo(on.fromNative(y.networkID,y.pBlockchainID,D,C,i),eo.fromNative(a,h,r,b,exports.Id.fromString(m)),T,_,O,S,new exports.Int(p));return new gc(U,N,V)},Qc=({changeAddressesBytes:t,end:e,feeState:r,fromAddressesBytes:s,locktime:n=0n,nodeId:o,memo:a=new Uint8Array,minIssuanceTime:i=Hc(),rewardAddresses:u,stakingAssetId:c,start:d,subnetId:p,threshold:f=1,utxos:l,weight:h},m)=>{const x=p===ts.toString(),g=c??m.avaxAssetID;if(x&&g!==m.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const b=new Map([[g,h]]),y=exports.OutputOwners.fromNative(u,n,f),w=Yu(a),I=$u(y),B=Au(Cu,w,I),T=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:Js(s),initialComplexity:B,minIssuanceTime:i,shouldConsolidateOutputs:!0,toStake:b,utxos:l},[Cc,Nc],m),{changeOutputs:O,inputs:S,inputUTXOs:v,stakeOutputs:A}=T,E=jc({inputs:S,inputUTXOs:v,minIssuanceTime:i,fromAddressesBytes:s}),P=new vo(on.fromNative(m.networkID,m.pBlockchainID,O,S,a),eo.fromNative(o,d,e,h,exports.Id.fromString(p)),A,y);return new gc(P,v,E)},td=({changeAddressesBytes:t,fromAddressesBytes:e,feeState:r,locktime:s=0n,memo:n=new Uint8Array,minIssuanceTime:o=Hc(),subnetAuth:a,subnetId:i,subnetOwners:u,threshold:c=1,utxos:d},p)=>{const f=Yu(n),l=zu(exports.Input.fromNative(a)),h=$u(exports.OutputOwners.fromNative(u,s,c)),m=Au(Lu,f,l,h),x=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:e}),excessAVAX:0n,feeState:r,fromAddresses:Js(e),initialComplexity:m,minIssuanceTime:o,utxos:d},[Nc],p),{changeOutputs:g,inputs:b,inputUTXOs:y}=x,w=jc({inputs:b,inputUTXOs:y,minIssuanceTime:o,fromAddressesBytes:e});return new gc(new Va(on.fromNative(p.networkID,p.pBlockchainID,g,b,n),exports.Id.fromString(i),exports.Input.fromNative(a),exports.OutputOwners.fromNative(u,s,c)),y,w)},ed=({address:t,chainId:e,changeAddressesBytes:r,feeState:s,fromAddressesBytes:n,memo:o=new Uint8Array,minIssuanceTime:a=BigInt(Math.floor((new Date).getTime()/1e3)),subnetAuth:i,subnetId:u,utxos:c,validators:d},p)=>{if(d.find((t=>t.getWeight()<=0n)))throw new Error("Validator weight must be greater than 0");const f=Yu(o,t),l=zu(exports.Input.fromNative(i)),h=Qu(d),m=d.sort(((t,e)=>Zr(t.nodeId.toBytes(),e.nodeId.toBytes()))),x=new Map;for(const t of m)x.set(p.avaxAssetID,(x.get(p.avaxAssetID)??0n)+t.getBalance().value());const g=Au(qu,f,h,l),b=Fc({changeOutputOwners:Xc({changeAddressesBytes:r,fromAddressesBytes:n}),excessAVAX:0n,feeState:s,fromAddresses:Js(n),initialComplexity:g,minIssuanceTime:a,toBurn:x,utxos:c},[Nc],p),{changeOutputs:y,inputs:w,inputUTXOs:I}=b,B=jc({inputs:w,inputUTXOs:I,minIssuanceTime:a,fromAddressesBytes:n});return new gc(new Ha(on.fromNative(p.networkID,p.pBlockchainID,y,w,o),exports.Id.fromString(u),exports.Id.fromString(e),new exports.Bytes(t),m,exports.Input.fromNative(i)),I,B)},rd=({balance:t,blsSignature:e,changeAddressesBytes:r,feeState:s,fromAddressesBytes:n,memo:o=new Uint8Array,message:a,minIssuanceTime:i=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:u},c)=>{const d=new exports.Bytes(a),p=new Map([[c.avaxAssetID,t]]),f=Yu(o),l=Ju(d),h=Au(Fu,f,l),m=Fc({changeOutputOwners:Xc({changeAddressesBytes:r,fromAddressesBytes:n}),excessAVAX:0n,feeState:s,fromAddresses:Js(n),initialComplexity:h,minIssuanceTime:i,toBurn:p,utxos:u},[Nc],c),{changeOutputs:x,inputs:g,inputUTXOs:b}=m,y=jc({inputs:g,inputUTXOs:b,minIssuanceTime:i,fromAddressesBytes:n});return new gc(new Ja(on.fromNative(c.networkID,c.pBlockchainID,x,g,o),new exports.BigIntPr(t),exports.BlsSignature.fromSignatureBytes(e),d),b,y)},sd=({changeAddressesBytes:t,feeState:e,fromAddressesBytes:r,memo:s=new Uint8Array,message:n,minIssuanceTime:o=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:a},i)=>{const u=new exports.Bytes(n),c=Yu(s),d=Ju(u),p=Au(Xu,c,d),f=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:r}),excessAVAX:0n,feeState:e,fromAddresses:Js(r),initialComplexity:p,minIssuanceTime:o,utxos:a},[Nc],i),{changeOutputs:l,inputs:h,inputUTXOs:m}=f,x=jc({inputs:h,inputUTXOs:m,minIssuanceTime:o,fromAddressesBytes:r});return new gc(new za(on.fromNative(i.networkID,i.pBlockchainID,l,h,s),u),m,x)},nd=({balance:t,changeAddressesBytes:e,feeState:r,fromAddressesBytes:s,memo:n=new Uint8Array,minIssuanceTime:o=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:a,validationId:i},u)=>{if(t<=0n)throw new Error("Balance must be greater than 0");const c=new Map([[u.avaxAssetID,t]]),d=Yu(n),p=Au(ju,d),f=Fc({changeOutputOwners:Xc({changeAddressesBytes:e,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:Js(s),initialComplexity:p,minIssuanceTime:o,toBurn:c,utxos:a},[Nc],u),{changeOutputs:l,inputs:h,inputUTXOs:m}=f,x=jc({inputs:h,inputUTXOs:m,minIssuanceTime:o,fromAddressesBytes:s});return new gc(new Wa(on.fromNative(u.networkID,u.pBlockchainID,l,h,n),exports.Id.fromString(i),new exports.BigIntPr(t)),m,x)},od=({changeAddressesBytes:t,disableAuth:e,feeState:r,fromAddressesBytes:s,memo:n=new Uint8Array,minIssuanceTime:o=BigInt(Math.floor((new Date).getTime()/1e3)),utxos:a,validationId:i},u)=>{const c=exports.Input.fromNative(e),d=Yu(n),p=zu(c),f=Au(Hu,d,p),l=Fc({changeOutputOwners:Xc({changeAddressesBytes:t,fromAddressesBytes:s}),excessAVAX:0n,feeState:r,fromAddresses:Js(s),initialComplexity:f,minIssuanceTime:o,utxos:a},[Nc],u),{changeOutputs:h,inputs:m,inputUTXOs:x}=l,g=jc({inputs:m,inputUTXOs:x,minIssuanceTime:o,fromAddressesBytes:s});return new gc(new Za(on.fromNative(u.networkID,u.pBlockchainID,h,m,n),exports.Id.fromString(i),c),x,g)};var ad=Object.freeze({__proto__:null,newAddPermissionlessDelegatorTx:Qc,newAddPermissionlessValidatorTx:Jc,newAddSubnetValidatorTx:zc,newBaseTx:Kc,newConvertSubnetToL1Tx:ed,newCreateChainTx:$c,newCreateSubnetTx:Zc,newDisableL1ValidatorTx:od,newExportTx:Gc,newImportTx:Wc,newIncreaseL1ValidatorBalanceTx:nd,newRegisterL1ValidatorTx:rd,newRemoveSubnetValidatorTx:Yc,newSetL1ValidatorWeightTx:sd,newTransferSubnetOwnershipTx:td});class id extends dc{constructor(t){super(t,"/ext/bc/P","platform",ei())}getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getCurrentValidators(t){return this.callRpc("getCurrentValidators",t)}getPendingValidators(t){return this.callRpc("getPendingValidators",t)}async getRewardUTXOs(t){const e=await this.callRpc("getRewardUTXOs",t);return{...e,utxos:e.utxos.map((t=>ei().unpack(Te(t),exports.Utxo)))}}async getStake(t){const e=await this.callRpc("getStake",t);return{...e,stakedOutputs:e.stakedOutputs.map((t=>ei().unpack(Te(t),exports.TransferableOutput)))}}getValidatorsAt(t){return this.callRpc("getValidatorsAt",t)}getCurrentSupply(){return this.callRpc("getCurrentSupply")}getMaxStakeAmount(t){return this.callRpc("getMaxStakeAmount",t)}async getBalance(t){const e=await this.callRpc("getBalance",t);return{balance:BigInt(e.balance),unlocked:BigInt(e.unlocked),lockedStakeable:BigInt(e.lockedStakeable),lockedNotStakeable:BigInt(e.lockedNotStakeable),utxoIDs:e.utxoIDs}}getBlockchains(){return this.callRpc("getBlockchains")}getBlockchainStatus(t){return this.callRpc("getBlockchainStatus",{blockchainID:t})}getHeight(){return this.callRpc("getHeight")}getMinStake(){return this.callRpc("getMinStake")}getStakingAssetID(t){return this.callRpc("getStakingAssetID",t)}getSubnet(t){return this.callRpc("getSubnet",t)}getSubnets(t){return this.callRpc("getSubnets",t)}getTimestamp(){return this.callRpc("getTimestamp")}getTotalStake(t){return this.callRpc("getTotalStake",{subnetID:t})}getTxStatus(t){return this.callRpc("getTxStatus",t)}sampleValidators(t){return this.callRpc("sampleValidators",t)}validatedBy(t){return this.callRpc("validatedBy",t)}validates(t){return this.callRpc("validates",t)}async getFeeConfig(){const t=await this.callRpc("getFeeConfig"),{weights:e,maxCapacity:r,maxPerSecond:s,targetPerSecond:n,minPrice:o,excessConversionConstant:a}=t,[i,u,c,d]=e;return{weights:vu({bandwidth:i,dbRead:u,dbWrite:c,compute:d}),maxCapacity:BigInt(r),maxPerSecond:BigInt(s),targetPerSecond:BigInt(n),minPrice:BigInt(o),excessConversionConstant:BigInt(a)}}async getFeeState(){const t=await this.callRpc("getFeeState");return{capacity:BigInt(t.capacity),excess:BigInt(t.excess),price:BigInt(t.price),timestamp:t.timestamp}}async getL1Validator(t){const e=await this.callRpc("getL1Validator",{validationID:t}),r=exports.PChainOwner.fromNative(e.deactivationOwner.addresses.map((t=>u(t)[2])),Number(e.deactivationOwner.threshold)),s=exports.PChainOwner.fromNative(e.remainingBalanceOwner.addresses.map((t=>u(t)[2])),Number(e.remainingBalanceOwner.threshold));return{balance:BigInt(e.balance),nodeID:e.nodeID,publicKey:e.publicKey,subnetID:e.subnetID,weight:BigInt(e.weight),deactivationOwner:r,remainingBalanceOwner:s,startTime:BigInt(e.startTime),height:BigInt(e.height),minNonce:BigInt(e.minNonce)}}}var ud=Object.freeze({__proto__:null,INTRINSIC_ADD_PERMISSIONLESS_DELEGATOR_TX_COMPLEXITIES:Cu,INTRINSIC_ADD_PERMISSIONLESS_VALIDATOR_TX_COMPLEXITIES:Du,INTRINSIC_ADD_SUBNET_VALIDATOR_TX_COMPLEXITIES:Nu,INTRINSIC_BASE_TX_COMPLEXITIES:Pu,INTRINSIC_CONVERT_SUBNET_TO_L1_TX_COMPLEXITIES:qu,INTRINSIC_CREATE_CHAIN_TX_COMPLEXITIES:ku,INTRINSIC_CREATE_SUBNET_TX_COMPLEXITIES:Ru,INTRINSIC_DISABLE_L1_VALIDATOR_TX_COMPLEXITIES:Hu,INTRINSIC_EXPORT_TX_COMPLEXITIES:_u,INTRINSIC_IMPORT_TX_COMPLEXITIES:Vu,INTRINSIC_INCREASE_L1_VALIDATOR_BALANCE_TX_COMPLEXITIES:ju,INTRINSIC_REGISTER_L1_VALIDATOR_TX_COMPLEXITIES:Fu,INTRINSIC_REMOVE_SUBNET_VALIDATOR_TX_COMPLEXITIES:Uu,INTRINSIC_SET_L1_VALIDATOR_WEIGHT_TX_COMPLEXITIES:Xu,INTRINSIC_TRANSFER_SUBNET_OWNERSHIP_TX_COMPLEXITIES:Lu,PVMApi:id,calculateFee:sc,e:ad,getAuthComplexity:zu,getBytesComplexity:Yu,getInputComplexity:Gu,getL1ValidatorsComplexity:Qu,getOutputComplexity:Wu,getOwnerComplexity:$u,getSignerComplexity:Zu,getTxComplexity:rc,newAddPermissionlessDelegatorTx:Qc,newAddPermissionlessValidatorTx:Jc,newAddSubnetValidatorTx:zc,newBaseTx:Kc,newConvertSubnetToL1Tx:ed,newCreateChainTx:$c,newCreateSubnetTx:Zc,newDisableL1ValidatorTx:od,newExportTx:Gc,newImportTx:Wc,newIncreaseL1ValidatorBalanceTx:nd,newRegisterL1ValidatorTx:rd,newRemoveSubnetValidatorTx:Yc,newSetL1ValidatorWeightTx:sd,newTransferSubnetOwnershipTx:td});var cd=Object.freeze({__proto__:null,getContextFromURI:async(t,e="AVAX")=>{const r=new id(t),s=new pc(t),{assetID:n}=await s.getAssetDescription(e),o=new Pc(t),{txFee:a,createAssetTxFee:i}=await s.getTxFee(),{blockchainID:u}=await o.getBlockchainId("X"),{blockchainID:c}=await o.getBlockchainId("P"),{blockchainID:d}=await o.getBlockchainId("C"),{networkID:p}=await o.getNetworkId(),f=Number(p),l=await r.getFeeConfig();return Object.freeze({xBlockchainID:u,pBlockchainID:c,cBlockchainID:d,avaxAssetID:n,baseTxFee:a,createAssetTxFee:i,networkID:f,hrp:bs(f),platformFeeConfig:l})}});class dd extends uc{constructor(t){super(t,"/ext/bc/C/rpc")}async getBaseFee(){return BigInt(await this.callRpc("eth_baseFee"))}}function pd(t,e,r,s,n,o,a,i,u){return e*iu(fd(t,r,s,n,o,e,a,i,u))}function fd(t,e,r,s,n,o,a,i,u){i=i??t.avaxAssetID;const{threshold:c,locktime:d}=(t=>({locktime:0n,threshold:1,...t}))(u),p=[];t.avaxAssetID===i?p.push({assetId:t.avaxAssetID,amount:e+o}):(p.push({amount:o,assetId:t.avaxAssetID}),p.push({amount:e,assetId:i}));const f=p.map((({assetId:t,amount:e})=>new Ln(new exports.Address(s),new exports.BigIntPr(e),exports.Id.fromString(t),new exports.BigIntPr(a)))),l=[new exports.TransferableOutput(exports.Id.fromString(i),new exports.TransferOutput(new exports.BigIntPr(e),new exports.OutputOwners(new exports.BigIntPr(d),new exports.Int(c),Js(n))))];return f.sort(Ln.compare),new Ec(new qn(new exports.Int(t.networkID),exports.Id.fromString(t.cBlockchainID),exports.Id.fromString(r),f,l),[],new lu([new fu([[new exports.Address(s),0]])]))}function ld(t,e,r,s,n,o=0n,a=t.avaxAssetID){const i=Js(r),u=new Map;let c=[],d=[],p=0n;const f=[];s.forEach((t=>{const e=t.getAssetId(),r=t.output,s=r.amount();let n=s;a&&o&&p<o&&a===e&&(p+=n,p>o?(n=p-o,p=o):n=0n);const d=pu(r.outputOwners,i,0n);if(!d)return;const l=new exports.TransferableInput(t.utxoId,t.assetId,exports.TransferInput.fromNative(s,d.sigIndicies));c.push(l),f.push(t);const h=u.get(e);h&&(n+=h),u.set(e,n)}));for(const[t,r]of u.entries())d.push(new Xn(new exports.Address(e),new exports.BigIntPr(r),exports.Id.fromString(t)));c=c.sort(exports.TransferableInput.compare);const l=lu.fromTransferableInputs(c,s,0n,r);d=d.sort(lc);const h=new Kn(new exports.Int(t.networkID),exports.Id.fromString(t.cBlockchainID),exports.Id.fromString(n),c,d);return new Ec(h,f,l)}var hd=Object.freeze({__proto__:null,EVMApi:class extends cc{ethAPI;constructor(t){super(t,"/ext/bc/C/avax","avax",Gn()),this.ethAPI=new dd(t)}getAtomicTx=async t=>{const e=await this.callRpc("getAtomicTx",{...t,encoding:"hex"});return this.manager.unpack(Te(e.tx),oi)};getBaseFee(){return this.ethAPI.getBaseFee()}getAtomicTxStatus(t){return this.callRpc("getAtomicTxStatus",{txID:t})}},estimateExportCost:pd,newExportTx:fd,newExportTxFromBaseFee:function(t,e,r,s,n,o,a,i,u){return fd(t,r,s,n,o,pd(t,e,r,s,n,o,a,i,u),a,i,u)},newImportTx:ld,newImportTxFromBaseFee:function(t,e,r,s,n,o=0n,a){const i=function(t,e,r,s,n,o=0n,a){const i=ld(t,e,r,s,n,o,a),u=iu(i);return o*u}(t,e,r,s,n,o,a);return ld(t,e,r,s,n,i,a)}});exports.AVM=Ae,exports.Common=Sc,exports.Context=cd,exports.EVM=Ee,exports.EVMUnsignedTx=Ec,exports.PVM=Pe,exports.TypeRegistry=Qs,exports.UnsignedTx=gc,exports.ValidVMs=ke,exports.addTxSignatures=async({unsignedTx:t,privateKeys:e})=>{const r=t.toBytes();await Promise.all(e.map((async e=>{const s=Ta(e);if(t.hasPubkey(s)){const s=await wa(r,e);t.addSignature(s)}})))},exports.avaxSerial=ui,exports.avm=Ac,exports.avmSerial=fi,exports.bls=Wr,exports.evm=hd,exports.evmSerial=bi,exports.info=kc,exports.networkIDs=ws,exports.pvm=ud,exports.pvmSerial=au,exports.secp256k1=Aa,exports.utils=oc;
